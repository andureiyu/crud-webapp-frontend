
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model group_session_participants
 * 
 */
export type group_session_participants = $Result.DefaultSelection<Prisma.$group_session_participantsPayload>
/**
 * Model group_sessions
 * 
 */
export type group_sessions = $Result.DefaultSelection<Prisma.$group_sessionsPayload>
/**
 * Model messages
 * 
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model resources
 * 
 */
export type resources = $Result.DefaultSelection<Prisma.$resourcesPayload>
/**
 * Model session_notes
 * 
 */
export type session_notes = $Result.DefaultSelection<Prisma.$session_notesPayload>
/**
 * Model session_ratings
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type session_ratings = $Result.DefaultSelection<Prisma.$session_ratingsPayload>
/**
 * Model session_resources
 * 
 */
export type session_resources = $Result.DefaultSelection<Prisma.$session_resourcesPayload>
/**
 * Model sessions
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model student_subject_interests
 * 
 */
export type student_subject_interests = $Result.DefaultSelection<Prisma.$student_subject_interestsPayload>
/**
 * Model students
 * 
 */
export type students = $Result.DefaultSelection<Prisma.$studentsPayload>
/**
 * Model subject_categories
 * 
 */
export type subject_categories = $Result.DefaultSelection<Prisma.$subject_categoriesPayload>
/**
 * Model subjects
 * 
 */
export type subjects = $Result.DefaultSelection<Prisma.$subjectsPayload>
/**
 * Model subscriptions
 * 
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>
/**
 * Model tutor_availability
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type tutor_availability = $Result.DefaultSelection<Prisma.$tutor_availabilityPayload>
/**
 * Model tutor_subjects
 * 
 */
export type tutor_subjects = $Result.DefaultSelection<Prisma.$tutor_subjectsPayload>
/**
 * Model tutors
 * 
 */
export type tutors = $Result.DefaultSelection<Prisma.$tutorsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Group_session_participants
 * const group_session_participants = await prisma.group_session_participants.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Group_session_participants
   * const group_session_participants = await prisma.group_session_participants.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.group_session_participants`: Exposes CRUD operations for the **group_session_participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_session_participants
    * const group_session_participants = await prisma.group_session_participants.findMany()
    * ```
    */
  get group_session_participants(): Prisma.group_session_participantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group_sessions`: Exposes CRUD operations for the **group_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_sessions
    * const group_sessions = await prisma.group_sessions.findMany()
    * ```
    */
  get group_sessions(): Prisma.group_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resources`: Exposes CRUD operations for the **resources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resources.findMany()
    * ```
    */
  get resources(): Prisma.resourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session_notes`: Exposes CRUD operations for the **session_notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_notes
    * const session_notes = await prisma.session_notes.findMany()
    * ```
    */
  get session_notes(): Prisma.session_notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session_ratings`: Exposes CRUD operations for the **session_ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_ratings
    * const session_ratings = await prisma.session_ratings.findMany()
    * ```
    */
  get session_ratings(): Prisma.session_ratingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session_resources`: Exposes CRUD operations for the **session_resources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_resources
    * const session_resources = await prisma.session_resources.findMany()
    * ```
    */
  get session_resources(): Prisma.session_resourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student_subject_interests`: Exposes CRUD operations for the **student_subject_interests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_subject_interests
    * const student_subject_interests = await prisma.student_subject_interests.findMany()
    * ```
    */
  get student_subject_interests(): Prisma.student_subject_interestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.studentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject_categories`: Exposes CRUD operations for the **subject_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subject_categories
    * const subject_categories = await prisma.subject_categories.findMany()
    * ```
    */
  get subject_categories(): Prisma.subject_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.subjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutor_availability`: Exposes CRUD operations for the **tutor_availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutor_availabilities
    * const tutor_availabilities = await prisma.tutor_availability.findMany()
    * ```
    */
  get tutor_availability(): Prisma.tutor_availabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutor_subjects`: Exposes CRUD operations for the **tutor_subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutor_subjects
    * const tutor_subjects = await prisma.tutor_subjects.findMany()
    * ```
    */
  get tutor_subjects(): Prisma.tutor_subjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutors`: Exposes CRUD operations for the **tutors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutors
    * const tutors = await prisma.tutors.findMany()
    * ```
    */
  get tutors(): Prisma.tutorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    group_session_participants: 'group_session_participants',
    group_sessions: 'group_sessions',
    messages: 'messages',
    notifications: 'notifications',
    payments: 'payments',
    resources: 'resources',
    session_notes: 'session_notes',
    session_ratings: 'session_ratings',
    session_resources: 'session_resources',
    sessions: 'sessions',
    student_subject_interests: 'student_subject_interests',
    students: 'students',
    subject_categories: 'subject_categories',
    subjects: 'subjects',
    subscriptions: 'subscriptions',
    tutor_availability: 'tutor_availability',
    tutor_subjects: 'tutor_subjects',
    tutors: 'tutors',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "group_session_participants" | "group_sessions" | "messages" | "notifications" | "payments" | "resources" | "session_notes" | "session_ratings" | "session_resources" | "sessions" | "student_subject_interests" | "students" | "subject_categories" | "subjects" | "subscriptions" | "tutor_availability" | "tutor_subjects" | "tutors" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      group_session_participants: {
        payload: Prisma.$group_session_participantsPayload<ExtArgs>
        fields: Prisma.group_session_participantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_session_participantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_session_participantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>
          }
          findFirst: {
            args: Prisma.group_session_participantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_session_participantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>
          }
          findMany: {
            args: Prisma.group_session_participantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>[]
          }
          create: {
            args: Prisma.group_session_participantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>
          }
          createMany: {
            args: Prisma.group_session_participantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.group_session_participantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>
          }
          update: {
            args: Prisma.group_session_participantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>
          }
          deleteMany: {
            args: Prisma.group_session_participantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_session_participantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.group_session_participantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_session_participantsPayload>
          }
          aggregate: {
            args: Prisma.Group_session_participantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_session_participants>
          }
          groupBy: {
            args: Prisma.group_session_participantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_session_participantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_session_participantsCountArgs<ExtArgs>
            result: $Utils.Optional<Group_session_participantsCountAggregateOutputType> | number
          }
        }
      }
      group_sessions: {
        payload: Prisma.$group_sessionsPayload<ExtArgs>
        fields: Prisma.group_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>
          }
          findFirst: {
            args: Prisma.group_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>
          }
          findMany: {
            args: Prisma.group_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>[]
          }
          create: {
            args: Prisma.group_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>
          }
          createMany: {
            args: Prisma.group_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.group_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>
          }
          update: {
            args: Prisma.group_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.group_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.group_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Group_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_sessions>
          }
          groupBy: {
            args: Prisma.group_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Group_sessionsCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      resources: {
        payload: Prisma.$resourcesPayload<ExtArgs>
        fields: Prisma.resourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.resourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.resourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          findFirst: {
            args: Prisma.resourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.resourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          findMany: {
            args: Prisma.resourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>[]
          }
          create: {
            args: Prisma.resourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          createMany: {
            args: Prisma.resourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.resourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          update: {
            args: Prisma.resourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          deleteMany: {
            args: Prisma.resourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.resourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.resourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$resourcesPayload>
          }
          aggregate: {
            args: Prisma.ResourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResources>
          }
          groupBy: {
            args: Prisma.resourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.resourcesCountArgs<ExtArgs>
            result: $Utils.Optional<ResourcesCountAggregateOutputType> | number
          }
        }
      }
      session_notes: {
        payload: Prisma.$session_notesPayload<ExtArgs>
        fields: Prisma.session_notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>
          }
          findFirst: {
            args: Prisma.session_notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>
          }
          findMany: {
            args: Prisma.session_notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>[]
          }
          create: {
            args: Prisma.session_notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>
          }
          createMany: {
            args: Prisma.session_notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.session_notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>
          }
          update: {
            args: Prisma.session_notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>
          }
          deleteMany: {
            args: Prisma.session_notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.session_notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_notesPayload>
          }
          aggregate: {
            args: Prisma.Session_notesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_notes>
          }
          groupBy: {
            args: Prisma.session_notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_notesGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_notesCountArgs<ExtArgs>
            result: $Utils.Optional<Session_notesCountAggregateOutputType> | number
          }
        }
      }
      session_ratings: {
        payload: Prisma.$session_ratingsPayload<ExtArgs>
        fields: Prisma.session_ratingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_ratingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_ratingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>
          }
          findFirst: {
            args: Prisma.session_ratingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_ratingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>
          }
          findMany: {
            args: Prisma.session_ratingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>[]
          }
          create: {
            args: Prisma.session_ratingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>
          }
          createMany: {
            args: Prisma.session_ratingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.session_ratingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>
          }
          update: {
            args: Prisma.session_ratingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>
          }
          deleteMany: {
            args: Prisma.session_ratingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_ratingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.session_ratingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_ratingsPayload>
          }
          aggregate: {
            args: Prisma.Session_ratingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_ratings>
          }
          groupBy: {
            args: Prisma.session_ratingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_ratingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_ratingsCountArgs<ExtArgs>
            result: $Utils.Optional<Session_ratingsCountAggregateOutputType> | number
          }
        }
      }
      session_resources: {
        payload: Prisma.$session_resourcesPayload<ExtArgs>
        fields: Prisma.session_resourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_resourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_resourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>
          }
          findFirst: {
            args: Prisma.session_resourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_resourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>
          }
          findMany: {
            args: Prisma.session_resourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>[]
          }
          create: {
            args: Prisma.session_resourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>
          }
          createMany: {
            args: Prisma.session_resourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.session_resourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>
          }
          update: {
            args: Prisma.session_resourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>
          }
          deleteMany: {
            args: Prisma.session_resourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_resourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.session_resourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_resourcesPayload>
          }
          aggregate: {
            args: Prisma.Session_resourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_resources>
          }
          groupBy: {
            args: Prisma.session_resourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_resourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_resourcesCountArgs<ExtArgs>
            result: $Utils.Optional<Session_resourcesCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      student_subject_interests: {
        payload: Prisma.$student_subject_interestsPayload<ExtArgs>
        fields: Prisma.student_subject_interestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_subject_interestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_subject_interestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>
          }
          findFirst: {
            args: Prisma.student_subject_interestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_subject_interestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>
          }
          findMany: {
            args: Prisma.student_subject_interestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>[]
          }
          create: {
            args: Prisma.student_subject_interestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>
          }
          createMany: {
            args: Prisma.student_subject_interestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_subject_interestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>
          }
          update: {
            args: Prisma.student_subject_interestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>
          }
          deleteMany: {
            args: Prisma.student_subject_interestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_subject_interestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_subject_interestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_subject_interestsPayload>
          }
          aggregate: {
            args: Prisma.Student_subject_interestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_subject_interests>
          }
          groupBy: {
            args: Prisma.student_subject_interestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_subject_interestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_subject_interestsCountArgs<ExtArgs>
            result: $Utils.Optional<Student_subject_interestsCountAggregateOutputType> | number
          }
        }
      }
      students: {
        payload: Prisma.$studentsPayload<ExtArgs>
        fields: Prisma.studentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findFirst: {
            args: Prisma.studentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findMany: {
            args: Prisma.studentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          create: {
            args: Prisma.studentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          createMany: {
            args: Prisma.studentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.studentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          update: {
            args: Prisma.studentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          deleteMany: {
            args: Prisma.studentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.studentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      subject_categories: {
        payload: Prisma.$subject_categoriesPayload<ExtArgs>
        fields: Prisma.subject_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subject_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subject_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>
          }
          findFirst: {
            args: Prisma.subject_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subject_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>
          }
          findMany: {
            args: Prisma.subject_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>[]
          }
          create: {
            args: Prisma.subject_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>
          }
          createMany: {
            args: Prisma.subject_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subject_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>
          }
          update: {
            args: Prisma.subject_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.subject_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subject_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subject_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Subject_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject_categories>
          }
          groupBy: {
            args: Prisma.subject_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Subject_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.subject_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Subject_categoriesCountAggregateOutputType> | number
          }
        }
      }
      subjects: {
        payload: Prisma.$subjectsPayload<ExtArgs>
        fields: Prisma.subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findFirst: {
            args: Prisma.subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findMany: {
            args: Prisma.subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          create: {
            args: Prisma.subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          createMany: {
            args: Prisma.subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          update: {
            args: Prisma.subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          deleteMany: {
            args: Prisma.subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>
        fields: Prisma.subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      tutor_availability: {
        payload: Prisma.$tutor_availabilityPayload<ExtArgs>
        fields: Prisma.tutor_availabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tutor_availabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tutor_availabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>
          }
          findFirst: {
            args: Prisma.tutor_availabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tutor_availabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>
          }
          findMany: {
            args: Prisma.tutor_availabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>[]
          }
          create: {
            args: Prisma.tutor_availabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>
          }
          createMany: {
            args: Prisma.tutor_availabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tutor_availabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>
          }
          update: {
            args: Prisma.tutor_availabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>
          }
          deleteMany: {
            args: Prisma.tutor_availabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tutor_availabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tutor_availabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_availabilityPayload>
          }
          aggregate: {
            args: Prisma.Tutor_availabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutor_availability>
          }
          groupBy: {
            args: Prisma.tutor_availabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tutor_availabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.tutor_availabilityCountArgs<ExtArgs>
            result: $Utils.Optional<Tutor_availabilityCountAggregateOutputType> | number
          }
        }
      }
      tutor_subjects: {
        payload: Prisma.$tutor_subjectsPayload<ExtArgs>
        fields: Prisma.tutor_subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tutor_subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tutor_subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>
          }
          findFirst: {
            args: Prisma.tutor_subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tutor_subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>
          }
          findMany: {
            args: Prisma.tutor_subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>[]
          }
          create: {
            args: Prisma.tutor_subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>
          }
          createMany: {
            args: Prisma.tutor_subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tutor_subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>
          }
          update: {
            args: Prisma.tutor_subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>
          }
          deleteMany: {
            args: Prisma.tutor_subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tutor_subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tutor_subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutor_subjectsPayload>
          }
          aggregate: {
            args: Prisma.Tutor_subjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutor_subjects>
          }
          groupBy: {
            args: Prisma.tutor_subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tutor_subjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tutor_subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<Tutor_subjectsCountAggregateOutputType> | number
          }
        }
      }
      tutors: {
        payload: Prisma.$tutorsPayload<ExtArgs>
        fields: Prisma.tutorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tutorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tutorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>
          }
          findFirst: {
            args: Prisma.tutorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tutorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>
          }
          findMany: {
            args: Prisma.tutorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>[]
          }
          create: {
            args: Prisma.tutorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>
          }
          createMany: {
            args: Prisma.tutorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tutorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>
          }
          update: {
            args: Prisma.tutorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>
          }
          deleteMany: {
            args: Prisma.tutorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tutorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tutorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutorsPayload>
          }
          aggregate: {
            args: Prisma.TutorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutors>
          }
          groupBy: {
            args: Prisma.tutorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tutorsCountArgs<ExtArgs>
            result: $Utils.Optional<TutorsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    group_session_participants?: group_session_participantsOmit
    group_sessions?: group_sessionsOmit
    messages?: messagesOmit
    notifications?: notificationsOmit
    payments?: paymentsOmit
    resources?: resourcesOmit
    session_notes?: session_notesOmit
    session_ratings?: session_ratingsOmit
    session_resources?: session_resourcesOmit
    sessions?: sessionsOmit
    student_subject_interests?: student_subject_interestsOmit
    students?: studentsOmit
    subject_categories?: subject_categoriesOmit
    subjects?: subjectsOmit
    subscriptions?: subscriptionsOmit
    tutor_availability?: tutor_availabilityOmit
    tutor_subjects?: tutor_subjectsOmit
    tutors?: tutorsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Group_sessionsCountOutputType
   */

  export type Group_sessionsCountOutputType = {
    group_session_participants: number
  }

  export type Group_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_session_participants?: boolean | Group_sessionsCountOutputTypeCountGroup_session_participantsArgs
  }

  // Custom InputTypes
  /**
   * Group_sessionsCountOutputType without action
   */
  export type Group_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group_sessionsCountOutputType
     */
    select?: Group_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Group_sessionsCountOutputType without action
   */
  export type Group_sessionsCountOutputTypeCountGroup_session_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_session_participantsWhereInput
  }


  /**
   * Count Type ResourcesCountOutputType
   */

  export type ResourcesCountOutputType = {
    session_resources: number
  }

  export type ResourcesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session_resources?: boolean | ResourcesCountOutputTypeCountSession_resourcesArgs
  }

  // Custom InputTypes
  /**
   * ResourcesCountOutputType without action
   */
  export type ResourcesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourcesCountOutputType
     */
    select?: ResourcesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourcesCountOutputType without action
   */
  export type ResourcesCountOutputTypeCountSession_resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_resourcesWhereInput
  }


  /**
   * Count Type SessionsCountOutputType
   */

  export type SessionsCountOutputType = {
    payments: number
    session_notes: number
    session_resources: number
  }

  export type SessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SessionsCountOutputTypeCountPaymentsArgs
    session_notes?: boolean | SessionsCountOutputTypeCountSession_notesArgs
    session_resources?: boolean | SessionsCountOutputTypeCountSession_resourcesArgs
  }

  // Custom InputTypes
  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionsCountOutputType
     */
    select?: SessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountSession_notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_notesWhereInput
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountSession_resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_resourcesWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    group_session_participants: number
    session_ratings: number
    sessions: number
    student_subject_interests: number
    subscriptions: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_session_participants?: boolean | StudentsCountOutputTypeCountGroup_session_participantsArgs
    session_ratings?: boolean | StudentsCountOutputTypeCountSession_ratingsArgs
    sessions?: boolean | StudentsCountOutputTypeCountSessionsArgs
    student_subject_interests?: boolean | StudentsCountOutputTypeCountStudent_subject_interestsArgs
    subscriptions?: boolean | StudentsCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountGroup_session_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_session_participantsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountSession_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_ratingsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_subject_interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_subject_interestsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
  }


  /**
   * Count Type Subject_categoriesCountOutputType
   */

  export type Subject_categoriesCountOutputType = {
    subjects: number
  }

  export type Subject_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | Subject_categoriesCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * Subject_categoriesCountOutputType without action
   */
  export type Subject_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject_categoriesCountOutputType
     */
    select?: Subject_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Subject_categoriesCountOutputType without action
   */
  export type Subject_categoriesCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectsWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    group_sessions: number
    resources: number
    sessions: number
    student_subject_interests: number
    tutor_subjects: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_sessions?: boolean | SubjectsCountOutputTypeCountGroup_sessionsArgs
    resources?: boolean | SubjectsCountOutputTypeCountResourcesArgs
    sessions?: boolean | SubjectsCountOutputTypeCountSessionsArgs
    student_subject_interests?: boolean | SubjectsCountOutputTypeCountStudent_subject_interestsArgs
    tutor_subjects?: boolean | SubjectsCountOutputTypeCountTutor_subjectsArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountGroup_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_sessionsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourcesWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountStudent_subject_interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_subject_interestsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountTutor_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutor_subjectsWhereInput
  }


  /**
   * Count Type TutorsCountOutputType
   */

  export type TutorsCountOutputType = {
    group_sessions: number
    session_ratings: number
    sessions: number
    tutor_availability: number
    tutor_subjects: number
  }

  export type TutorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_sessions?: boolean | TutorsCountOutputTypeCountGroup_sessionsArgs
    session_ratings?: boolean | TutorsCountOutputTypeCountSession_ratingsArgs
    sessions?: boolean | TutorsCountOutputTypeCountSessionsArgs
    tutor_availability?: boolean | TutorsCountOutputTypeCountTutor_availabilityArgs
    tutor_subjects?: boolean | TutorsCountOutputTypeCountTutor_subjectsArgs
  }

  // Custom InputTypes
  /**
   * TutorsCountOutputType without action
   */
  export type TutorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorsCountOutputType
     */
    select?: TutorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutorsCountOutputType without action
   */
  export type TutorsCountOutputTypeCountGroup_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_sessionsWhereInput
  }

  /**
   * TutorsCountOutputType without action
   */
  export type TutorsCountOutputTypeCountSession_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_ratingsWhereInput
  }

  /**
   * TutorsCountOutputType without action
   */
  export type TutorsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }

  /**
   * TutorsCountOutputType without action
   */
  export type TutorsCountOutputTypeCountTutor_availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutor_availabilityWhereInput
  }

  /**
   * TutorsCountOutputType without action
   */
  export type TutorsCountOutputTypeCountTutor_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutor_subjectsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    messages_messages_sender_idTousers: number
    messages_messages_recipient_idTousers: number
    notifications: number
    resources: number
    session_notes: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages_messages_sender_idTousers?: boolean | UsersCountOutputTypeCountMessages_messages_sender_idTousersArgs
    messages_messages_recipient_idTousers?: boolean | UsersCountOutputTypeCountMessages_messages_recipient_idTousersArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    resources?: boolean | UsersCountOutputTypeCountResourcesArgs
    session_notes?: boolean | UsersCountOutputTypeCountSession_notesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessages_messages_sender_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessages_messages_recipient_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourcesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSession_notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_notesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model group_session_participants
   */

  export type AggregateGroup_session_participants = {
    _count: Group_session_participantsCountAggregateOutputType | null
    _avg: Group_session_participantsAvgAggregateOutputType | null
    _sum: Group_session_participantsSumAggregateOutputType | null
    _min: Group_session_participantsMinAggregateOutputType | null
    _max: Group_session_participantsMaxAggregateOutputType | null
  }

  export type Group_session_participantsAvgAggregateOutputType = {
    participation_id: number | null
    group_session_id: number | null
    student_id: number | null
  }

  export type Group_session_participantsSumAggregateOutputType = {
    participation_id: number | null
    group_session_id: number | null
    student_id: number | null
  }

  export type Group_session_participantsMinAggregateOutputType = {
    participation_id: number | null
    group_session_id: number | null
    student_id: number | null
    registration_time: Date | null
    payment_status: string | null
    attended: boolean | null
  }

  export type Group_session_participantsMaxAggregateOutputType = {
    participation_id: number | null
    group_session_id: number | null
    student_id: number | null
    registration_time: Date | null
    payment_status: string | null
    attended: boolean | null
  }

  export type Group_session_participantsCountAggregateOutputType = {
    participation_id: number
    group_session_id: number
    student_id: number
    registration_time: number
    payment_status: number
    attended: number
    _all: number
  }


  export type Group_session_participantsAvgAggregateInputType = {
    participation_id?: true
    group_session_id?: true
    student_id?: true
  }

  export type Group_session_participantsSumAggregateInputType = {
    participation_id?: true
    group_session_id?: true
    student_id?: true
  }

  export type Group_session_participantsMinAggregateInputType = {
    participation_id?: true
    group_session_id?: true
    student_id?: true
    registration_time?: true
    payment_status?: true
    attended?: true
  }

  export type Group_session_participantsMaxAggregateInputType = {
    participation_id?: true
    group_session_id?: true
    student_id?: true
    registration_time?: true
    payment_status?: true
    attended?: true
  }

  export type Group_session_participantsCountAggregateInputType = {
    participation_id?: true
    group_session_id?: true
    student_id?: true
    registration_time?: true
    payment_status?: true
    attended?: true
    _all?: true
  }

  export type Group_session_participantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_session_participants to aggregate.
     */
    where?: group_session_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_session_participants to fetch.
     */
    orderBy?: group_session_participantsOrderByWithRelationInput | group_session_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_session_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_session_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_session_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_session_participants
    **/
    _count?: true | Group_session_participantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_session_participantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_session_participantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_session_participantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_session_participantsMaxAggregateInputType
  }

  export type GetGroup_session_participantsAggregateType<T extends Group_session_participantsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_session_participants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_session_participants[P]>
      : GetScalarType<T[P], AggregateGroup_session_participants[P]>
  }




  export type group_session_participantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_session_participantsWhereInput
    orderBy?: group_session_participantsOrderByWithAggregationInput | group_session_participantsOrderByWithAggregationInput[]
    by: Group_session_participantsScalarFieldEnum[] | Group_session_participantsScalarFieldEnum
    having?: group_session_participantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_session_participantsCountAggregateInputType | true
    _avg?: Group_session_participantsAvgAggregateInputType
    _sum?: Group_session_participantsSumAggregateInputType
    _min?: Group_session_participantsMinAggregateInputType
    _max?: Group_session_participantsMaxAggregateInputType
  }

  export type Group_session_participantsGroupByOutputType = {
    participation_id: number
    group_session_id: number
    student_id: number
    registration_time: Date | null
    payment_status: string | null
    attended: boolean | null
    _count: Group_session_participantsCountAggregateOutputType | null
    _avg: Group_session_participantsAvgAggregateOutputType | null
    _sum: Group_session_participantsSumAggregateOutputType | null
    _min: Group_session_participantsMinAggregateOutputType | null
    _max: Group_session_participantsMaxAggregateOutputType | null
  }

  type GetGroup_session_participantsGroupByPayload<T extends group_session_participantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_session_participantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_session_participantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_session_participantsGroupByOutputType[P]>
            : GetScalarType<T[P], Group_session_participantsGroupByOutputType[P]>
        }
      >
    >


  export type group_session_participantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    participation_id?: boolean
    group_session_id?: boolean
    student_id?: boolean
    registration_time?: boolean
    payment_status?: boolean
    attended?: boolean
    group_sessions?: boolean | group_sessionsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group_session_participants"]>



  export type group_session_participantsSelectScalar = {
    participation_id?: boolean
    group_session_id?: boolean
    student_id?: boolean
    registration_time?: boolean
    payment_status?: boolean
    attended?: boolean
  }

  export type group_session_participantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"participation_id" | "group_session_id" | "student_id" | "registration_time" | "payment_status" | "attended", ExtArgs["result"]["group_session_participants"]>
  export type group_session_participantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_sessions?: boolean | group_sessionsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $group_session_participantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_session_participants"
    objects: {
      group_sessions: Prisma.$group_sessionsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      participation_id: number
      group_session_id: number
      student_id: number
      registration_time: Date | null
      payment_status: string | null
      attended: boolean | null
    }, ExtArgs["result"]["group_session_participants"]>
    composites: {}
  }

  type group_session_participantsGetPayload<S extends boolean | null | undefined | group_session_participantsDefaultArgs> = $Result.GetResult<Prisma.$group_session_participantsPayload, S>

  type group_session_participantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<group_session_participantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Group_session_participantsCountAggregateInputType | true
    }

  export interface group_session_participantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_session_participants'], meta: { name: 'group_session_participants' } }
    /**
     * Find zero or one Group_session_participants that matches the filter.
     * @param {group_session_participantsFindUniqueArgs} args - Arguments to find a Group_session_participants
     * @example
     * // Get one Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_session_participantsFindUniqueArgs>(args: SelectSubset<T, group_session_participantsFindUniqueArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group_session_participants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {group_session_participantsFindUniqueOrThrowArgs} args - Arguments to find a Group_session_participants
     * @example
     * // Get one Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_session_participantsFindUniqueOrThrowArgs>(args: SelectSubset<T, group_session_participantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_session_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_session_participantsFindFirstArgs} args - Arguments to find a Group_session_participants
     * @example
     * // Get one Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_session_participantsFindFirstArgs>(args?: SelectSubset<T, group_session_participantsFindFirstArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_session_participants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_session_participantsFindFirstOrThrowArgs} args - Arguments to find a Group_session_participants
     * @example
     * // Get one Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_session_participantsFindFirstOrThrowArgs>(args?: SelectSubset<T, group_session_participantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Group_session_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_session_participantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.findMany()
     * 
     * // Get first 10 Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.findMany({ take: 10 })
     * 
     * // Only select the `participation_id`
     * const group_session_participantsWithParticipation_idOnly = await prisma.group_session_participants.findMany({ select: { participation_id: true } })
     * 
     */
    findMany<T extends group_session_participantsFindManyArgs>(args?: SelectSubset<T, group_session_participantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group_session_participants.
     * @param {group_session_participantsCreateArgs} args - Arguments to create a Group_session_participants.
     * @example
     * // Create one Group_session_participants
     * const Group_session_participants = await prisma.group_session_participants.create({
     *   data: {
     *     // ... data to create a Group_session_participants
     *   }
     * })
     * 
     */
    create<T extends group_session_participantsCreateArgs>(args: SelectSubset<T, group_session_participantsCreateArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Group_session_participants.
     * @param {group_session_participantsCreateManyArgs} args - Arguments to create many Group_session_participants.
     * @example
     * // Create many Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_session_participantsCreateManyArgs>(args?: SelectSubset<T, group_session_participantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group_session_participants.
     * @param {group_session_participantsDeleteArgs} args - Arguments to delete one Group_session_participants.
     * @example
     * // Delete one Group_session_participants
     * const Group_session_participants = await prisma.group_session_participants.delete({
     *   where: {
     *     // ... filter to delete one Group_session_participants
     *   }
     * })
     * 
     */
    delete<T extends group_session_participantsDeleteArgs>(args: SelectSubset<T, group_session_participantsDeleteArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group_session_participants.
     * @param {group_session_participantsUpdateArgs} args - Arguments to update one Group_session_participants.
     * @example
     * // Update one Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_session_participantsUpdateArgs>(args: SelectSubset<T, group_session_participantsUpdateArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Group_session_participants.
     * @param {group_session_participantsDeleteManyArgs} args - Arguments to filter Group_session_participants to delete.
     * @example
     * // Delete a few Group_session_participants
     * const { count } = await prisma.group_session_participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_session_participantsDeleteManyArgs>(args?: SelectSubset<T, group_session_participantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_session_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_session_participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_session_participantsUpdateManyArgs>(args: SelectSubset<T, group_session_participantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group_session_participants.
     * @param {group_session_participantsUpsertArgs} args - Arguments to update or create a Group_session_participants.
     * @example
     * // Update or create a Group_session_participants
     * const group_session_participants = await prisma.group_session_participants.upsert({
     *   create: {
     *     // ... data to create a Group_session_participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_session_participants we want to update
     *   }
     * })
     */
    upsert<T extends group_session_participantsUpsertArgs>(args: SelectSubset<T, group_session_participantsUpsertArgs<ExtArgs>>): Prisma__group_session_participantsClient<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Group_session_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_session_participantsCountArgs} args - Arguments to filter Group_session_participants to count.
     * @example
     * // Count the number of Group_session_participants
     * const count = await prisma.group_session_participants.count({
     *   where: {
     *     // ... the filter for the Group_session_participants we want to count
     *   }
     * })
    **/
    count<T extends group_session_participantsCountArgs>(
      args?: Subset<T, group_session_participantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_session_participantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_session_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_session_participantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_session_participantsAggregateArgs>(args: Subset<T, Group_session_participantsAggregateArgs>): Prisma.PrismaPromise<GetGroup_session_participantsAggregateType<T>>

    /**
     * Group by Group_session_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_session_participantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_session_participantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_session_participantsGroupByArgs['orderBy'] }
        : { orderBy?: group_session_participantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_session_participantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_session_participantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_session_participants model
   */
  readonly fields: group_session_participantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_session_participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_session_participantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group_sessions<T extends group_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, group_sessionsDefaultArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_session_participants model
   */
  interface group_session_participantsFieldRefs {
    readonly participation_id: FieldRef<"group_session_participants", 'Int'>
    readonly group_session_id: FieldRef<"group_session_participants", 'Int'>
    readonly student_id: FieldRef<"group_session_participants", 'Int'>
    readonly registration_time: FieldRef<"group_session_participants", 'DateTime'>
    readonly payment_status: FieldRef<"group_session_participants", 'String'>
    readonly attended: FieldRef<"group_session_participants", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * group_session_participants findUnique
   */
  export type group_session_participantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * Filter, which group_session_participants to fetch.
     */
    where: group_session_participantsWhereUniqueInput
  }

  /**
   * group_session_participants findUniqueOrThrow
   */
  export type group_session_participantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * Filter, which group_session_participants to fetch.
     */
    where: group_session_participantsWhereUniqueInput
  }

  /**
   * group_session_participants findFirst
   */
  export type group_session_participantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * Filter, which group_session_participants to fetch.
     */
    where?: group_session_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_session_participants to fetch.
     */
    orderBy?: group_session_participantsOrderByWithRelationInput | group_session_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_session_participants.
     */
    cursor?: group_session_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_session_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_session_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_session_participants.
     */
    distinct?: Group_session_participantsScalarFieldEnum | Group_session_participantsScalarFieldEnum[]
  }

  /**
   * group_session_participants findFirstOrThrow
   */
  export type group_session_participantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * Filter, which group_session_participants to fetch.
     */
    where?: group_session_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_session_participants to fetch.
     */
    orderBy?: group_session_participantsOrderByWithRelationInput | group_session_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_session_participants.
     */
    cursor?: group_session_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_session_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_session_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_session_participants.
     */
    distinct?: Group_session_participantsScalarFieldEnum | Group_session_participantsScalarFieldEnum[]
  }

  /**
   * group_session_participants findMany
   */
  export type group_session_participantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * Filter, which group_session_participants to fetch.
     */
    where?: group_session_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_session_participants to fetch.
     */
    orderBy?: group_session_participantsOrderByWithRelationInput | group_session_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_session_participants.
     */
    cursor?: group_session_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_session_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_session_participants.
     */
    skip?: number
    distinct?: Group_session_participantsScalarFieldEnum | Group_session_participantsScalarFieldEnum[]
  }

  /**
   * group_session_participants create
   */
  export type group_session_participantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * The data needed to create a group_session_participants.
     */
    data: XOR<group_session_participantsCreateInput, group_session_participantsUncheckedCreateInput>
  }

  /**
   * group_session_participants createMany
   */
  export type group_session_participantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_session_participants.
     */
    data: group_session_participantsCreateManyInput | group_session_participantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_session_participants update
   */
  export type group_session_participantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * The data needed to update a group_session_participants.
     */
    data: XOR<group_session_participantsUpdateInput, group_session_participantsUncheckedUpdateInput>
    /**
     * Choose, which group_session_participants to update.
     */
    where: group_session_participantsWhereUniqueInput
  }

  /**
   * group_session_participants updateMany
   */
  export type group_session_participantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_session_participants.
     */
    data: XOR<group_session_participantsUpdateManyMutationInput, group_session_participantsUncheckedUpdateManyInput>
    /**
     * Filter which group_session_participants to update
     */
    where?: group_session_participantsWhereInput
    /**
     * Limit how many group_session_participants to update.
     */
    limit?: number
  }

  /**
   * group_session_participants upsert
   */
  export type group_session_participantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * The filter to search for the group_session_participants to update in case it exists.
     */
    where: group_session_participantsWhereUniqueInput
    /**
     * In case the group_session_participants found by the `where` argument doesn't exist, create a new group_session_participants with this data.
     */
    create: XOR<group_session_participantsCreateInput, group_session_participantsUncheckedCreateInput>
    /**
     * In case the group_session_participants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_session_participantsUpdateInput, group_session_participantsUncheckedUpdateInput>
  }

  /**
   * group_session_participants delete
   */
  export type group_session_participantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    /**
     * Filter which group_session_participants to delete.
     */
    where: group_session_participantsWhereUniqueInput
  }

  /**
   * group_session_participants deleteMany
   */
  export type group_session_participantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_session_participants to delete
     */
    where?: group_session_participantsWhereInput
    /**
     * Limit how many group_session_participants to delete.
     */
    limit?: number
  }

  /**
   * group_session_participants without action
   */
  export type group_session_participantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
  }


  /**
   * Model group_sessions
   */

  export type AggregateGroup_sessions = {
    _count: Group_sessionsCountAggregateOutputType | null
    _avg: Group_sessionsAvgAggregateOutputType | null
    _sum: Group_sessionsSumAggregateOutputType | null
    _min: Group_sessionsMinAggregateOutputType | null
    _max: Group_sessionsMaxAggregateOutputType | null
  }

  export type Group_sessionsAvgAggregateOutputType = {
    group_session_id: number | null
    tutor_id: number | null
    subject_id: number | null
    max_participants: number | null
    current_participants: number | null
    price_per_student: Decimal | null
  }

  export type Group_sessionsSumAggregateOutputType = {
    group_session_id: number | null
    tutor_id: number | null
    subject_id: number | null
    max_participants: number | null
    current_participants: number | null
    price_per_student: Decimal | null
  }

  export type Group_sessionsMinAggregateOutputType = {
    group_session_id: number | null
    tutor_id: number | null
    subject_id: number | null
    title: string | null
    description: string | null
    start_time: Date | null
    end_time: Date | null
    max_participants: number | null
    current_participants: number | null
    price_per_student: Decimal | null
    meeting_url: string | null
    status: string | null
    created_at: Date | null
  }

  export type Group_sessionsMaxAggregateOutputType = {
    group_session_id: number | null
    tutor_id: number | null
    subject_id: number | null
    title: string | null
    description: string | null
    start_time: Date | null
    end_time: Date | null
    max_participants: number | null
    current_participants: number | null
    price_per_student: Decimal | null
    meeting_url: string | null
    status: string | null
    created_at: Date | null
  }

  export type Group_sessionsCountAggregateOutputType = {
    group_session_id: number
    tutor_id: number
    subject_id: number
    title: number
    description: number
    start_time: number
    end_time: number
    max_participants: number
    current_participants: number
    price_per_student: number
    meeting_url: number
    status: number
    created_at: number
    _all: number
  }


  export type Group_sessionsAvgAggregateInputType = {
    group_session_id?: true
    tutor_id?: true
    subject_id?: true
    max_participants?: true
    current_participants?: true
    price_per_student?: true
  }

  export type Group_sessionsSumAggregateInputType = {
    group_session_id?: true
    tutor_id?: true
    subject_id?: true
    max_participants?: true
    current_participants?: true
    price_per_student?: true
  }

  export type Group_sessionsMinAggregateInputType = {
    group_session_id?: true
    tutor_id?: true
    subject_id?: true
    title?: true
    description?: true
    start_time?: true
    end_time?: true
    max_participants?: true
    current_participants?: true
    price_per_student?: true
    meeting_url?: true
    status?: true
    created_at?: true
  }

  export type Group_sessionsMaxAggregateInputType = {
    group_session_id?: true
    tutor_id?: true
    subject_id?: true
    title?: true
    description?: true
    start_time?: true
    end_time?: true
    max_participants?: true
    current_participants?: true
    price_per_student?: true
    meeting_url?: true
    status?: true
    created_at?: true
  }

  export type Group_sessionsCountAggregateInputType = {
    group_session_id?: true
    tutor_id?: true
    subject_id?: true
    title?: true
    description?: true
    start_time?: true
    end_time?: true
    max_participants?: true
    current_participants?: true
    price_per_student?: true
    meeting_url?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Group_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_sessions to aggregate.
     */
    where?: group_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_sessions to fetch.
     */
    orderBy?: group_sessionsOrderByWithRelationInput | group_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_sessions
    **/
    _count?: true | Group_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_sessionsMaxAggregateInputType
  }

  export type GetGroup_sessionsAggregateType<T extends Group_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_sessions[P]>
      : GetScalarType<T[P], AggregateGroup_sessions[P]>
  }




  export type group_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_sessionsWhereInput
    orderBy?: group_sessionsOrderByWithAggregationInput | group_sessionsOrderByWithAggregationInput[]
    by: Group_sessionsScalarFieldEnum[] | Group_sessionsScalarFieldEnum
    having?: group_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_sessionsCountAggregateInputType | true
    _avg?: Group_sessionsAvgAggregateInputType
    _sum?: Group_sessionsSumAggregateInputType
    _min?: Group_sessionsMinAggregateInputType
    _max?: Group_sessionsMaxAggregateInputType
  }

  export type Group_sessionsGroupByOutputType = {
    group_session_id: number
    tutor_id: number
    subject_id: number
    title: string
    description: string | null
    start_time: Date
    end_time: Date
    max_participants: number
    current_participants: number | null
    price_per_student: Decimal
    meeting_url: string | null
    status: string
    created_at: Date | null
    _count: Group_sessionsCountAggregateOutputType | null
    _avg: Group_sessionsAvgAggregateOutputType | null
    _sum: Group_sessionsSumAggregateOutputType | null
    _min: Group_sessionsMinAggregateOutputType | null
    _max: Group_sessionsMaxAggregateOutputType | null
  }

  type GetGroup_sessionsGroupByPayload<T extends group_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Group_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type group_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_session_id?: boolean
    tutor_id?: boolean
    subject_id?: boolean
    title?: boolean
    description?: boolean
    start_time?: boolean
    end_time?: boolean
    max_participants?: boolean
    current_participants?: boolean
    price_per_student?: boolean
    meeting_url?: boolean
    status?: boolean
    created_at?: boolean
    group_session_participants?: boolean | group_sessions$group_session_participantsArgs<ExtArgs>
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | Group_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group_sessions"]>



  export type group_sessionsSelectScalar = {
    group_session_id?: boolean
    tutor_id?: boolean
    subject_id?: boolean
    title?: boolean
    description?: boolean
    start_time?: boolean
    end_time?: boolean
    max_participants?: boolean
    current_participants?: boolean
    price_per_student?: boolean
    meeting_url?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type group_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"group_session_id" | "tutor_id" | "subject_id" | "title" | "description" | "start_time" | "end_time" | "max_participants" | "current_participants" | "price_per_student" | "meeting_url" | "status" | "created_at", ExtArgs["result"]["group_sessions"]>
  export type group_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_session_participants?: boolean | group_sessions$group_session_participantsArgs<ExtArgs>
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | Group_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $group_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_sessions"
    objects: {
      group_session_participants: Prisma.$group_session_participantsPayload<ExtArgs>[]
      tutors: Prisma.$tutorsPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      group_session_id: number
      tutor_id: number
      subject_id: number
      title: string
      description: string | null
      start_time: Date
      end_time: Date
      max_participants: number
      current_participants: number | null
      price_per_student: Prisma.Decimal
      meeting_url: string | null
      status: string
      created_at: Date | null
    }, ExtArgs["result"]["group_sessions"]>
    composites: {}
  }

  type group_sessionsGetPayload<S extends boolean | null | undefined | group_sessionsDefaultArgs> = $Result.GetResult<Prisma.$group_sessionsPayload, S>

  type group_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<group_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Group_sessionsCountAggregateInputType | true
    }

  export interface group_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_sessions'], meta: { name: 'group_sessions' } }
    /**
     * Find zero or one Group_sessions that matches the filter.
     * @param {group_sessionsFindUniqueArgs} args - Arguments to find a Group_sessions
     * @example
     * // Get one Group_sessions
     * const group_sessions = await prisma.group_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_sessionsFindUniqueArgs>(args: SelectSubset<T, group_sessionsFindUniqueArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {group_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Group_sessions
     * @example
     * // Get one Group_sessions
     * const group_sessions = await prisma.group_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, group_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_sessionsFindFirstArgs} args - Arguments to find a Group_sessions
     * @example
     * // Get one Group_sessions
     * const group_sessions = await prisma.group_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_sessionsFindFirstArgs>(args?: SelectSubset<T, group_sessionsFindFirstArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_sessionsFindFirstOrThrowArgs} args - Arguments to find a Group_sessions
     * @example
     * // Get one Group_sessions
     * const group_sessions = await prisma.group_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, group_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Group_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_sessions
     * const group_sessions = await prisma.group_sessions.findMany()
     * 
     * // Get first 10 Group_sessions
     * const group_sessions = await prisma.group_sessions.findMany({ take: 10 })
     * 
     * // Only select the `group_session_id`
     * const group_sessionsWithGroup_session_idOnly = await prisma.group_sessions.findMany({ select: { group_session_id: true } })
     * 
     */
    findMany<T extends group_sessionsFindManyArgs>(args?: SelectSubset<T, group_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group_sessions.
     * @param {group_sessionsCreateArgs} args - Arguments to create a Group_sessions.
     * @example
     * // Create one Group_sessions
     * const Group_sessions = await prisma.group_sessions.create({
     *   data: {
     *     // ... data to create a Group_sessions
     *   }
     * })
     * 
     */
    create<T extends group_sessionsCreateArgs>(args: SelectSubset<T, group_sessionsCreateArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Group_sessions.
     * @param {group_sessionsCreateManyArgs} args - Arguments to create many Group_sessions.
     * @example
     * // Create many Group_sessions
     * const group_sessions = await prisma.group_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_sessionsCreateManyArgs>(args?: SelectSubset<T, group_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group_sessions.
     * @param {group_sessionsDeleteArgs} args - Arguments to delete one Group_sessions.
     * @example
     * // Delete one Group_sessions
     * const Group_sessions = await prisma.group_sessions.delete({
     *   where: {
     *     // ... filter to delete one Group_sessions
     *   }
     * })
     * 
     */
    delete<T extends group_sessionsDeleteArgs>(args: SelectSubset<T, group_sessionsDeleteArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group_sessions.
     * @param {group_sessionsUpdateArgs} args - Arguments to update one Group_sessions.
     * @example
     * // Update one Group_sessions
     * const group_sessions = await prisma.group_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_sessionsUpdateArgs>(args: SelectSubset<T, group_sessionsUpdateArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Group_sessions.
     * @param {group_sessionsDeleteManyArgs} args - Arguments to filter Group_sessions to delete.
     * @example
     * // Delete a few Group_sessions
     * const { count } = await prisma.group_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_sessionsDeleteManyArgs>(args?: SelectSubset<T, group_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_sessions
     * const group_sessions = await prisma.group_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_sessionsUpdateManyArgs>(args: SelectSubset<T, group_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group_sessions.
     * @param {group_sessionsUpsertArgs} args - Arguments to update or create a Group_sessions.
     * @example
     * // Update or create a Group_sessions
     * const group_sessions = await prisma.group_sessions.upsert({
     *   create: {
     *     // ... data to create a Group_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_sessions we want to update
     *   }
     * })
     */
    upsert<T extends group_sessionsUpsertArgs>(args: SelectSubset<T, group_sessionsUpsertArgs<ExtArgs>>): Prisma__group_sessionsClient<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Group_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_sessionsCountArgs} args - Arguments to filter Group_sessions to count.
     * @example
     * // Count the number of Group_sessions
     * const count = await prisma.group_sessions.count({
     *   where: {
     *     // ... the filter for the Group_sessions we want to count
     *   }
     * })
    **/
    count<T extends group_sessionsCountArgs>(
      args?: Subset<T, group_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_sessionsAggregateArgs>(args: Subset<T, Group_sessionsAggregateArgs>): Prisma.PrismaPromise<GetGroup_sessionsAggregateType<T>>

    /**
     * Group by Group_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: group_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_sessions model
   */
  readonly fields: group_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group_session_participants<T extends group_sessions$group_session_participantsArgs<ExtArgs> = {}>(args?: Subset<T, group_sessions$group_session_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutors<T extends tutorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tutorsDefaultArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_sessions model
   */
  interface group_sessionsFieldRefs {
    readonly group_session_id: FieldRef<"group_sessions", 'Int'>
    readonly tutor_id: FieldRef<"group_sessions", 'Int'>
    readonly subject_id: FieldRef<"group_sessions", 'Int'>
    readonly title: FieldRef<"group_sessions", 'String'>
    readonly description: FieldRef<"group_sessions", 'String'>
    readonly start_time: FieldRef<"group_sessions", 'DateTime'>
    readonly end_time: FieldRef<"group_sessions", 'DateTime'>
    readonly max_participants: FieldRef<"group_sessions", 'Int'>
    readonly current_participants: FieldRef<"group_sessions", 'Int'>
    readonly price_per_student: FieldRef<"group_sessions", 'Decimal'>
    readonly meeting_url: FieldRef<"group_sessions", 'String'>
    readonly status: FieldRef<"group_sessions", 'String'>
    readonly created_at: FieldRef<"group_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * group_sessions findUnique
   */
  export type group_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which group_sessions to fetch.
     */
    where: group_sessionsWhereUniqueInput
  }

  /**
   * group_sessions findUniqueOrThrow
   */
  export type group_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which group_sessions to fetch.
     */
    where: group_sessionsWhereUniqueInput
  }

  /**
   * group_sessions findFirst
   */
  export type group_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which group_sessions to fetch.
     */
    where?: group_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_sessions to fetch.
     */
    orderBy?: group_sessionsOrderByWithRelationInput | group_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_sessions.
     */
    cursor?: group_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_sessions.
     */
    distinct?: Group_sessionsScalarFieldEnum | Group_sessionsScalarFieldEnum[]
  }

  /**
   * group_sessions findFirstOrThrow
   */
  export type group_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which group_sessions to fetch.
     */
    where?: group_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_sessions to fetch.
     */
    orderBy?: group_sessionsOrderByWithRelationInput | group_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_sessions.
     */
    cursor?: group_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_sessions.
     */
    distinct?: Group_sessionsScalarFieldEnum | Group_sessionsScalarFieldEnum[]
  }

  /**
   * group_sessions findMany
   */
  export type group_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which group_sessions to fetch.
     */
    where?: group_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_sessions to fetch.
     */
    orderBy?: group_sessionsOrderByWithRelationInput | group_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_sessions.
     */
    cursor?: group_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_sessions.
     */
    skip?: number
    distinct?: Group_sessionsScalarFieldEnum | Group_sessionsScalarFieldEnum[]
  }

  /**
   * group_sessions create
   */
  export type group_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a group_sessions.
     */
    data: XOR<group_sessionsCreateInput, group_sessionsUncheckedCreateInput>
  }

  /**
   * group_sessions createMany
   */
  export type group_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_sessions.
     */
    data: group_sessionsCreateManyInput | group_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_sessions update
   */
  export type group_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a group_sessions.
     */
    data: XOR<group_sessionsUpdateInput, group_sessionsUncheckedUpdateInput>
    /**
     * Choose, which group_sessions to update.
     */
    where: group_sessionsWhereUniqueInput
  }

  /**
   * group_sessions updateMany
   */
  export type group_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_sessions.
     */
    data: XOR<group_sessionsUpdateManyMutationInput, group_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which group_sessions to update
     */
    where?: group_sessionsWhereInput
    /**
     * Limit how many group_sessions to update.
     */
    limit?: number
  }

  /**
   * group_sessions upsert
   */
  export type group_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the group_sessions to update in case it exists.
     */
    where: group_sessionsWhereUniqueInput
    /**
     * In case the group_sessions found by the `where` argument doesn't exist, create a new group_sessions with this data.
     */
    create: XOR<group_sessionsCreateInput, group_sessionsUncheckedCreateInput>
    /**
     * In case the group_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_sessionsUpdateInput, group_sessionsUncheckedUpdateInput>
  }

  /**
   * group_sessions delete
   */
  export type group_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    /**
     * Filter which group_sessions to delete.
     */
    where: group_sessionsWhereUniqueInput
  }

  /**
   * group_sessions deleteMany
   */
  export type group_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_sessions to delete
     */
    where?: group_sessionsWhereInput
    /**
     * Limit how many group_sessions to delete.
     */
    limit?: number
  }

  /**
   * group_sessions.group_session_participants
   */
  export type group_sessions$group_session_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    where?: group_session_participantsWhereInput
    orderBy?: group_session_participantsOrderByWithRelationInput | group_session_participantsOrderByWithRelationInput[]
    cursor?: group_session_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Group_session_participantsScalarFieldEnum | Group_session_participantsScalarFieldEnum[]
  }

  /**
   * group_sessions without action
   */
  export type group_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesAvgAggregateOutputType = {
    message_id: number | null
    sender_id: number | null
    recipient_id: number | null
  }

  export type MessagesSumAggregateOutputType = {
    message_id: number | null
    sender_id: number | null
    recipient_id: number | null
  }

  export type MessagesMinAggregateOutputType = {
    message_id: number | null
    sender_id: number | null
    recipient_id: number | null
    content: string | null
    sent_at: Date | null
    read_at: Date | null
    attachment_url: string | null
  }

  export type MessagesMaxAggregateOutputType = {
    message_id: number | null
    sender_id: number | null
    recipient_id: number | null
    content: string | null
    sent_at: Date | null
    read_at: Date | null
    attachment_url: string | null
  }

  export type MessagesCountAggregateOutputType = {
    message_id: number
    sender_id: number
    recipient_id: number
    content: number
    sent_at: number
    read_at: number
    attachment_url: number
    _all: number
  }


  export type MessagesAvgAggregateInputType = {
    message_id?: true
    sender_id?: true
    recipient_id?: true
  }

  export type MessagesSumAggregateInputType = {
    message_id?: true
    sender_id?: true
    recipient_id?: true
  }

  export type MessagesMinAggregateInputType = {
    message_id?: true
    sender_id?: true
    recipient_id?: true
    content?: true
    sent_at?: true
    read_at?: true
    attachment_url?: true
  }

  export type MessagesMaxAggregateInputType = {
    message_id?: true
    sender_id?: true
    recipient_id?: true
    content?: true
    sent_at?: true
    read_at?: true
    attachment_url?: true
  }

  export type MessagesCountAggregateInputType = {
    message_id?: true
    sender_id?: true
    recipient_id?: true
    content?: true
    sent_at?: true
    read_at?: true
    attachment_url?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _avg?: MessagesAvgAggregateInputType
    _sum?: MessagesSumAggregateInputType
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    message_id: number
    sender_id: number
    recipient_id: number
    content: string
    sent_at: Date | null
    read_at: Date | null
    attachment_url: string | null
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_id?: boolean
    sender_id?: boolean
    recipient_id?: boolean
    content?: boolean
    sent_at?: boolean
    read_at?: boolean
    attachment_url?: boolean
    users_messages_sender_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_recipient_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>



  export type messagesSelectScalar = {
    message_id?: boolean
    sender_id?: boolean
    recipient_id?: boolean
    content?: boolean
    sent_at?: boolean
    read_at?: boolean
    attachment_url?: boolean
  }

  export type messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"message_id" | "sender_id" | "recipient_id" | "content" | "sent_at" | "read_at" | "attachment_url", ExtArgs["result"]["messages"]>
  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_messages_sender_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_recipient_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      users_messages_sender_idTousers: Prisma.$usersPayload<ExtArgs>
      users_messages_recipient_idTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      message_id: number
      sender_id: number
      recipient_id: number
      content: string
      sent_at: Date | null
      read_at: Date | null
      attachment_url: string | null
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `message_id`
     * const messagesWithMessage_idOnly = await prisma.messages.findMany({ select: { message_id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_messages_sender_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_messages_recipient_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */
  interface messagesFieldRefs {
    readonly message_id: FieldRef<"messages", 'Int'>
    readonly sender_id: FieldRef<"messages", 'Int'>
    readonly recipient_id: FieldRef<"messages", 'Int'>
    readonly content: FieldRef<"messages", 'String'>
    readonly sent_at: FieldRef<"messages", 'DateTime'>
    readonly read_at: FieldRef<"messages", 'DateTime'>
    readonly attachment_url: FieldRef<"messages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    notification_id: number | null
    user_id: number | null
    related_id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    notification_id: number | null
    user_id: number | null
    related_id: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    notification_id: number | null
    user_id: number | null
    title: string | null
    content: string | null
    notification_type: string | null
    related_id: number | null
    created_at: Date | null
    read_at: Date | null
    is_read: boolean | null
  }

  export type NotificationsMaxAggregateOutputType = {
    notification_id: number | null
    user_id: number | null
    title: string | null
    content: string | null
    notification_type: string | null
    related_id: number | null
    created_at: Date | null
    read_at: Date | null
    is_read: boolean | null
  }

  export type NotificationsCountAggregateOutputType = {
    notification_id: number
    user_id: number
    title: number
    content: number
    notification_type: number
    related_id: number
    created_at: number
    read_at: number
    is_read: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    notification_id?: true
    user_id?: true
    related_id?: true
  }

  export type NotificationsSumAggregateInputType = {
    notification_id?: true
    user_id?: true
    related_id?: true
  }

  export type NotificationsMinAggregateInputType = {
    notification_id?: true
    user_id?: true
    title?: true
    content?: true
    notification_type?: true
    related_id?: true
    created_at?: true
    read_at?: true
    is_read?: true
  }

  export type NotificationsMaxAggregateInputType = {
    notification_id?: true
    user_id?: true
    title?: true
    content?: true
    notification_type?: true
    related_id?: true
    created_at?: true
    read_at?: true
    is_read?: true
  }

  export type NotificationsCountAggregateInputType = {
    notification_id?: true
    user_id?: true
    title?: true
    content?: true
    notification_type?: true
    related_id?: true
    created_at?: true
    read_at?: true
    is_read?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    notification_id: number
    user_id: number
    title: string
    content: string
    notification_type: string
    related_id: number | null
    created_at: Date | null
    read_at: Date | null
    is_read: boolean | null
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    notification_id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    notification_type?: boolean
    related_id?: boolean
    created_at?: boolean
    read_at?: boolean
    is_read?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>



  export type notificationsSelectScalar = {
    notification_id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    notification_type?: boolean
    related_id?: boolean
    created_at?: boolean
    read_at?: boolean
    is_read?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"notification_id" | "user_id" | "title" | "content" | "notification_type" | "related_id" | "created_at" | "read_at" | "is_read", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      notification_id: number
      user_id: number
      title: string
      content: string
      notification_type: string
      related_id: number | null
      created_at: Date | null
      read_at: Date | null
      is_read: boolean | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `notification_id`
     * const notificationsWithNotification_idOnly = await prisma.notifications.findMany({ select: { notification_id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly notification_id: FieldRef<"notifications", 'Int'>
    readonly user_id: FieldRef<"notifications", 'Int'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly content: FieldRef<"notifications", 'String'>
    readonly notification_type: FieldRef<"notifications", 'String'>
    readonly related_id: FieldRef<"notifications", 'Int'>
    readonly created_at: FieldRef<"notifications", 'DateTime'>
    readonly read_at: FieldRef<"notifications", 'DateTime'>
    readonly is_read: FieldRef<"notifications", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    payment_id: number | null
    session_id: number | null
    amount: Decimal | null
    platform_fee: Decimal | null
    tutor_payout: Decimal | null
    refund_amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    payment_id: number | null
    session_id: number | null
    amount: Decimal | null
    platform_fee: Decimal | null
    tutor_payout: Decimal | null
    refund_amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    payment_id: number | null
    session_id: number | null
    amount: Decimal | null
    payment_date: Date | null
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    platform_fee: Decimal | null
    tutor_payout: Decimal | null
    payout_date: Date | null
    refund_amount: Decimal | null
    refund_date: Date | null
    refund_reason: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    payment_id: number | null
    session_id: number | null
    amount: Decimal | null
    payment_date: Date | null
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    platform_fee: Decimal | null
    tutor_payout: Decimal | null
    payout_date: Date | null
    refund_amount: Decimal | null
    refund_date: Date | null
    refund_reason: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    payment_id: number
    session_id: number
    amount: number
    payment_date: number
    payment_method: number
    transaction_id: number
    status: number
    platform_fee: number
    tutor_payout: number
    payout_date: number
    refund_amount: number
    refund_date: number
    refund_reason: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    payment_id?: true
    session_id?: true
    amount?: true
    platform_fee?: true
    tutor_payout?: true
    refund_amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    payment_id?: true
    session_id?: true
    amount?: true
    platform_fee?: true
    tutor_payout?: true
    refund_amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    payment_id?: true
    session_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    platform_fee?: true
    tutor_payout?: true
    payout_date?: true
    refund_amount?: true
    refund_date?: true
    refund_reason?: true
  }

  export type PaymentsMaxAggregateInputType = {
    payment_id?: true
    session_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    platform_fee?: true
    tutor_payout?: true
    payout_date?: true
    refund_amount?: true
    refund_date?: true
    refund_reason?: true
  }

  export type PaymentsCountAggregateInputType = {
    payment_id?: true
    session_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    platform_fee?: true
    tutor_payout?: true
    payout_date?: true
    refund_amount?: true
    refund_date?: true
    refund_reason?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    payment_id: number
    session_id: number
    amount: Decimal
    payment_date: Date | null
    payment_method: string
    transaction_id: string | null
    status: string
    platform_fee: Decimal
    tutor_payout: Decimal
    payout_date: Date | null
    refund_amount: Decimal | null
    refund_date: Date | null
    refund_reason: string | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    session_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    platform_fee?: boolean
    tutor_payout?: boolean
    payout_date?: boolean
    refund_amount?: boolean
    refund_date?: boolean
    refund_reason?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>



  export type paymentsSelectScalar = {
    payment_id?: boolean
    session_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    platform_fee?: boolean
    tutor_payout?: boolean
    payout_date?: boolean
    refund_amount?: boolean
    refund_date?: boolean
    refund_reason?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_id" | "session_id" | "amount" | "payment_date" | "payment_method" | "transaction_id" | "status" | "platform_fee" | "tutor_payout" | "payout_date" | "refund_amount" | "refund_date" | "refund_reason", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      sessions: Prisma.$sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_id: number
      session_id: number
      amount: Prisma.Decimal
      payment_date: Date | null
      payment_method: string
      transaction_id: string | null
      status: string
      platform_fee: Prisma.Decimal
      tutor_payout: Prisma.Decimal
      payout_date: Date | null
      refund_amount: Prisma.Decimal | null
      refund_date: Date | null
      refund_reason: string | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const paymentsWithPayment_idOnly = await prisma.payments.findMany({ select: { payment_id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessionsDefaultArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly payment_id: FieldRef<"payments", 'Int'>
    readonly session_id: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly payment_date: FieldRef<"payments", 'DateTime'>
    readonly payment_method: FieldRef<"payments", 'String'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly status: FieldRef<"payments", 'String'>
    readonly platform_fee: FieldRef<"payments", 'Decimal'>
    readonly tutor_payout: FieldRef<"payments", 'Decimal'>
    readonly payout_date: FieldRef<"payments", 'DateTime'>
    readonly refund_amount: FieldRef<"payments", 'Decimal'>
    readonly refund_date: FieldRef<"payments", 'DateTime'>
    readonly refund_reason: FieldRef<"payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model resources
   */

  export type AggregateResources = {
    _count: ResourcesCountAggregateOutputType | null
    _avg: ResourcesAvgAggregateOutputType | null
    _sum: ResourcesSumAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  export type ResourcesAvgAggregateOutputType = {
    resource_id: number | null
    subject_id: number | null
    uploaded_by: number | null
  }

  export type ResourcesSumAggregateOutputType = {
    resource_id: number | null
    subject_id: number | null
    uploaded_by: number | null
  }

  export type ResourcesMinAggregateOutputType = {
    resource_id: number | null
    title: string | null
    description: string | null
    url: string | null
    file_path: string | null
    subject_id: number | null
    uploaded_by: number | null
    resource_type: string | null
    is_public: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ResourcesMaxAggregateOutputType = {
    resource_id: number | null
    title: string | null
    description: string | null
    url: string | null
    file_path: string | null
    subject_id: number | null
    uploaded_by: number | null
    resource_type: string | null
    is_public: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ResourcesCountAggregateOutputType = {
    resource_id: number
    title: number
    description: number
    url: number
    file_path: number
    subject_id: number
    uploaded_by: number
    resource_type: number
    is_public: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ResourcesAvgAggregateInputType = {
    resource_id?: true
    subject_id?: true
    uploaded_by?: true
  }

  export type ResourcesSumAggregateInputType = {
    resource_id?: true
    subject_id?: true
    uploaded_by?: true
  }

  export type ResourcesMinAggregateInputType = {
    resource_id?: true
    title?: true
    description?: true
    url?: true
    file_path?: true
    subject_id?: true
    uploaded_by?: true
    resource_type?: true
    is_public?: true
    created_at?: true
    updated_at?: true
  }

  export type ResourcesMaxAggregateInputType = {
    resource_id?: true
    title?: true
    description?: true
    url?: true
    file_path?: true
    subject_id?: true
    uploaded_by?: true
    resource_type?: true
    is_public?: true
    created_at?: true
    updated_at?: true
  }

  export type ResourcesCountAggregateInputType = {
    resource_id?: true
    title?: true
    description?: true
    url?: true
    file_path?: true
    subject_id?: true
    uploaded_by?: true
    resource_type?: true
    is_public?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ResourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resources to aggregate.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned resources
    **/
    _count?: true | ResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourcesMaxAggregateInputType
  }

  export type GetResourcesAggregateType<T extends ResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResources[P]>
      : GetScalarType<T[P], AggregateResources[P]>
  }




  export type resourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: resourcesWhereInput
    orderBy?: resourcesOrderByWithAggregationInput | resourcesOrderByWithAggregationInput[]
    by: ResourcesScalarFieldEnum[] | ResourcesScalarFieldEnum
    having?: resourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourcesCountAggregateInputType | true
    _avg?: ResourcesAvgAggregateInputType
    _sum?: ResourcesSumAggregateInputType
    _min?: ResourcesMinAggregateInputType
    _max?: ResourcesMaxAggregateInputType
  }

  export type ResourcesGroupByOutputType = {
    resource_id: number
    title: string
    description: string | null
    url: string | null
    file_path: string | null
    subject_id: number | null
    uploaded_by: number
    resource_type: string
    is_public: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: ResourcesCountAggregateOutputType | null
    _avg: ResourcesAvgAggregateOutputType | null
    _sum: ResourcesSumAggregateOutputType | null
    _min: ResourcesMinAggregateOutputType | null
    _max: ResourcesMaxAggregateOutputType | null
  }

  type GetResourcesGroupByPayload<T extends resourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], ResourcesGroupByOutputType[P]>
        }
      >
    >


  export type resourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resource_id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    file_path?: boolean
    subject_id?: boolean
    uploaded_by?: boolean
    resource_type?: boolean
    is_public?: boolean
    created_at?: boolean
    updated_at?: boolean
    subjects?: boolean | resources$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    session_resources?: boolean | resources$session_resourcesArgs<ExtArgs>
    _count?: boolean | ResourcesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resources"]>



  export type resourcesSelectScalar = {
    resource_id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    file_path?: boolean
    subject_id?: boolean
    uploaded_by?: boolean
    resource_type?: boolean
    is_public?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type resourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"resource_id" | "title" | "description" | "url" | "file_path" | "subject_id" | "uploaded_by" | "resource_type" | "is_public" | "created_at" | "updated_at", ExtArgs["result"]["resources"]>
  export type resourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | resources$subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    session_resources?: boolean | resources$session_resourcesArgs<ExtArgs>
    _count?: boolean | ResourcesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $resourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "resources"
    objects: {
      subjects: Prisma.$subjectsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      session_resources: Prisma.$session_resourcesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      resource_id: number
      title: string
      description: string | null
      url: string | null
      file_path: string | null
      subject_id: number | null
      uploaded_by: number
      resource_type: string
      is_public: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["resources"]>
    composites: {}
  }

  type resourcesGetPayload<S extends boolean | null | undefined | resourcesDefaultArgs> = $Result.GetResult<Prisma.$resourcesPayload, S>

  type resourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<resourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourcesCountAggregateInputType | true
    }

  export interface resourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['resources'], meta: { name: 'resources' } }
    /**
     * Find zero or one Resources that matches the filter.
     * @param {resourcesFindUniqueArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resourcesFindUniqueArgs>(args: SelectSubset<T, resourcesFindUniqueArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resourcesFindUniqueOrThrowArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, resourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesFindFirstArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resourcesFindFirstArgs>(args?: SelectSubset<T, resourcesFindFirstArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesFindFirstOrThrowArgs} args - Arguments to find a Resources
     * @example
     * // Get one Resources
     * const resources = await prisma.resources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, resourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resources.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resources.findMany({ take: 10 })
     * 
     * // Only select the `resource_id`
     * const resourcesWithResource_idOnly = await prisma.resources.findMany({ select: { resource_id: true } })
     * 
     */
    findMany<T extends resourcesFindManyArgs>(args?: SelectSubset<T, resourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resources.
     * @param {resourcesCreateArgs} args - Arguments to create a Resources.
     * @example
     * // Create one Resources
     * const Resources = await prisma.resources.create({
     *   data: {
     *     // ... data to create a Resources
     *   }
     * })
     * 
     */
    create<T extends resourcesCreateArgs>(args: SelectSubset<T, resourcesCreateArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {resourcesCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resources = await prisma.resources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends resourcesCreateManyArgs>(args?: SelectSubset<T, resourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resources.
     * @param {resourcesDeleteArgs} args - Arguments to delete one Resources.
     * @example
     * // Delete one Resources
     * const Resources = await prisma.resources.delete({
     *   where: {
     *     // ... filter to delete one Resources
     *   }
     * })
     * 
     */
    delete<T extends resourcesDeleteArgs>(args: SelectSubset<T, resourcesDeleteArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resources.
     * @param {resourcesUpdateArgs} args - Arguments to update one Resources.
     * @example
     * // Update one Resources
     * const resources = await prisma.resources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends resourcesUpdateArgs>(args: SelectSubset<T, resourcesUpdateArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {resourcesDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends resourcesDeleteManyArgs>(args?: SelectSubset<T, resourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resources = await prisma.resources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends resourcesUpdateManyArgs>(args: SelectSubset<T, resourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resources.
     * @param {resourcesUpsertArgs} args - Arguments to update or create a Resources.
     * @example
     * // Update or create a Resources
     * const resources = await prisma.resources.upsert({
     *   create: {
     *     // ... data to create a Resources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resources we want to update
     *   }
     * })
     */
    upsert<T extends resourcesUpsertArgs>(args: SelectSubset<T, resourcesUpsertArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resources.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends resourcesCountArgs>(
      args?: Subset<T, resourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourcesAggregateArgs>(args: Subset<T, ResourcesAggregateArgs>): Prisma.PrismaPromise<GetResourcesAggregateType<T>>

    /**
     * Group by Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends resourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resourcesGroupByArgs['orderBy'] }
        : { orderBy?: resourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, resourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the resources model
   */
  readonly fields: resourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for resources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subjects<T extends resources$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, resources$subjectsArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session_resources<T extends resources$session_resourcesArgs<ExtArgs> = {}>(args?: Subset<T, resources$session_resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the resources model
   */
  interface resourcesFieldRefs {
    readonly resource_id: FieldRef<"resources", 'Int'>
    readonly title: FieldRef<"resources", 'String'>
    readonly description: FieldRef<"resources", 'String'>
    readonly url: FieldRef<"resources", 'String'>
    readonly file_path: FieldRef<"resources", 'String'>
    readonly subject_id: FieldRef<"resources", 'Int'>
    readonly uploaded_by: FieldRef<"resources", 'Int'>
    readonly resource_type: FieldRef<"resources", 'String'>
    readonly is_public: FieldRef<"resources", 'Boolean'>
    readonly created_at: FieldRef<"resources", 'DateTime'>
    readonly updated_at: FieldRef<"resources", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * resources findUnique
   */
  export type resourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources findUniqueOrThrow
   */
  export type resourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources findFirst
   */
  export type resourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * resources findFirstOrThrow
   */
  export type resourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for resources.
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of resources.
     */
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * resources findMany
   */
  export type resourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter, which resources to fetch.
     */
    where?: resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of resources to fetch.
     */
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing resources.
     */
    cursor?: resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` resources.
     */
    skip?: number
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * resources create
   */
  export type resourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a resources.
     */
    data: XOR<resourcesCreateInput, resourcesUncheckedCreateInput>
  }

  /**
   * resources createMany
   */
  export type resourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many resources.
     */
    data: resourcesCreateManyInput | resourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * resources update
   */
  export type resourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a resources.
     */
    data: XOR<resourcesUpdateInput, resourcesUncheckedUpdateInput>
    /**
     * Choose, which resources to update.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources updateMany
   */
  export type resourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update resources.
     */
    data: XOR<resourcesUpdateManyMutationInput, resourcesUncheckedUpdateManyInput>
    /**
     * Filter which resources to update
     */
    where?: resourcesWhereInput
    /**
     * Limit how many resources to update.
     */
    limit?: number
  }

  /**
   * resources upsert
   */
  export type resourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the resources to update in case it exists.
     */
    where: resourcesWhereUniqueInput
    /**
     * In case the resources found by the `where` argument doesn't exist, create a new resources with this data.
     */
    create: XOR<resourcesCreateInput, resourcesUncheckedCreateInput>
    /**
     * In case the resources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resourcesUpdateInput, resourcesUncheckedUpdateInput>
  }

  /**
   * resources delete
   */
  export type resourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    /**
     * Filter which resources to delete.
     */
    where: resourcesWhereUniqueInput
  }

  /**
   * resources deleteMany
   */
  export type resourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which resources to delete
     */
    where?: resourcesWhereInput
    /**
     * Limit how many resources to delete.
     */
    limit?: number
  }

  /**
   * resources.subjects
   */
  export type resources$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    where?: subjectsWhereInput
  }

  /**
   * resources.session_resources
   */
  export type resources$session_resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    where?: session_resourcesWhereInput
    orderBy?: session_resourcesOrderByWithRelationInput | session_resourcesOrderByWithRelationInput[]
    cursor?: session_resourcesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_resourcesScalarFieldEnum | Session_resourcesScalarFieldEnum[]
  }

  /**
   * resources without action
   */
  export type resourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
  }


  /**
   * Model session_notes
   */

  export type AggregateSession_notes = {
    _count: Session_notesCountAggregateOutputType | null
    _avg: Session_notesAvgAggregateOutputType | null
    _sum: Session_notesSumAggregateOutputType | null
    _min: Session_notesMinAggregateOutputType | null
    _max: Session_notesMaxAggregateOutputType | null
  }

  export type Session_notesAvgAggregateOutputType = {
    note_id: number | null
    session_id: number | null
    author_id: number | null
  }

  export type Session_notesSumAggregateOutputType = {
    note_id: number | null
    session_id: number | null
    author_id: number | null
  }

  export type Session_notesMinAggregateOutputType = {
    note_id: number | null
    session_id: number | null
    author_id: number | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    is_private: boolean | null
  }

  export type Session_notesMaxAggregateOutputType = {
    note_id: number | null
    session_id: number | null
    author_id: number | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    is_private: boolean | null
  }

  export type Session_notesCountAggregateOutputType = {
    note_id: number
    session_id: number
    author_id: number
    content: number
    created_at: number
    updated_at: number
    is_private: number
    _all: number
  }


  export type Session_notesAvgAggregateInputType = {
    note_id?: true
    session_id?: true
    author_id?: true
  }

  export type Session_notesSumAggregateInputType = {
    note_id?: true
    session_id?: true
    author_id?: true
  }

  export type Session_notesMinAggregateInputType = {
    note_id?: true
    session_id?: true
    author_id?: true
    content?: true
    created_at?: true
    updated_at?: true
    is_private?: true
  }

  export type Session_notesMaxAggregateInputType = {
    note_id?: true
    session_id?: true
    author_id?: true
    content?: true
    created_at?: true
    updated_at?: true
    is_private?: true
  }

  export type Session_notesCountAggregateInputType = {
    note_id?: true
    session_id?: true
    author_id?: true
    content?: true
    created_at?: true
    updated_at?: true
    is_private?: true
    _all?: true
  }

  export type Session_notesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_notes to aggregate.
     */
    where?: session_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_notes to fetch.
     */
    orderBy?: session_notesOrderByWithRelationInput | session_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_notes
    **/
    _count?: true | Session_notesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_notesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_notesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_notesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_notesMaxAggregateInputType
  }

  export type GetSession_notesAggregateType<T extends Session_notesAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_notes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_notes[P]>
      : GetScalarType<T[P], AggregateSession_notes[P]>
  }




  export type session_notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_notesWhereInput
    orderBy?: session_notesOrderByWithAggregationInput | session_notesOrderByWithAggregationInput[]
    by: Session_notesScalarFieldEnum[] | Session_notesScalarFieldEnum
    having?: session_notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_notesCountAggregateInputType | true
    _avg?: Session_notesAvgAggregateInputType
    _sum?: Session_notesSumAggregateInputType
    _min?: Session_notesMinAggregateInputType
    _max?: Session_notesMaxAggregateInputType
  }

  export type Session_notesGroupByOutputType = {
    note_id: number
    session_id: number
    author_id: number
    content: string
    created_at: Date | null
    updated_at: Date | null
    is_private: boolean | null
    _count: Session_notesCountAggregateOutputType | null
    _avg: Session_notesAvgAggregateOutputType | null
    _sum: Session_notesSumAggregateOutputType | null
    _min: Session_notesMinAggregateOutputType | null
    _max: Session_notesMaxAggregateOutputType | null
  }

  type GetSession_notesGroupByPayload<T extends session_notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_notesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_notesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_notesGroupByOutputType[P]>
            : GetScalarType<T[P], Session_notesGroupByOutputType[P]>
        }
      >
    >


  export type session_notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    note_id?: boolean
    session_id?: boolean
    author_id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_private?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_notes"]>



  export type session_notesSelectScalar = {
    note_id?: boolean
    session_id?: boolean
    author_id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_private?: boolean
  }

  export type session_notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"note_id" | "session_id" | "author_id" | "content" | "created_at" | "updated_at" | "is_private", ExtArgs["result"]["session_notes"]>
  export type session_notesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $session_notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_notes"
    objects: {
      sessions: Prisma.$sessionsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      note_id: number
      session_id: number
      author_id: number
      content: string
      created_at: Date | null
      updated_at: Date | null
      is_private: boolean | null
    }, ExtArgs["result"]["session_notes"]>
    composites: {}
  }

  type session_notesGetPayload<S extends boolean | null | undefined | session_notesDefaultArgs> = $Result.GetResult<Prisma.$session_notesPayload, S>

  type session_notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<session_notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Session_notesCountAggregateInputType | true
    }

  export interface session_notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_notes'], meta: { name: 'session_notes' } }
    /**
     * Find zero or one Session_notes that matches the filter.
     * @param {session_notesFindUniqueArgs} args - Arguments to find a Session_notes
     * @example
     * // Get one Session_notes
     * const session_notes = await prisma.session_notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_notesFindUniqueArgs>(args: SelectSubset<T, session_notesFindUniqueArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session_notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {session_notesFindUniqueOrThrowArgs} args - Arguments to find a Session_notes
     * @example
     * // Get one Session_notes
     * const session_notes = await prisma.session_notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_notesFindUniqueOrThrowArgs>(args: SelectSubset<T, session_notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_notesFindFirstArgs} args - Arguments to find a Session_notes
     * @example
     * // Get one Session_notes
     * const session_notes = await prisma.session_notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_notesFindFirstArgs>(args?: SelectSubset<T, session_notesFindFirstArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_notesFindFirstOrThrowArgs} args - Arguments to find a Session_notes
     * @example
     * // Get one Session_notes
     * const session_notes = await prisma.session_notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_notesFindFirstOrThrowArgs>(args?: SelectSubset<T, session_notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Session_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_notes
     * const session_notes = await prisma.session_notes.findMany()
     * 
     * // Get first 10 Session_notes
     * const session_notes = await prisma.session_notes.findMany({ take: 10 })
     * 
     * // Only select the `note_id`
     * const session_notesWithNote_idOnly = await prisma.session_notes.findMany({ select: { note_id: true } })
     * 
     */
    findMany<T extends session_notesFindManyArgs>(args?: SelectSubset<T, session_notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session_notes.
     * @param {session_notesCreateArgs} args - Arguments to create a Session_notes.
     * @example
     * // Create one Session_notes
     * const Session_notes = await prisma.session_notes.create({
     *   data: {
     *     // ... data to create a Session_notes
     *   }
     * })
     * 
     */
    create<T extends session_notesCreateArgs>(args: SelectSubset<T, session_notesCreateArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Session_notes.
     * @param {session_notesCreateManyArgs} args - Arguments to create many Session_notes.
     * @example
     * // Create many Session_notes
     * const session_notes = await prisma.session_notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_notesCreateManyArgs>(args?: SelectSubset<T, session_notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session_notes.
     * @param {session_notesDeleteArgs} args - Arguments to delete one Session_notes.
     * @example
     * // Delete one Session_notes
     * const Session_notes = await prisma.session_notes.delete({
     *   where: {
     *     // ... filter to delete one Session_notes
     *   }
     * })
     * 
     */
    delete<T extends session_notesDeleteArgs>(args: SelectSubset<T, session_notesDeleteArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session_notes.
     * @param {session_notesUpdateArgs} args - Arguments to update one Session_notes.
     * @example
     * // Update one Session_notes
     * const session_notes = await prisma.session_notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_notesUpdateArgs>(args: SelectSubset<T, session_notesUpdateArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Session_notes.
     * @param {session_notesDeleteManyArgs} args - Arguments to filter Session_notes to delete.
     * @example
     * // Delete a few Session_notes
     * const { count } = await prisma.session_notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_notesDeleteManyArgs>(args?: SelectSubset<T, session_notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_notes
     * const session_notes = await prisma.session_notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_notesUpdateManyArgs>(args: SelectSubset<T, session_notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session_notes.
     * @param {session_notesUpsertArgs} args - Arguments to update or create a Session_notes.
     * @example
     * // Update or create a Session_notes
     * const session_notes = await prisma.session_notes.upsert({
     *   create: {
     *     // ... data to create a Session_notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_notes we want to update
     *   }
     * })
     */
    upsert<T extends session_notesUpsertArgs>(args: SelectSubset<T, session_notesUpsertArgs<ExtArgs>>): Prisma__session_notesClient<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Session_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_notesCountArgs} args - Arguments to filter Session_notes to count.
     * @example
     * // Count the number of Session_notes
     * const count = await prisma.session_notes.count({
     *   where: {
     *     // ... the filter for the Session_notes we want to count
     *   }
     * })
    **/
    count<T extends session_notesCountArgs>(
      args?: Subset<T, session_notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_notesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_notesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_notesAggregateArgs>(args: Subset<T, Session_notesAggregateArgs>): Prisma.PrismaPromise<GetSession_notesAggregateType<T>>

    /**
     * Group by Session_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_notesGroupByArgs['orderBy'] }
        : { orderBy?: session_notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_notesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_notes model
   */
  readonly fields: session_notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessionsDefaultArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_notes model
   */
  interface session_notesFieldRefs {
    readonly note_id: FieldRef<"session_notes", 'Int'>
    readonly session_id: FieldRef<"session_notes", 'Int'>
    readonly author_id: FieldRef<"session_notes", 'Int'>
    readonly content: FieldRef<"session_notes", 'String'>
    readonly created_at: FieldRef<"session_notes", 'DateTime'>
    readonly updated_at: FieldRef<"session_notes", 'DateTime'>
    readonly is_private: FieldRef<"session_notes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * session_notes findUnique
   */
  export type session_notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * Filter, which session_notes to fetch.
     */
    where: session_notesWhereUniqueInput
  }

  /**
   * session_notes findUniqueOrThrow
   */
  export type session_notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * Filter, which session_notes to fetch.
     */
    where: session_notesWhereUniqueInput
  }

  /**
   * session_notes findFirst
   */
  export type session_notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * Filter, which session_notes to fetch.
     */
    where?: session_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_notes to fetch.
     */
    orderBy?: session_notesOrderByWithRelationInput | session_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_notes.
     */
    cursor?: session_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_notes.
     */
    distinct?: Session_notesScalarFieldEnum | Session_notesScalarFieldEnum[]
  }

  /**
   * session_notes findFirstOrThrow
   */
  export type session_notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * Filter, which session_notes to fetch.
     */
    where?: session_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_notes to fetch.
     */
    orderBy?: session_notesOrderByWithRelationInput | session_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_notes.
     */
    cursor?: session_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_notes.
     */
    distinct?: Session_notesScalarFieldEnum | Session_notesScalarFieldEnum[]
  }

  /**
   * session_notes findMany
   */
  export type session_notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * Filter, which session_notes to fetch.
     */
    where?: session_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_notes to fetch.
     */
    orderBy?: session_notesOrderByWithRelationInput | session_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_notes.
     */
    cursor?: session_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_notes.
     */
    skip?: number
    distinct?: Session_notesScalarFieldEnum | Session_notesScalarFieldEnum[]
  }

  /**
   * session_notes create
   */
  export type session_notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * The data needed to create a session_notes.
     */
    data: XOR<session_notesCreateInput, session_notesUncheckedCreateInput>
  }

  /**
   * session_notes createMany
   */
  export type session_notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_notes.
     */
    data: session_notesCreateManyInput | session_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_notes update
   */
  export type session_notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * The data needed to update a session_notes.
     */
    data: XOR<session_notesUpdateInput, session_notesUncheckedUpdateInput>
    /**
     * Choose, which session_notes to update.
     */
    where: session_notesWhereUniqueInput
  }

  /**
   * session_notes updateMany
   */
  export type session_notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_notes.
     */
    data: XOR<session_notesUpdateManyMutationInput, session_notesUncheckedUpdateManyInput>
    /**
     * Filter which session_notes to update
     */
    where?: session_notesWhereInput
    /**
     * Limit how many session_notes to update.
     */
    limit?: number
  }

  /**
   * session_notes upsert
   */
  export type session_notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * The filter to search for the session_notes to update in case it exists.
     */
    where: session_notesWhereUniqueInput
    /**
     * In case the session_notes found by the `where` argument doesn't exist, create a new session_notes with this data.
     */
    create: XOR<session_notesCreateInput, session_notesUncheckedCreateInput>
    /**
     * In case the session_notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_notesUpdateInput, session_notesUncheckedUpdateInput>
  }

  /**
   * session_notes delete
   */
  export type session_notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    /**
     * Filter which session_notes to delete.
     */
    where: session_notesWhereUniqueInput
  }

  /**
   * session_notes deleteMany
   */
  export type session_notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_notes to delete
     */
    where?: session_notesWhereInput
    /**
     * Limit how many session_notes to delete.
     */
    limit?: number
  }

  /**
   * session_notes without action
   */
  export type session_notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
  }


  /**
   * Model session_ratings
   */

  export type AggregateSession_ratings = {
    _count: Session_ratingsCountAggregateOutputType | null
    _avg: Session_ratingsAvgAggregateOutputType | null
    _sum: Session_ratingsSumAggregateOutputType | null
    _min: Session_ratingsMinAggregateOutputType | null
    _max: Session_ratingsMaxAggregateOutputType | null
  }

  export type Session_ratingsAvgAggregateOutputType = {
    rating_id: number | null
    session_id: number | null
    student_id: number | null
    tutor_id: number | null
    rating: Decimal | null
  }

  export type Session_ratingsSumAggregateOutputType = {
    rating_id: number | null
    session_id: number | null
    student_id: number | null
    tutor_id: number | null
    rating: Decimal | null
  }

  export type Session_ratingsMinAggregateOutputType = {
    rating_id: number | null
    session_id: number | null
    student_id: number | null
    tutor_id: number | null
    rating: Decimal | null
    feedback: string | null
    created_at: Date | null
  }

  export type Session_ratingsMaxAggregateOutputType = {
    rating_id: number | null
    session_id: number | null
    student_id: number | null
    tutor_id: number | null
    rating: Decimal | null
    feedback: string | null
    created_at: Date | null
  }

  export type Session_ratingsCountAggregateOutputType = {
    rating_id: number
    session_id: number
    student_id: number
    tutor_id: number
    rating: number
    feedback: number
    created_at: number
    _all: number
  }


  export type Session_ratingsAvgAggregateInputType = {
    rating_id?: true
    session_id?: true
    student_id?: true
    tutor_id?: true
    rating?: true
  }

  export type Session_ratingsSumAggregateInputType = {
    rating_id?: true
    session_id?: true
    student_id?: true
    tutor_id?: true
    rating?: true
  }

  export type Session_ratingsMinAggregateInputType = {
    rating_id?: true
    session_id?: true
    student_id?: true
    tutor_id?: true
    rating?: true
    feedback?: true
    created_at?: true
  }

  export type Session_ratingsMaxAggregateInputType = {
    rating_id?: true
    session_id?: true
    student_id?: true
    tutor_id?: true
    rating?: true
    feedback?: true
    created_at?: true
  }

  export type Session_ratingsCountAggregateInputType = {
    rating_id?: true
    session_id?: true
    student_id?: true
    tutor_id?: true
    rating?: true
    feedback?: true
    created_at?: true
    _all?: true
  }

  export type Session_ratingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_ratings to aggregate.
     */
    where?: session_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_ratings to fetch.
     */
    orderBy?: session_ratingsOrderByWithRelationInput | session_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_ratings
    **/
    _count?: true | Session_ratingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_ratingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_ratingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_ratingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_ratingsMaxAggregateInputType
  }

  export type GetSession_ratingsAggregateType<T extends Session_ratingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_ratings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_ratings[P]>
      : GetScalarType<T[P], AggregateSession_ratings[P]>
  }




  export type session_ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_ratingsWhereInput
    orderBy?: session_ratingsOrderByWithAggregationInput | session_ratingsOrderByWithAggregationInput[]
    by: Session_ratingsScalarFieldEnum[] | Session_ratingsScalarFieldEnum
    having?: session_ratingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_ratingsCountAggregateInputType | true
    _avg?: Session_ratingsAvgAggregateInputType
    _sum?: Session_ratingsSumAggregateInputType
    _min?: Session_ratingsMinAggregateInputType
    _max?: Session_ratingsMaxAggregateInputType
  }

  export type Session_ratingsGroupByOutputType = {
    rating_id: number
    session_id: number
    student_id: number
    tutor_id: number
    rating: Decimal
    feedback: string | null
    created_at: Date | null
    _count: Session_ratingsCountAggregateOutputType | null
    _avg: Session_ratingsAvgAggregateOutputType | null
    _sum: Session_ratingsSumAggregateOutputType | null
    _min: Session_ratingsMinAggregateOutputType | null
    _max: Session_ratingsMaxAggregateOutputType | null
  }

  type GetSession_ratingsGroupByPayload<T extends session_ratingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_ratingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_ratingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_ratingsGroupByOutputType[P]>
            : GetScalarType<T[P], Session_ratingsGroupByOutputType[P]>
        }
      >
    >


  export type session_ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rating_id?: boolean
    session_id?: boolean
    student_id?: boolean
    tutor_id?: boolean
    rating?: boolean
    feedback?: boolean
    created_at?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_ratings"]>



  export type session_ratingsSelectScalar = {
    rating_id?: boolean
    session_id?: boolean
    student_id?: boolean
    tutor_id?: boolean
    rating?: boolean
    feedback?: boolean
    created_at?: boolean
  }

  export type session_ratingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"rating_id" | "session_id" | "student_id" | "tutor_id" | "rating" | "feedback" | "created_at", ExtArgs["result"]["session_ratings"]>
  export type session_ratingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
  }

  export type $session_ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_ratings"
    objects: {
      sessions: Prisma.$sessionsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
      tutors: Prisma.$tutorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      rating_id: number
      session_id: number
      student_id: number
      tutor_id: number
      rating: Prisma.Decimal
      feedback: string | null
      created_at: Date | null
    }, ExtArgs["result"]["session_ratings"]>
    composites: {}
  }

  type session_ratingsGetPayload<S extends boolean | null | undefined | session_ratingsDefaultArgs> = $Result.GetResult<Prisma.$session_ratingsPayload, S>

  type session_ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<session_ratingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Session_ratingsCountAggregateInputType | true
    }

  export interface session_ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_ratings'], meta: { name: 'session_ratings' } }
    /**
     * Find zero or one Session_ratings that matches the filter.
     * @param {session_ratingsFindUniqueArgs} args - Arguments to find a Session_ratings
     * @example
     * // Get one Session_ratings
     * const session_ratings = await prisma.session_ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_ratingsFindUniqueArgs>(args: SelectSubset<T, session_ratingsFindUniqueArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session_ratings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {session_ratingsFindUniqueOrThrowArgs} args - Arguments to find a Session_ratings
     * @example
     * // Get one Session_ratings
     * const session_ratings = await prisma.session_ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_ratingsFindUniqueOrThrowArgs>(args: SelectSubset<T, session_ratingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_ratingsFindFirstArgs} args - Arguments to find a Session_ratings
     * @example
     * // Get one Session_ratings
     * const session_ratings = await prisma.session_ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_ratingsFindFirstArgs>(args?: SelectSubset<T, session_ratingsFindFirstArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_ratingsFindFirstOrThrowArgs} args - Arguments to find a Session_ratings
     * @example
     * // Get one Session_ratings
     * const session_ratings = await prisma.session_ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_ratingsFindFirstOrThrowArgs>(args?: SelectSubset<T, session_ratingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Session_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_ratingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_ratings
     * const session_ratings = await prisma.session_ratings.findMany()
     * 
     * // Get first 10 Session_ratings
     * const session_ratings = await prisma.session_ratings.findMany({ take: 10 })
     * 
     * // Only select the `rating_id`
     * const session_ratingsWithRating_idOnly = await prisma.session_ratings.findMany({ select: { rating_id: true } })
     * 
     */
    findMany<T extends session_ratingsFindManyArgs>(args?: SelectSubset<T, session_ratingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session_ratings.
     * @param {session_ratingsCreateArgs} args - Arguments to create a Session_ratings.
     * @example
     * // Create one Session_ratings
     * const Session_ratings = await prisma.session_ratings.create({
     *   data: {
     *     // ... data to create a Session_ratings
     *   }
     * })
     * 
     */
    create<T extends session_ratingsCreateArgs>(args: SelectSubset<T, session_ratingsCreateArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Session_ratings.
     * @param {session_ratingsCreateManyArgs} args - Arguments to create many Session_ratings.
     * @example
     * // Create many Session_ratings
     * const session_ratings = await prisma.session_ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_ratingsCreateManyArgs>(args?: SelectSubset<T, session_ratingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session_ratings.
     * @param {session_ratingsDeleteArgs} args - Arguments to delete one Session_ratings.
     * @example
     * // Delete one Session_ratings
     * const Session_ratings = await prisma.session_ratings.delete({
     *   where: {
     *     // ... filter to delete one Session_ratings
     *   }
     * })
     * 
     */
    delete<T extends session_ratingsDeleteArgs>(args: SelectSubset<T, session_ratingsDeleteArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session_ratings.
     * @param {session_ratingsUpdateArgs} args - Arguments to update one Session_ratings.
     * @example
     * // Update one Session_ratings
     * const session_ratings = await prisma.session_ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_ratingsUpdateArgs>(args: SelectSubset<T, session_ratingsUpdateArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Session_ratings.
     * @param {session_ratingsDeleteManyArgs} args - Arguments to filter Session_ratings to delete.
     * @example
     * // Delete a few Session_ratings
     * const { count } = await prisma.session_ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_ratingsDeleteManyArgs>(args?: SelectSubset<T, session_ratingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_ratingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_ratings
     * const session_ratings = await prisma.session_ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_ratingsUpdateManyArgs>(args: SelectSubset<T, session_ratingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session_ratings.
     * @param {session_ratingsUpsertArgs} args - Arguments to update or create a Session_ratings.
     * @example
     * // Update or create a Session_ratings
     * const session_ratings = await prisma.session_ratings.upsert({
     *   create: {
     *     // ... data to create a Session_ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_ratings we want to update
     *   }
     * })
     */
    upsert<T extends session_ratingsUpsertArgs>(args: SelectSubset<T, session_ratingsUpsertArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Session_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_ratingsCountArgs} args - Arguments to filter Session_ratings to count.
     * @example
     * // Count the number of Session_ratings
     * const count = await prisma.session_ratings.count({
     *   where: {
     *     // ... the filter for the Session_ratings we want to count
     *   }
     * })
    **/
    count<T extends session_ratingsCountArgs>(
      args?: Subset<T, session_ratingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_ratingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_ratingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_ratingsAggregateArgs>(args: Subset<T, Session_ratingsAggregateArgs>): Prisma.PrismaPromise<GetSession_ratingsAggregateType<T>>

    /**
     * Group by Session_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_ratingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_ratingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_ratingsGroupByArgs['orderBy'] }
        : { orderBy?: session_ratingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_ratingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_ratings model
   */
  readonly fields: session_ratingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessionsDefaultArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tutors<T extends tutorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tutorsDefaultArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_ratings model
   */
  interface session_ratingsFieldRefs {
    readonly rating_id: FieldRef<"session_ratings", 'Int'>
    readonly session_id: FieldRef<"session_ratings", 'Int'>
    readonly student_id: FieldRef<"session_ratings", 'Int'>
    readonly tutor_id: FieldRef<"session_ratings", 'Int'>
    readonly rating: FieldRef<"session_ratings", 'Decimal'>
    readonly feedback: FieldRef<"session_ratings", 'String'>
    readonly created_at: FieldRef<"session_ratings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * session_ratings findUnique
   */
  export type session_ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which session_ratings to fetch.
     */
    where: session_ratingsWhereUniqueInput
  }

  /**
   * session_ratings findUniqueOrThrow
   */
  export type session_ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which session_ratings to fetch.
     */
    where: session_ratingsWhereUniqueInput
  }

  /**
   * session_ratings findFirst
   */
  export type session_ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which session_ratings to fetch.
     */
    where?: session_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_ratings to fetch.
     */
    orderBy?: session_ratingsOrderByWithRelationInput | session_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_ratings.
     */
    cursor?: session_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_ratings.
     */
    distinct?: Session_ratingsScalarFieldEnum | Session_ratingsScalarFieldEnum[]
  }

  /**
   * session_ratings findFirstOrThrow
   */
  export type session_ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which session_ratings to fetch.
     */
    where?: session_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_ratings to fetch.
     */
    orderBy?: session_ratingsOrderByWithRelationInput | session_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_ratings.
     */
    cursor?: session_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_ratings.
     */
    distinct?: Session_ratingsScalarFieldEnum | Session_ratingsScalarFieldEnum[]
  }

  /**
   * session_ratings findMany
   */
  export type session_ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which session_ratings to fetch.
     */
    where?: session_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_ratings to fetch.
     */
    orderBy?: session_ratingsOrderByWithRelationInput | session_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_ratings.
     */
    cursor?: session_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_ratings.
     */
    skip?: number
    distinct?: Session_ratingsScalarFieldEnum | Session_ratingsScalarFieldEnum[]
  }

  /**
   * session_ratings create
   */
  export type session_ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * The data needed to create a session_ratings.
     */
    data: XOR<session_ratingsCreateInput, session_ratingsUncheckedCreateInput>
  }

  /**
   * session_ratings createMany
   */
  export type session_ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_ratings.
     */
    data: session_ratingsCreateManyInput | session_ratingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_ratings update
   */
  export type session_ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * The data needed to update a session_ratings.
     */
    data: XOR<session_ratingsUpdateInput, session_ratingsUncheckedUpdateInput>
    /**
     * Choose, which session_ratings to update.
     */
    where: session_ratingsWhereUniqueInput
  }

  /**
   * session_ratings updateMany
   */
  export type session_ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_ratings.
     */
    data: XOR<session_ratingsUpdateManyMutationInput, session_ratingsUncheckedUpdateManyInput>
    /**
     * Filter which session_ratings to update
     */
    where?: session_ratingsWhereInput
    /**
     * Limit how many session_ratings to update.
     */
    limit?: number
  }

  /**
   * session_ratings upsert
   */
  export type session_ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * The filter to search for the session_ratings to update in case it exists.
     */
    where: session_ratingsWhereUniqueInput
    /**
     * In case the session_ratings found by the `where` argument doesn't exist, create a new session_ratings with this data.
     */
    create: XOR<session_ratingsCreateInput, session_ratingsUncheckedCreateInput>
    /**
     * In case the session_ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_ratingsUpdateInput, session_ratingsUncheckedUpdateInput>
  }

  /**
   * session_ratings delete
   */
  export type session_ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    /**
     * Filter which session_ratings to delete.
     */
    where: session_ratingsWhereUniqueInput
  }

  /**
   * session_ratings deleteMany
   */
  export type session_ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_ratings to delete
     */
    where?: session_ratingsWhereInput
    /**
     * Limit how many session_ratings to delete.
     */
    limit?: number
  }

  /**
   * session_ratings without action
   */
  export type session_ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
  }


  /**
   * Model session_resources
   */

  export type AggregateSession_resources = {
    _count: Session_resourcesCountAggregateOutputType | null
    _avg: Session_resourcesAvgAggregateOutputType | null
    _sum: Session_resourcesSumAggregateOutputType | null
    _min: Session_resourcesMinAggregateOutputType | null
    _max: Session_resourcesMaxAggregateOutputType | null
  }

  export type Session_resourcesAvgAggregateOutputType = {
    session_resource_id: number | null
    session_id: number | null
    resource_id: number | null
  }

  export type Session_resourcesSumAggregateOutputType = {
    session_resource_id: number | null
    session_id: number | null
    resource_id: number | null
  }

  export type Session_resourcesMinAggregateOutputType = {
    session_resource_id: number | null
    session_id: number | null
    resource_id: number | null
  }

  export type Session_resourcesMaxAggregateOutputType = {
    session_resource_id: number | null
    session_id: number | null
    resource_id: number | null
  }

  export type Session_resourcesCountAggregateOutputType = {
    session_resource_id: number
    session_id: number
    resource_id: number
    _all: number
  }


  export type Session_resourcesAvgAggregateInputType = {
    session_resource_id?: true
    session_id?: true
    resource_id?: true
  }

  export type Session_resourcesSumAggregateInputType = {
    session_resource_id?: true
    session_id?: true
    resource_id?: true
  }

  export type Session_resourcesMinAggregateInputType = {
    session_resource_id?: true
    session_id?: true
    resource_id?: true
  }

  export type Session_resourcesMaxAggregateInputType = {
    session_resource_id?: true
    session_id?: true
    resource_id?: true
  }

  export type Session_resourcesCountAggregateInputType = {
    session_resource_id?: true
    session_id?: true
    resource_id?: true
    _all?: true
  }

  export type Session_resourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_resources to aggregate.
     */
    where?: session_resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_resources to fetch.
     */
    orderBy?: session_resourcesOrderByWithRelationInput | session_resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_resources
    **/
    _count?: true | Session_resourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_resourcesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_resourcesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_resourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_resourcesMaxAggregateInputType
  }

  export type GetSession_resourcesAggregateType<T extends Session_resourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_resources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_resources[P]>
      : GetScalarType<T[P], AggregateSession_resources[P]>
  }




  export type session_resourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_resourcesWhereInput
    orderBy?: session_resourcesOrderByWithAggregationInput | session_resourcesOrderByWithAggregationInput[]
    by: Session_resourcesScalarFieldEnum[] | Session_resourcesScalarFieldEnum
    having?: session_resourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_resourcesCountAggregateInputType | true
    _avg?: Session_resourcesAvgAggregateInputType
    _sum?: Session_resourcesSumAggregateInputType
    _min?: Session_resourcesMinAggregateInputType
    _max?: Session_resourcesMaxAggregateInputType
  }

  export type Session_resourcesGroupByOutputType = {
    session_resource_id: number
    session_id: number
    resource_id: number
    _count: Session_resourcesCountAggregateOutputType | null
    _avg: Session_resourcesAvgAggregateOutputType | null
    _sum: Session_resourcesSumAggregateOutputType | null
    _min: Session_resourcesMinAggregateOutputType | null
    _max: Session_resourcesMaxAggregateOutputType | null
  }

  type GetSession_resourcesGroupByPayload<T extends session_resourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_resourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_resourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_resourcesGroupByOutputType[P]>
            : GetScalarType<T[P], Session_resourcesGroupByOutputType[P]>
        }
      >
    >


  export type session_resourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_resource_id?: boolean
    session_id?: boolean
    resource_id?: boolean
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
    resources?: boolean | resourcesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_resources"]>



  export type session_resourcesSelectScalar = {
    session_resource_id?: boolean
    session_id?: boolean
    resource_id?: boolean
  }

  export type session_resourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"session_resource_id" | "session_id" | "resource_id", ExtArgs["result"]["session_resources"]>
  export type session_resourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | sessionsDefaultArgs<ExtArgs>
    resources?: boolean | resourcesDefaultArgs<ExtArgs>
  }

  export type $session_resourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_resources"
    objects: {
      sessions: Prisma.$sessionsPayload<ExtArgs>
      resources: Prisma.$resourcesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      session_resource_id: number
      session_id: number
      resource_id: number
    }, ExtArgs["result"]["session_resources"]>
    composites: {}
  }

  type session_resourcesGetPayload<S extends boolean | null | undefined | session_resourcesDefaultArgs> = $Result.GetResult<Prisma.$session_resourcesPayload, S>

  type session_resourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<session_resourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Session_resourcesCountAggregateInputType | true
    }

  export interface session_resourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_resources'], meta: { name: 'session_resources' } }
    /**
     * Find zero or one Session_resources that matches the filter.
     * @param {session_resourcesFindUniqueArgs} args - Arguments to find a Session_resources
     * @example
     * // Get one Session_resources
     * const session_resources = await prisma.session_resources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_resourcesFindUniqueArgs>(args: SelectSubset<T, session_resourcesFindUniqueArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session_resources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {session_resourcesFindUniqueOrThrowArgs} args - Arguments to find a Session_resources
     * @example
     * // Get one Session_resources
     * const session_resources = await prisma.session_resources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_resourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, session_resourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_resourcesFindFirstArgs} args - Arguments to find a Session_resources
     * @example
     * // Get one Session_resources
     * const session_resources = await prisma.session_resources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_resourcesFindFirstArgs>(args?: SelectSubset<T, session_resourcesFindFirstArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_resources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_resourcesFindFirstOrThrowArgs} args - Arguments to find a Session_resources
     * @example
     * // Get one Session_resources
     * const session_resources = await prisma.session_resources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_resourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, session_resourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Session_resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_resourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_resources
     * const session_resources = await prisma.session_resources.findMany()
     * 
     * // Get first 10 Session_resources
     * const session_resources = await prisma.session_resources.findMany({ take: 10 })
     * 
     * // Only select the `session_resource_id`
     * const session_resourcesWithSession_resource_idOnly = await prisma.session_resources.findMany({ select: { session_resource_id: true } })
     * 
     */
    findMany<T extends session_resourcesFindManyArgs>(args?: SelectSubset<T, session_resourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session_resources.
     * @param {session_resourcesCreateArgs} args - Arguments to create a Session_resources.
     * @example
     * // Create one Session_resources
     * const Session_resources = await prisma.session_resources.create({
     *   data: {
     *     // ... data to create a Session_resources
     *   }
     * })
     * 
     */
    create<T extends session_resourcesCreateArgs>(args: SelectSubset<T, session_resourcesCreateArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Session_resources.
     * @param {session_resourcesCreateManyArgs} args - Arguments to create many Session_resources.
     * @example
     * // Create many Session_resources
     * const session_resources = await prisma.session_resources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_resourcesCreateManyArgs>(args?: SelectSubset<T, session_resourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session_resources.
     * @param {session_resourcesDeleteArgs} args - Arguments to delete one Session_resources.
     * @example
     * // Delete one Session_resources
     * const Session_resources = await prisma.session_resources.delete({
     *   where: {
     *     // ... filter to delete one Session_resources
     *   }
     * })
     * 
     */
    delete<T extends session_resourcesDeleteArgs>(args: SelectSubset<T, session_resourcesDeleteArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session_resources.
     * @param {session_resourcesUpdateArgs} args - Arguments to update one Session_resources.
     * @example
     * // Update one Session_resources
     * const session_resources = await prisma.session_resources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_resourcesUpdateArgs>(args: SelectSubset<T, session_resourcesUpdateArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Session_resources.
     * @param {session_resourcesDeleteManyArgs} args - Arguments to filter Session_resources to delete.
     * @example
     * // Delete a few Session_resources
     * const { count } = await prisma.session_resources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_resourcesDeleteManyArgs>(args?: SelectSubset<T, session_resourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_resourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_resources
     * const session_resources = await prisma.session_resources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_resourcesUpdateManyArgs>(args: SelectSubset<T, session_resourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session_resources.
     * @param {session_resourcesUpsertArgs} args - Arguments to update or create a Session_resources.
     * @example
     * // Update or create a Session_resources
     * const session_resources = await prisma.session_resources.upsert({
     *   create: {
     *     // ... data to create a Session_resources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_resources we want to update
     *   }
     * })
     */
    upsert<T extends session_resourcesUpsertArgs>(args: SelectSubset<T, session_resourcesUpsertArgs<ExtArgs>>): Prisma__session_resourcesClient<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Session_resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_resourcesCountArgs} args - Arguments to filter Session_resources to count.
     * @example
     * // Count the number of Session_resources
     * const count = await prisma.session_resources.count({
     *   where: {
     *     // ... the filter for the Session_resources we want to count
     *   }
     * })
    **/
    count<T extends session_resourcesCountArgs>(
      args?: Subset<T, session_resourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_resourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_resourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_resourcesAggregateArgs>(args: Subset<T, Session_resourcesAggregateArgs>): Prisma.PrismaPromise<GetSession_resourcesAggregateType<T>>

    /**
     * Group by Session_resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_resourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_resourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_resourcesGroupByArgs['orderBy'] }
        : { orderBy?: session_resourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_resourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_resourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_resources model
   */
  readonly fields: session_resourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_resources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_resourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessionsDefaultArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resources<T extends resourcesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, resourcesDefaultArgs<ExtArgs>>): Prisma__resourcesClient<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_resources model
   */
  interface session_resourcesFieldRefs {
    readonly session_resource_id: FieldRef<"session_resources", 'Int'>
    readonly session_id: FieldRef<"session_resources", 'Int'>
    readonly resource_id: FieldRef<"session_resources", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * session_resources findUnique
   */
  export type session_resourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * Filter, which session_resources to fetch.
     */
    where: session_resourcesWhereUniqueInput
  }

  /**
   * session_resources findUniqueOrThrow
   */
  export type session_resourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * Filter, which session_resources to fetch.
     */
    where: session_resourcesWhereUniqueInput
  }

  /**
   * session_resources findFirst
   */
  export type session_resourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * Filter, which session_resources to fetch.
     */
    where?: session_resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_resources to fetch.
     */
    orderBy?: session_resourcesOrderByWithRelationInput | session_resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_resources.
     */
    cursor?: session_resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_resources.
     */
    distinct?: Session_resourcesScalarFieldEnum | Session_resourcesScalarFieldEnum[]
  }

  /**
   * session_resources findFirstOrThrow
   */
  export type session_resourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * Filter, which session_resources to fetch.
     */
    where?: session_resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_resources to fetch.
     */
    orderBy?: session_resourcesOrderByWithRelationInput | session_resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_resources.
     */
    cursor?: session_resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_resources.
     */
    distinct?: Session_resourcesScalarFieldEnum | Session_resourcesScalarFieldEnum[]
  }

  /**
   * session_resources findMany
   */
  export type session_resourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * Filter, which session_resources to fetch.
     */
    where?: session_resourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_resources to fetch.
     */
    orderBy?: session_resourcesOrderByWithRelationInput | session_resourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_resources.
     */
    cursor?: session_resourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_resources.
     */
    skip?: number
    distinct?: Session_resourcesScalarFieldEnum | Session_resourcesScalarFieldEnum[]
  }

  /**
   * session_resources create
   */
  export type session_resourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a session_resources.
     */
    data: XOR<session_resourcesCreateInput, session_resourcesUncheckedCreateInput>
  }

  /**
   * session_resources createMany
   */
  export type session_resourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_resources.
     */
    data: session_resourcesCreateManyInput | session_resourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_resources update
   */
  export type session_resourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a session_resources.
     */
    data: XOR<session_resourcesUpdateInput, session_resourcesUncheckedUpdateInput>
    /**
     * Choose, which session_resources to update.
     */
    where: session_resourcesWhereUniqueInput
  }

  /**
   * session_resources updateMany
   */
  export type session_resourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_resources.
     */
    data: XOR<session_resourcesUpdateManyMutationInput, session_resourcesUncheckedUpdateManyInput>
    /**
     * Filter which session_resources to update
     */
    where?: session_resourcesWhereInput
    /**
     * Limit how many session_resources to update.
     */
    limit?: number
  }

  /**
   * session_resources upsert
   */
  export type session_resourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the session_resources to update in case it exists.
     */
    where: session_resourcesWhereUniqueInput
    /**
     * In case the session_resources found by the `where` argument doesn't exist, create a new session_resources with this data.
     */
    create: XOR<session_resourcesCreateInput, session_resourcesUncheckedCreateInput>
    /**
     * In case the session_resources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_resourcesUpdateInput, session_resourcesUncheckedUpdateInput>
  }

  /**
   * session_resources delete
   */
  export type session_resourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    /**
     * Filter which session_resources to delete.
     */
    where: session_resourcesWhereUniqueInput
  }

  /**
   * session_resources deleteMany
   */
  export type session_resourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_resources to delete
     */
    where?: session_resourcesWhereInput
    /**
     * Limit how many session_resources to delete.
     */
    limit?: number
  }

  /**
   * session_resources without action
   */
  export type session_resourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    session_id: number | null
    tutor_id: number | null
    student_id: number | null
    subject_id: number | null
    duration_minutes: number | null
    hourly_rate: Decimal | null
    session_cost: Decimal | null
    cancellation_fee: Decimal | null
  }

  export type SessionsSumAggregateOutputType = {
    session_id: number | null
    tutor_id: number | null
    student_id: number | null
    subject_id: number | null
    duration_minutes: number | null
    hourly_rate: Decimal | null
    session_cost: Decimal | null
    cancellation_fee: Decimal | null
  }

  export type SessionsMinAggregateOutputType = {
    session_id: number | null
    tutor_id: number | null
    student_id: number | null
    subject_id: number | null
    start_time: Date | null
    end_time: Date | null
    duration_minutes: number | null
    hourly_rate: Decimal | null
    session_cost: Decimal | null
    status: string | null
    meeting_url: string | null
    notes: string | null
    materials_url: string | null
    created_at: Date | null
    canceled_at: Date | null
    cancellation_reason: string | null
    cancellation_fee: Decimal | null
  }

  export type SessionsMaxAggregateOutputType = {
    session_id: number | null
    tutor_id: number | null
    student_id: number | null
    subject_id: number | null
    start_time: Date | null
    end_time: Date | null
    duration_minutes: number | null
    hourly_rate: Decimal | null
    session_cost: Decimal | null
    status: string | null
    meeting_url: string | null
    notes: string | null
    materials_url: string | null
    created_at: Date | null
    canceled_at: Date | null
    cancellation_reason: string | null
    cancellation_fee: Decimal | null
  }

  export type SessionsCountAggregateOutputType = {
    session_id: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: number
    end_time: number
    duration_minutes: number
    hourly_rate: number
    session_cost: number
    status: number
    meeting_url: number
    notes: number
    materials_url: number
    created_at: number
    canceled_at: number
    cancellation_reason: number
    cancellation_fee: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    session_id?: true
    tutor_id?: true
    student_id?: true
    subject_id?: true
    duration_minutes?: true
    hourly_rate?: true
    session_cost?: true
    cancellation_fee?: true
  }

  export type SessionsSumAggregateInputType = {
    session_id?: true
    tutor_id?: true
    student_id?: true
    subject_id?: true
    duration_minutes?: true
    hourly_rate?: true
    session_cost?: true
    cancellation_fee?: true
  }

  export type SessionsMinAggregateInputType = {
    session_id?: true
    tutor_id?: true
    student_id?: true
    subject_id?: true
    start_time?: true
    end_time?: true
    duration_minutes?: true
    hourly_rate?: true
    session_cost?: true
    status?: true
    meeting_url?: true
    notes?: true
    materials_url?: true
    created_at?: true
    canceled_at?: true
    cancellation_reason?: true
    cancellation_fee?: true
  }

  export type SessionsMaxAggregateInputType = {
    session_id?: true
    tutor_id?: true
    student_id?: true
    subject_id?: true
    start_time?: true
    end_time?: true
    duration_minutes?: true
    hourly_rate?: true
    session_cost?: true
    status?: true
    meeting_url?: true
    notes?: true
    materials_url?: true
    created_at?: true
    canceled_at?: true
    cancellation_reason?: true
    cancellation_fee?: true
  }

  export type SessionsCountAggregateInputType = {
    session_id?: true
    tutor_id?: true
    student_id?: true
    subject_id?: true
    start_time?: true
    end_time?: true
    duration_minutes?: true
    hourly_rate?: true
    session_cost?: true
    status?: true
    meeting_url?: true
    notes?: true
    materials_url?: true
    created_at?: true
    canceled_at?: true
    cancellation_reason?: true
    cancellation_fee?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    session_id: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date
    end_time: Date
    duration_minutes: number | null
    hourly_rate: Decimal
    session_cost: Decimal | null
    status: string
    meeting_url: string | null
    notes: string | null
    materials_url: string | null
    created_at: Date | null
    canceled_at: Date | null
    cancellation_reason: string | null
    cancellation_fee: Decimal | null
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    tutor_id?: boolean
    student_id?: boolean
    subject_id?: boolean
    start_time?: boolean
    end_time?: boolean
    duration_minutes?: boolean
    hourly_rate?: boolean
    session_cost?: boolean
    status?: boolean
    meeting_url?: boolean
    notes?: boolean
    materials_url?: boolean
    created_at?: boolean
    canceled_at?: boolean
    cancellation_reason?: boolean
    cancellation_fee?: boolean
    payments?: boolean | sessions$paymentsArgs<ExtArgs>
    session_notes?: boolean | sessions$session_notesArgs<ExtArgs>
    session_ratings?: boolean | sessions$session_ratingsArgs<ExtArgs>
    session_resources?: boolean | sessions$session_resourcesArgs<ExtArgs>
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>



  export type sessionsSelectScalar = {
    session_id?: boolean
    tutor_id?: boolean
    student_id?: boolean
    subject_id?: boolean
    start_time?: boolean
    end_time?: boolean
    duration_minutes?: boolean
    hourly_rate?: boolean
    session_cost?: boolean
    status?: boolean
    meeting_url?: boolean
    notes?: boolean
    materials_url?: boolean
    created_at?: boolean
    canceled_at?: boolean
    cancellation_reason?: boolean
    cancellation_fee?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"session_id" | "tutor_id" | "student_id" | "subject_id" | "start_time" | "end_time" | "duration_minutes" | "hourly_rate" | "session_cost" | "status" | "meeting_url" | "notes" | "materials_url" | "created_at" | "canceled_at" | "cancellation_reason" | "cancellation_fee", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | sessions$paymentsArgs<ExtArgs>
    session_notes?: boolean | sessions$session_notesArgs<ExtArgs>
    session_ratings?: boolean | sessions$session_ratingsArgs<ExtArgs>
    session_resources?: boolean | sessions$session_resourcesArgs<ExtArgs>
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      session_notes: Prisma.$session_notesPayload<ExtArgs>[]
      session_ratings: Prisma.$session_ratingsPayload<ExtArgs> | null
      session_resources: Prisma.$session_resourcesPayload<ExtArgs>[]
      tutors: Prisma.$tutorsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      session_id: number
      tutor_id: number
      student_id: number
      subject_id: number
      start_time: Date
      end_time: Date
      duration_minutes: number | null
      hourly_rate: Prisma.Decimal
      session_cost: Prisma.Decimal | null
      status: string
      meeting_url: string | null
      notes: string | null
      materials_url: string | null
      created_at: Date | null
      canceled_at: Date | null
      cancellation_reason: string | null
      cancellation_fee: Prisma.Decimal | null
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `session_id`
     * const sessionsWithSession_idOnly = await prisma.sessions.findMany({ select: { session_id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends sessions$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, sessions$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_notes<T extends sessions$session_notesArgs<ExtArgs> = {}>(args?: Subset<T, sessions$session_notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_ratings<T extends sessions$session_ratingsArgs<ExtArgs> = {}>(args?: Subset<T, sessions$session_ratingsArgs<ExtArgs>>): Prisma__session_ratingsClient<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    session_resources<T extends sessions$session_resourcesArgs<ExtArgs> = {}>(args?: Subset<T, sessions$session_resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutors<T extends tutorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tutorsDefaultArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly session_id: FieldRef<"sessions", 'Int'>
    readonly tutor_id: FieldRef<"sessions", 'Int'>
    readonly student_id: FieldRef<"sessions", 'Int'>
    readonly subject_id: FieldRef<"sessions", 'Int'>
    readonly start_time: FieldRef<"sessions", 'DateTime'>
    readonly end_time: FieldRef<"sessions", 'DateTime'>
    readonly duration_minutes: FieldRef<"sessions", 'Int'>
    readonly hourly_rate: FieldRef<"sessions", 'Decimal'>
    readonly session_cost: FieldRef<"sessions", 'Decimal'>
    readonly status: FieldRef<"sessions", 'String'>
    readonly meeting_url: FieldRef<"sessions", 'String'>
    readonly notes: FieldRef<"sessions", 'String'>
    readonly materials_url: FieldRef<"sessions", 'String'>
    readonly created_at: FieldRef<"sessions", 'DateTime'>
    readonly canceled_at: FieldRef<"sessions", 'DateTime'>
    readonly cancellation_reason: FieldRef<"sessions", 'String'>
    readonly cancellation_fee: FieldRef<"sessions", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions.payments
   */
  export type sessions$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * sessions.session_notes
   */
  export type sessions$session_notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    where?: session_notesWhereInput
    orderBy?: session_notesOrderByWithRelationInput | session_notesOrderByWithRelationInput[]
    cursor?: session_notesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_notesScalarFieldEnum | Session_notesScalarFieldEnum[]
  }

  /**
   * sessions.session_ratings
   */
  export type sessions$session_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    where?: session_ratingsWhereInput
  }

  /**
   * sessions.session_resources
   */
  export type sessions$session_resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_resources
     */
    select?: session_resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_resources
     */
    omit?: session_resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_resourcesInclude<ExtArgs> | null
    where?: session_resourcesWhereInput
    orderBy?: session_resourcesOrderByWithRelationInput | session_resourcesOrderByWithRelationInput[]
    cursor?: session_resourcesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_resourcesScalarFieldEnum | Session_resourcesScalarFieldEnum[]
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Model student_subject_interests
   */

  export type AggregateStudent_subject_interests = {
    _count: Student_subject_interestsCountAggregateOutputType | null
    _avg: Student_subject_interestsAvgAggregateOutputType | null
    _sum: Student_subject_interestsSumAggregateOutputType | null
    _min: Student_subject_interestsMinAggregateOutputType | null
    _max: Student_subject_interestsMaxAggregateOutputType | null
  }

  export type Student_subject_interestsAvgAggregateOutputType = {
    interest_id: number | null
    student_id: number | null
    subject_id: number | null
  }

  export type Student_subject_interestsSumAggregateOutputType = {
    interest_id: number | null
    student_id: number | null
    subject_id: number | null
  }

  export type Student_subject_interestsMinAggregateOutputType = {
    interest_id: number | null
    student_id: number | null
    subject_id: number | null
    interest_level: string | null
  }

  export type Student_subject_interestsMaxAggregateOutputType = {
    interest_id: number | null
    student_id: number | null
    subject_id: number | null
    interest_level: string | null
  }

  export type Student_subject_interestsCountAggregateOutputType = {
    interest_id: number
    student_id: number
    subject_id: number
    interest_level: number
    _all: number
  }


  export type Student_subject_interestsAvgAggregateInputType = {
    interest_id?: true
    student_id?: true
    subject_id?: true
  }

  export type Student_subject_interestsSumAggregateInputType = {
    interest_id?: true
    student_id?: true
    subject_id?: true
  }

  export type Student_subject_interestsMinAggregateInputType = {
    interest_id?: true
    student_id?: true
    subject_id?: true
    interest_level?: true
  }

  export type Student_subject_interestsMaxAggregateInputType = {
    interest_id?: true
    student_id?: true
    subject_id?: true
    interest_level?: true
  }

  export type Student_subject_interestsCountAggregateInputType = {
    interest_id?: true
    student_id?: true
    subject_id?: true
    interest_level?: true
    _all?: true
  }

  export type Student_subject_interestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_subject_interests to aggregate.
     */
    where?: student_subject_interestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_subject_interests to fetch.
     */
    orderBy?: student_subject_interestsOrderByWithRelationInput | student_subject_interestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_subject_interestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_subject_interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_subject_interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_subject_interests
    **/
    _count?: true | Student_subject_interestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_subject_interestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_subject_interestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_subject_interestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_subject_interestsMaxAggregateInputType
  }

  export type GetStudent_subject_interestsAggregateType<T extends Student_subject_interestsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_subject_interests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_subject_interests[P]>
      : GetScalarType<T[P], AggregateStudent_subject_interests[P]>
  }




  export type student_subject_interestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_subject_interestsWhereInput
    orderBy?: student_subject_interestsOrderByWithAggregationInput | student_subject_interestsOrderByWithAggregationInput[]
    by: Student_subject_interestsScalarFieldEnum[] | Student_subject_interestsScalarFieldEnum
    having?: student_subject_interestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_subject_interestsCountAggregateInputType | true
    _avg?: Student_subject_interestsAvgAggregateInputType
    _sum?: Student_subject_interestsSumAggregateInputType
    _min?: Student_subject_interestsMinAggregateInputType
    _max?: Student_subject_interestsMaxAggregateInputType
  }

  export type Student_subject_interestsGroupByOutputType = {
    interest_id: number
    student_id: number
    subject_id: number
    interest_level: string | null
    _count: Student_subject_interestsCountAggregateOutputType | null
    _avg: Student_subject_interestsAvgAggregateOutputType | null
    _sum: Student_subject_interestsSumAggregateOutputType | null
    _min: Student_subject_interestsMinAggregateOutputType | null
    _max: Student_subject_interestsMaxAggregateOutputType | null
  }

  type GetStudent_subject_interestsGroupByPayload<T extends student_subject_interestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_subject_interestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_subject_interestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_subject_interestsGroupByOutputType[P]>
            : GetScalarType<T[P], Student_subject_interestsGroupByOutputType[P]>
        }
      >
    >


  export type student_subject_interestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interest_id?: boolean
    student_id?: boolean
    subject_id?: boolean
    interest_level?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_subject_interests"]>



  export type student_subject_interestsSelectScalar = {
    interest_id?: boolean
    student_id?: boolean
    subject_id?: boolean
    interest_level?: boolean
  }

  export type student_subject_interestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"interest_id" | "student_id" | "subject_id" | "interest_level", ExtArgs["result"]["student_subject_interests"]>
  export type student_subject_interestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }

  export type $student_subject_interestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_subject_interests"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      interest_id: number
      student_id: number
      subject_id: number
      interest_level: string | null
    }, ExtArgs["result"]["student_subject_interests"]>
    composites: {}
  }

  type student_subject_interestsGetPayload<S extends boolean | null | undefined | student_subject_interestsDefaultArgs> = $Result.GetResult<Prisma.$student_subject_interestsPayload, S>

  type student_subject_interestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_subject_interestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Student_subject_interestsCountAggregateInputType | true
    }

  export interface student_subject_interestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_subject_interests'], meta: { name: 'student_subject_interests' } }
    /**
     * Find zero or one Student_subject_interests that matches the filter.
     * @param {student_subject_interestsFindUniqueArgs} args - Arguments to find a Student_subject_interests
     * @example
     * // Get one Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_subject_interestsFindUniqueArgs>(args: SelectSubset<T, student_subject_interestsFindUniqueArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student_subject_interests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_subject_interestsFindUniqueOrThrowArgs} args - Arguments to find a Student_subject_interests
     * @example
     * // Get one Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_subject_interestsFindUniqueOrThrowArgs>(args: SelectSubset<T, student_subject_interestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_subject_interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_subject_interestsFindFirstArgs} args - Arguments to find a Student_subject_interests
     * @example
     * // Get one Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_subject_interestsFindFirstArgs>(args?: SelectSubset<T, student_subject_interestsFindFirstArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_subject_interests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_subject_interestsFindFirstOrThrowArgs} args - Arguments to find a Student_subject_interests
     * @example
     * // Get one Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_subject_interestsFindFirstOrThrowArgs>(args?: SelectSubset<T, student_subject_interestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Student_subject_interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_subject_interestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.findMany()
     * 
     * // Get first 10 Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.findMany({ take: 10 })
     * 
     * // Only select the `interest_id`
     * const student_subject_interestsWithInterest_idOnly = await prisma.student_subject_interests.findMany({ select: { interest_id: true } })
     * 
     */
    findMany<T extends student_subject_interestsFindManyArgs>(args?: SelectSubset<T, student_subject_interestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student_subject_interests.
     * @param {student_subject_interestsCreateArgs} args - Arguments to create a Student_subject_interests.
     * @example
     * // Create one Student_subject_interests
     * const Student_subject_interests = await prisma.student_subject_interests.create({
     *   data: {
     *     // ... data to create a Student_subject_interests
     *   }
     * })
     * 
     */
    create<T extends student_subject_interestsCreateArgs>(args: SelectSubset<T, student_subject_interestsCreateArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Student_subject_interests.
     * @param {student_subject_interestsCreateManyArgs} args - Arguments to create many Student_subject_interests.
     * @example
     * // Create many Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_subject_interestsCreateManyArgs>(args?: SelectSubset<T, student_subject_interestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_subject_interests.
     * @param {student_subject_interestsDeleteArgs} args - Arguments to delete one Student_subject_interests.
     * @example
     * // Delete one Student_subject_interests
     * const Student_subject_interests = await prisma.student_subject_interests.delete({
     *   where: {
     *     // ... filter to delete one Student_subject_interests
     *   }
     * })
     * 
     */
    delete<T extends student_subject_interestsDeleteArgs>(args: SelectSubset<T, student_subject_interestsDeleteArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student_subject_interests.
     * @param {student_subject_interestsUpdateArgs} args - Arguments to update one Student_subject_interests.
     * @example
     * // Update one Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_subject_interestsUpdateArgs>(args: SelectSubset<T, student_subject_interestsUpdateArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Student_subject_interests.
     * @param {student_subject_interestsDeleteManyArgs} args - Arguments to filter Student_subject_interests to delete.
     * @example
     * // Delete a few Student_subject_interests
     * const { count } = await prisma.student_subject_interests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_subject_interestsDeleteManyArgs>(args?: SelectSubset<T, student_subject_interestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_subject_interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_subject_interestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_subject_interestsUpdateManyArgs>(args: SelectSubset<T, student_subject_interestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_subject_interests.
     * @param {student_subject_interestsUpsertArgs} args - Arguments to update or create a Student_subject_interests.
     * @example
     * // Update or create a Student_subject_interests
     * const student_subject_interests = await prisma.student_subject_interests.upsert({
     *   create: {
     *     // ... data to create a Student_subject_interests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_subject_interests we want to update
     *   }
     * })
     */
    upsert<T extends student_subject_interestsUpsertArgs>(args: SelectSubset<T, student_subject_interestsUpsertArgs<ExtArgs>>): Prisma__student_subject_interestsClient<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Student_subject_interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_subject_interestsCountArgs} args - Arguments to filter Student_subject_interests to count.
     * @example
     * // Count the number of Student_subject_interests
     * const count = await prisma.student_subject_interests.count({
     *   where: {
     *     // ... the filter for the Student_subject_interests we want to count
     *   }
     * })
    **/
    count<T extends student_subject_interestsCountArgs>(
      args?: Subset<T, student_subject_interestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_subject_interestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_subject_interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_subject_interestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_subject_interestsAggregateArgs>(args: Subset<T, Student_subject_interestsAggregateArgs>): Prisma.PrismaPromise<GetStudent_subject_interestsAggregateType<T>>

    /**
     * Group by Student_subject_interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_subject_interestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_subject_interestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_subject_interestsGroupByArgs['orderBy'] }
        : { orderBy?: student_subject_interestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_subject_interestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_subject_interestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_subject_interests model
   */
  readonly fields: student_subject_interestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_subject_interests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_subject_interestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_subject_interests model
   */
  interface student_subject_interestsFieldRefs {
    readonly interest_id: FieldRef<"student_subject_interests", 'Int'>
    readonly student_id: FieldRef<"student_subject_interests", 'Int'>
    readonly subject_id: FieldRef<"student_subject_interests", 'Int'>
    readonly interest_level: FieldRef<"student_subject_interests", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student_subject_interests findUnique
   */
  export type student_subject_interestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * Filter, which student_subject_interests to fetch.
     */
    where: student_subject_interestsWhereUniqueInput
  }

  /**
   * student_subject_interests findUniqueOrThrow
   */
  export type student_subject_interestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * Filter, which student_subject_interests to fetch.
     */
    where: student_subject_interestsWhereUniqueInput
  }

  /**
   * student_subject_interests findFirst
   */
  export type student_subject_interestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * Filter, which student_subject_interests to fetch.
     */
    where?: student_subject_interestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_subject_interests to fetch.
     */
    orderBy?: student_subject_interestsOrderByWithRelationInput | student_subject_interestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_subject_interests.
     */
    cursor?: student_subject_interestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_subject_interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_subject_interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_subject_interests.
     */
    distinct?: Student_subject_interestsScalarFieldEnum | Student_subject_interestsScalarFieldEnum[]
  }

  /**
   * student_subject_interests findFirstOrThrow
   */
  export type student_subject_interestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * Filter, which student_subject_interests to fetch.
     */
    where?: student_subject_interestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_subject_interests to fetch.
     */
    orderBy?: student_subject_interestsOrderByWithRelationInput | student_subject_interestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_subject_interests.
     */
    cursor?: student_subject_interestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_subject_interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_subject_interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_subject_interests.
     */
    distinct?: Student_subject_interestsScalarFieldEnum | Student_subject_interestsScalarFieldEnum[]
  }

  /**
   * student_subject_interests findMany
   */
  export type student_subject_interestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * Filter, which student_subject_interests to fetch.
     */
    where?: student_subject_interestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_subject_interests to fetch.
     */
    orderBy?: student_subject_interestsOrderByWithRelationInput | student_subject_interestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_subject_interests.
     */
    cursor?: student_subject_interestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_subject_interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_subject_interests.
     */
    skip?: number
    distinct?: Student_subject_interestsScalarFieldEnum | Student_subject_interestsScalarFieldEnum[]
  }

  /**
   * student_subject_interests create
   */
  export type student_subject_interestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * The data needed to create a student_subject_interests.
     */
    data: XOR<student_subject_interestsCreateInput, student_subject_interestsUncheckedCreateInput>
  }

  /**
   * student_subject_interests createMany
   */
  export type student_subject_interestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_subject_interests.
     */
    data: student_subject_interestsCreateManyInput | student_subject_interestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_subject_interests update
   */
  export type student_subject_interestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * The data needed to update a student_subject_interests.
     */
    data: XOR<student_subject_interestsUpdateInput, student_subject_interestsUncheckedUpdateInput>
    /**
     * Choose, which student_subject_interests to update.
     */
    where: student_subject_interestsWhereUniqueInput
  }

  /**
   * student_subject_interests updateMany
   */
  export type student_subject_interestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_subject_interests.
     */
    data: XOR<student_subject_interestsUpdateManyMutationInput, student_subject_interestsUncheckedUpdateManyInput>
    /**
     * Filter which student_subject_interests to update
     */
    where?: student_subject_interestsWhereInput
    /**
     * Limit how many student_subject_interests to update.
     */
    limit?: number
  }

  /**
   * student_subject_interests upsert
   */
  export type student_subject_interestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * The filter to search for the student_subject_interests to update in case it exists.
     */
    where: student_subject_interestsWhereUniqueInput
    /**
     * In case the student_subject_interests found by the `where` argument doesn't exist, create a new student_subject_interests with this data.
     */
    create: XOR<student_subject_interestsCreateInput, student_subject_interestsUncheckedCreateInput>
    /**
     * In case the student_subject_interests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_subject_interestsUpdateInput, student_subject_interestsUncheckedUpdateInput>
  }

  /**
   * student_subject_interests delete
   */
  export type student_subject_interestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    /**
     * Filter which student_subject_interests to delete.
     */
    where: student_subject_interestsWhereUniqueInput
  }

  /**
   * student_subject_interests deleteMany
   */
  export type student_subject_interestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_subject_interests to delete
     */
    where?: student_subject_interestsWhereInput
    /**
     * Limit how many student_subject_interests to delete.
     */
    limit?: number
  }

  /**
   * student_subject_interests without action
   */
  export type student_subject_interestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
  }


  /**
   * Model students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    student_id: number | null
    user_id: number | null
  }

  export type StudentsSumAggregateOutputType = {
    student_id: number | null
    user_id: number | null
  }

  export type StudentsMinAggregateOutputType = {
    student_id: number | null
    user_id: number | null
    education_level: string | null
    grade_year: string | null
    parent_guardian_name: string | null
    parent_guardian_email: string | null
    parent_guardian_phone: string | null
    special_needs: string | null
    learning_preferences: string | null
  }

  export type StudentsMaxAggregateOutputType = {
    student_id: number | null
    user_id: number | null
    education_level: string | null
    grade_year: string | null
    parent_guardian_name: string | null
    parent_guardian_email: string | null
    parent_guardian_phone: string | null
    special_needs: string | null
    learning_preferences: string | null
  }

  export type StudentsCountAggregateOutputType = {
    student_id: number
    user_id: number
    education_level: number
    grade_year: number
    parent_guardian_name: number
    parent_guardian_email: number
    parent_guardian_phone: number
    special_needs: number
    learning_preferences: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    student_id?: true
    user_id?: true
  }

  export type StudentsSumAggregateInputType = {
    student_id?: true
    user_id?: true
  }

  export type StudentsMinAggregateInputType = {
    student_id?: true
    user_id?: true
    education_level?: true
    grade_year?: true
    parent_guardian_name?: true
    parent_guardian_email?: true
    parent_guardian_phone?: true
    special_needs?: true
    learning_preferences?: true
  }

  export type StudentsMaxAggregateInputType = {
    student_id?: true
    user_id?: true
    education_level?: true
    grade_year?: true
    parent_guardian_name?: true
    parent_guardian_email?: true
    parent_guardian_phone?: true
    special_needs?: true
    learning_preferences?: true
  }

  export type StudentsCountAggregateInputType = {
    student_id?: true
    user_id?: true
    education_level?: true
    grade_year?: true
    parent_guardian_name?: true
    parent_guardian_email?: true
    parent_guardian_phone?: true
    special_needs?: true
    learning_preferences?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to aggregate.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type studentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithAggregationInput | studentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: studentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    student_id: number
    user_id: number
    education_level: string | null
    grade_year: string | null
    parent_guardian_name: string | null
    parent_guardian_email: string | null
    parent_guardian_phone: string | null
    special_needs: string | null
    learning_preferences: string | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends studentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type studentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    user_id?: boolean
    education_level?: boolean
    grade_year?: boolean
    parent_guardian_name?: boolean
    parent_guardian_email?: boolean
    parent_guardian_phone?: boolean
    special_needs?: boolean
    learning_preferences?: boolean
    group_session_participants?: boolean | students$group_session_participantsArgs<ExtArgs>
    session_ratings?: boolean | students$session_ratingsArgs<ExtArgs>
    sessions?: boolean | students$sessionsArgs<ExtArgs>
    student_subject_interests?: boolean | students$student_subject_interestsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    subscriptions?: boolean | students$subscriptionsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>



  export type studentsSelectScalar = {
    student_id?: boolean
    user_id?: boolean
    education_level?: boolean
    grade_year?: boolean
    parent_guardian_name?: boolean
    parent_guardian_email?: boolean
    parent_guardian_phone?: boolean
    special_needs?: boolean
    learning_preferences?: boolean
  }

  export type studentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_id" | "user_id" | "education_level" | "grade_year" | "parent_guardian_name" | "parent_guardian_email" | "parent_guardian_phone" | "special_needs" | "learning_preferences", ExtArgs["result"]["students"]>
  export type studentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_session_participants?: boolean | students$group_session_participantsArgs<ExtArgs>
    session_ratings?: boolean | students$session_ratingsArgs<ExtArgs>
    sessions?: boolean | students$sessionsArgs<ExtArgs>
    student_subject_interests?: boolean | students$student_subject_interestsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    subscriptions?: boolean | students$subscriptionsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $studentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students"
    objects: {
      group_session_participants: Prisma.$group_session_participantsPayload<ExtArgs>[]
      session_ratings: Prisma.$session_ratingsPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      student_subject_interests: Prisma.$student_subject_interestsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: number
      user_id: number
      education_level: string | null
      grade_year: string | null
      parent_guardian_name: string | null
      parent_guardian_email: string | null
      parent_guardian_phone: string | null
      special_needs: string | null
      learning_preferences: string | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type studentsGetPayload<S extends boolean | null | undefined | studentsDefaultArgs> = $Result.GetResult<Prisma.$studentsPayload, S>

  type studentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface studentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students'], meta: { name: 'students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {studentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentsFindUniqueArgs>(args: SelectSubset<T, studentsFindUniqueArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentsFindFirstArgs>(args?: SelectSubset<T, studentsFindFirstArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const studentsWithStudent_idOnly = await prisma.students.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends studentsFindManyArgs>(args?: SelectSubset<T, studentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {studentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends studentsCreateArgs>(args: SelectSubset<T, studentsCreateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentsCreateManyArgs>(args?: SelectSubset<T, studentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Students.
     * @param {studentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends studentsDeleteArgs>(args: SelectSubset<T, studentsDeleteArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {studentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentsUpdateArgs>(args: SelectSubset<T, studentsUpdateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentsDeleteManyArgs>(args?: SelectSubset<T, studentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentsUpdateManyArgs>(args: SelectSubset<T, studentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Students.
     * @param {studentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends studentsUpsertArgs>(args: SelectSubset<T, studentsUpsertArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentsCountArgs>(
      args?: Subset<T, studentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsGroupByArgs['orderBy'] }
        : { orderBy?: studentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students model
   */
  readonly fields: studentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group_session_participants<T extends students$group_session_participantsArgs<ExtArgs> = {}>(args?: Subset<T, students$group_session_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_session_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_ratings<T extends students$session_ratingsArgs<ExtArgs> = {}>(args?: Subset<T, students$session_ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends students$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, students$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_subject_interests<T extends students$student_subject_interestsArgs<ExtArgs> = {}>(args?: Subset<T, students$student_subject_interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends students$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, students$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students model
   */
  interface studentsFieldRefs {
    readonly student_id: FieldRef<"students", 'Int'>
    readonly user_id: FieldRef<"students", 'Int'>
    readonly education_level: FieldRef<"students", 'String'>
    readonly grade_year: FieldRef<"students", 'String'>
    readonly parent_guardian_name: FieldRef<"students", 'String'>
    readonly parent_guardian_email: FieldRef<"students", 'String'>
    readonly parent_guardian_phone: FieldRef<"students", 'String'>
    readonly special_needs: FieldRef<"students", 'String'>
    readonly learning_preferences: FieldRef<"students", 'String'>
  }
    

  // Custom InputTypes
  /**
   * students findUnique
   */
  export type studentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findUniqueOrThrow
   */
  export type studentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findFirst
   */
  export type studentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findFirstOrThrow
   */
  export type studentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findMany
   */
  export type studentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students create
   */
  export type studentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students.
     */
    data: XOR<studentsCreateInput, studentsUncheckedCreateInput>
  }

  /**
   * students createMany
   */
  export type studentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students update
   */
  export type studentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students.
     */
    data: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
    /**
     * Choose, which students to update.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students updateMany
   */
  export type studentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * students upsert
   */
  export type studentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students to update in case it exists.
     */
    where: studentsWhereUniqueInput
    /**
     * In case the students found by the `where` argument doesn't exist, create a new students with this data.
     */
    create: XOR<studentsCreateInput, studentsUncheckedCreateInput>
    /**
     * In case the students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
  }

  /**
   * students delete
   */
  export type studentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter which students to delete.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students deleteMany
   */
  export type studentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * students.group_session_participants
   */
  export type students$group_session_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_session_participants
     */
    select?: group_session_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_session_participants
     */
    omit?: group_session_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_session_participantsInclude<ExtArgs> | null
    where?: group_session_participantsWhereInput
    orderBy?: group_session_participantsOrderByWithRelationInput | group_session_participantsOrderByWithRelationInput[]
    cursor?: group_session_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Group_session_participantsScalarFieldEnum | Group_session_participantsScalarFieldEnum[]
  }

  /**
   * students.session_ratings
   */
  export type students$session_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    where?: session_ratingsWhereInput
    orderBy?: session_ratingsOrderByWithRelationInput | session_ratingsOrderByWithRelationInput[]
    cursor?: session_ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_ratingsScalarFieldEnum | Session_ratingsScalarFieldEnum[]
  }

  /**
   * students.sessions
   */
  export type students$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * students.student_subject_interests
   */
  export type students$student_subject_interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    where?: student_subject_interestsWhereInput
    orderBy?: student_subject_interestsOrderByWithRelationInput | student_subject_interestsOrderByWithRelationInput[]
    cursor?: student_subject_interestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_subject_interestsScalarFieldEnum | Student_subject_interestsScalarFieldEnum[]
  }

  /**
   * students.subscriptions
   */
  export type students$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    cursor?: subscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * students without action
   */
  export type studentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
  }


  /**
   * Model subject_categories
   */

  export type AggregateSubject_categories = {
    _count: Subject_categoriesCountAggregateOutputType | null
    _avg: Subject_categoriesAvgAggregateOutputType | null
    _sum: Subject_categoriesSumAggregateOutputType | null
    _min: Subject_categoriesMinAggregateOutputType | null
    _max: Subject_categoriesMaxAggregateOutputType | null
  }

  export type Subject_categoriesAvgAggregateOutputType = {
    category_id: number | null
  }

  export type Subject_categoriesSumAggregateOutputType = {
    category_id: number | null
  }

  export type Subject_categoriesMinAggregateOutputType = {
    category_id: number | null
    name: string | null
    description: string | null
  }

  export type Subject_categoriesMaxAggregateOutputType = {
    category_id: number | null
    name: string | null
    description: string | null
  }

  export type Subject_categoriesCountAggregateOutputType = {
    category_id: number
    name: number
    description: number
    _all: number
  }


  export type Subject_categoriesAvgAggregateInputType = {
    category_id?: true
  }

  export type Subject_categoriesSumAggregateInputType = {
    category_id?: true
  }

  export type Subject_categoriesMinAggregateInputType = {
    category_id?: true
    name?: true
    description?: true
  }

  export type Subject_categoriesMaxAggregateInputType = {
    category_id?: true
    name?: true
    description?: true
  }

  export type Subject_categoriesCountAggregateInputType = {
    category_id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Subject_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject_categories to aggregate.
     */
    where?: subject_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_categories to fetch.
     */
    orderBy?: subject_categoriesOrderByWithRelationInput | subject_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subject_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subject_categories
    **/
    _count?: true | Subject_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subject_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subject_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subject_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subject_categoriesMaxAggregateInputType
  }

  export type GetSubject_categoriesAggregateType<T extends Subject_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject_categories[P]>
      : GetScalarType<T[P], AggregateSubject_categories[P]>
  }




  export type subject_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_categoriesWhereInput
    orderBy?: subject_categoriesOrderByWithAggregationInput | subject_categoriesOrderByWithAggregationInput[]
    by: Subject_categoriesScalarFieldEnum[] | Subject_categoriesScalarFieldEnum
    having?: subject_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subject_categoriesCountAggregateInputType | true
    _avg?: Subject_categoriesAvgAggregateInputType
    _sum?: Subject_categoriesSumAggregateInputType
    _min?: Subject_categoriesMinAggregateInputType
    _max?: Subject_categoriesMaxAggregateInputType
  }

  export type Subject_categoriesGroupByOutputType = {
    category_id: number
    name: string
    description: string | null
    _count: Subject_categoriesCountAggregateOutputType | null
    _avg: Subject_categoriesAvgAggregateOutputType | null
    _sum: Subject_categoriesSumAggregateOutputType | null
    _min: Subject_categoriesMinAggregateOutputType | null
    _max: Subject_categoriesMaxAggregateOutputType | null
  }

  type GetSubject_categoriesGroupByPayload<T extends subject_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Subject_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subject_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subject_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Subject_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type subject_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    name?: boolean
    description?: boolean
    subjects?: boolean | subject_categories$subjectsArgs<ExtArgs>
    _count?: boolean | Subject_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject_categories"]>



  export type subject_categoriesSelectScalar = {
    category_id?: boolean
    name?: boolean
    description?: boolean
  }

  export type subject_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"category_id" | "name" | "description", ExtArgs["result"]["subject_categories"]>
  export type subject_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | subject_categories$subjectsArgs<ExtArgs>
    _count?: boolean | Subject_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subject_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subject_categories"
    objects: {
      subjects: Prisma.$subjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      category_id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["subject_categories"]>
    composites: {}
  }

  type subject_categoriesGetPayload<S extends boolean | null | undefined | subject_categoriesDefaultArgs> = $Result.GetResult<Prisma.$subject_categoriesPayload, S>

  type subject_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subject_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Subject_categoriesCountAggregateInputType | true
    }

  export interface subject_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subject_categories'], meta: { name: 'subject_categories' } }
    /**
     * Find zero or one Subject_categories that matches the filter.
     * @param {subject_categoriesFindUniqueArgs} args - Arguments to find a Subject_categories
     * @example
     * // Get one Subject_categories
     * const subject_categories = await prisma.subject_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subject_categoriesFindUniqueArgs>(args: SelectSubset<T, subject_categoriesFindUniqueArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subject_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Subject_categories
     * @example
     * // Get one Subject_categories
     * const subject_categories = await prisma.subject_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subject_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, subject_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_categoriesFindFirstArgs} args - Arguments to find a Subject_categories
     * @example
     * // Get one Subject_categories
     * const subject_categories = await prisma.subject_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subject_categoriesFindFirstArgs>(args?: SelectSubset<T, subject_categoriesFindFirstArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_categoriesFindFirstOrThrowArgs} args - Arguments to find a Subject_categories
     * @example
     * // Get one Subject_categories
     * const subject_categories = await prisma.subject_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subject_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, subject_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subject_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subject_categories
     * const subject_categories = await prisma.subject_categories.findMany()
     * 
     * // Get first 10 Subject_categories
     * const subject_categories = await prisma.subject_categories.findMany({ take: 10 })
     * 
     * // Only select the `category_id`
     * const subject_categoriesWithCategory_idOnly = await prisma.subject_categories.findMany({ select: { category_id: true } })
     * 
     */
    findMany<T extends subject_categoriesFindManyArgs>(args?: SelectSubset<T, subject_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject_categories.
     * @param {subject_categoriesCreateArgs} args - Arguments to create a Subject_categories.
     * @example
     * // Create one Subject_categories
     * const Subject_categories = await prisma.subject_categories.create({
     *   data: {
     *     // ... data to create a Subject_categories
     *   }
     * })
     * 
     */
    create<T extends subject_categoriesCreateArgs>(args: SelectSubset<T, subject_categoriesCreateArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subject_categories.
     * @param {subject_categoriesCreateManyArgs} args - Arguments to create many Subject_categories.
     * @example
     * // Create many Subject_categories
     * const subject_categories = await prisma.subject_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subject_categoriesCreateManyArgs>(args?: SelectSubset<T, subject_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject_categories.
     * @param {subject_categoriesDeleteArgs} args - Arguments to delete one Subject_categories.
     * @example
     * // Delete one Subject_categories
     * const Subject_categories = await prisma.subject_categories.delete({
     *   where: {
     *     // ... filter to delete one Subject_categories
     *   }
     * })
     * 
     */
    delete<T extends subject_categoriesDeleteArgs>(args: SelectSubset<T, subject_categoriesDeleteArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject_categories.
     * @param {subject_categoriesUpdateArgs} args - Arguments to update one Subject_categories.
     * @example
     * // Update one Subject_categories
     * const subject_categories = await prisma.subject_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subject_categoriesUpdateArgs>(args: SelectSubset<T, subject_categoriesUpdateArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subject_categories.
     * @param {subject_categoriesDeleteManyArgs} args - Arguments to filter Subject_categories to delete.
     * @example
     * // Delete a few Subject_categories
     * const { count } = await prisma.subject_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subject_categoriesDeleteManyArgs>(args?: SelectSubset<T, subject_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subject_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subject_categories
     * const subject_categories = await prisma.subject_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subject_categoriesUpdateManyArgs>(args: SelectSubset<T, subject_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject_categories.
     * @param {subject_categoriesUpsertArgs} args - Arguments to update or create a Subject_categories.
     * @example
     * // Update or create a Subject_categories
     * const subject_categories = await prisma.subject_categories.upsert({
     *   create: {
     *     // ... data to create a Subject_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject_categories we want to update
     *   }
     * })
     */
    upsert<T extends subject_categoriesUpsertArgs>(args: SelectSubset<T, subject_categoriesUpsertArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subject_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_categoriesCountArgs} args - Arguments to filter Subject_categories to count.
     * @example
     * // Count the number of Subject_categories
     * const count = await prisma.subject_categories.count({
     *   where: {
     *     // ... the filter for the Subject_categories we want to count
     *   }
     * })
    **/
    count<T extends subject_categoriesCountArgs>(
      args?: Subset<T, subject_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subject_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subject_categoriesAggregateArgs>(args: Subset<T, Subject_categoriesAggregateArgs>): Prisma.PrismaPromise<GetSubject_categoriesAggregateType<T>>

    /**
     * Group by Subject_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subject_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subject_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: subject_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subject_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubject_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subject_categories model
   */
  readonly fields: subject_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subject_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subjects<T extends subject_categories$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, subject_categories$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subject_categories model
   */
  interface subject_categoriesFieldRefs {
    readonly category_id: FieldRef<"subject_categories", 'Int'>
    readonly name: FieldRef<"subject_categories", 'String'>
    readonly description: FieldRef<"subject_categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subject_categories findUnique
   */
  export type subject_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which subject_categories to fetch.
     */
    where: subject_categoriesWhereUniqueInput
  }

  /**
   * subject_categories findUniqueOrThrow
   */
  export type subject_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which subject_categories to fetch.
     */
    where: subject_categoriesWhereUniqueInput
  }

  /**
   * subject_categories findFirst
   */
  export type subject_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which subject_categories to fetch.
     */
    where?: subject_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_categories to fetch.
     */
    orderBy?: subject_categoriesOrderByWithRelationInput | subject_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_categories.
     */
    cursor?: subject_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_categories.
     */
    distinct?: Subject_categoriesScalarFieldEnum | Subject_categoriesScalarFieldEnum[]
  }

  /**
   * subject_categories findFirstOrThrow
   */
  export type subject_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which subject_categories to fetch.
     */
    where?: subject_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_categories to fetch.
     */
    orderBy?: subject_categoriesOrderByWithRelationInput | subject_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_categories.
     */
    cursor?: subject_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_categories.
     */
    distinct?: Subject_categoriesScalarFieldEnum | Subject_categoriesScalarFieldEnum[]
  }

  /**
   * subject_categories findMany
   */
  export type subject_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which subject_categories to fetch.
     */
    where?: subject_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_categories to fetch.
     */
    orderBy?: subject_categoriesOrderByWithRelationInput | subject_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subject_categories.
     */
    cursor?: subject_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_categories.
     */
    skip?: number
    distinct?: Subject_categoriesScalarFieldEnum | Subject_categoriesScalarFieldEnum[]
  }

  /**
   * subject_categories create
   */
  export type subject_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a subject_categories.
     */
    data: XOR<subject_categoriesCreateInput, subject_categoriesUncheckedCreateInput>
  }

  /**
   * subject_categories createMany
   */
  export type subject_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subject_categories.
     */
    data: subject_categoriesCreateManyInput | subject_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subject_categories update
   */
  export type subject_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a subject_categories.
     */
    data: XOR<subject_categoriesUpdateInput, subject_categoriesUncheckedUpdateInput>
    /**
     * Choose, which subject_categories to update.
     */
    where: subject_categoriesWhereUniqueInput
  }

  /**
   * subject_categories updateMany
   */
  export type subject_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subject_categories.
     */
    data: XOR<subject_categoriesUpdateManyMutationInput, subject_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which subject_categories to update
     */
    where?: subject_categoriesWhereInput
    /**
     * Limit how many subject_categories to update.
     */
    limit?: number
  }

  /**
   * subject_categories upsert
   */
  export type subject_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the subject_categories to update in case it exists.
     */
    where: subject_categoriesWhereUniqueInput
    /**
     * In case the subject_categories found by the `where` argument doesn't exist, create a new subject_categories with this data.
     */
    create: XOR<subject_categoriesCreateInput, subject_categoriesUncheckedCreateInput>
    /**
     * In case the subject_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subject_categoriesUpdateInput, subject_categoriesUncheckedUpdateInput>
  }

  /**
   * subject_categories delete
   */
  export type subject_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    /**
     * Filter which subject_categories to delete.
     */
    where: subject_categoriesWhereUniqueInput
  }

  /**
   * subject_categories deleteMany
   */
  export type subject_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject_categories to delete
     */
    where?: subject_categoriesWhereInput
    /**
     * Limit how many subject_categories to delete.
     */
    limit?: number
  }

  /**
   * subject_categories.subjects
   */
  export type subject_categories$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    where?: subjectsWhereInput
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    cursor?: subjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subject_categories without action
   */
  export type subject_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsAvgAggregateOutputType = {
    subject_id: number | null
    category_id: number | null
  }

  export type SubjectsSumAggregateOutputType = {
    subject_id: number | null
    category_id: number | null
  }

  export type SubjectsMinAggregateOutputType = {
    subject_id: number | null
    category_id: number | null
    name: string | null
    description: string | null
    difficulty_level: string | null
  }

  export type SubjectsMaxAggregateOutputType = {
    subject_id: number | null
    category_id: number | null
    name: string | null
    description: string | null
    difficulty_level: string | null
  }

  export type SubjectsCountAggregateOutputType = {
    subject_id: number
    category_id: number
    name: number
    description: number
    difficulty_level: number
    _all: number
  }


  export type SubjectsAvgAggregateInputType = {
    subject_id?: true
    category_id?: true
  }

  export type SubjectsSumAggregateInputType = {
    subject_id?: true
    category_id?: true
  }

  export type SubjectsMinAggregateInputType = {
    subject_id?: true
    category_id?: true
    name?: true
    description?: true
    difficulty_level?: true
  }

  export type SubjectsMaxAggregateInputType = {
    subject_id?: true
    category_id?: true
    name?: true
    description?: true
    difficulty_level?: true
  }

  export type SubjectsCountAggregateInputType = {
    subject_id?: true
    category_id?: true
    name?: true
    description?: true
    difficulty_level?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to aggregate.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectsWhereInput
    orderBy?: subjectsOrderByWithAggregationInput | subjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _avg?: SubjectsAvgAggregateInputType
    _sum?: SubjectsSumAggregateInputType
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    subject_id: number
    category_id: number | null
    name: string
    description: string | null
    difficulty_level: string | null
    _count: SubjectsCountAggregateOutputType | null
    _avg: SubjectsAvgAggregateOutputType | null
    _sum: SubjectsSumAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subject_id?: boolean
    category_id?: boolean
    name?: boolean
    description?: boolean
    difficulty_level?: boolean
    group_sessions?: boolean | subjects$group_sessionsArgs<ExtArgs>
    resources?: boolean | subjects$resourcesArgs<ExtArgs>
    sessions?: boolean | subjects$sessionsArgs<ExtArgs>
    student_subject_interests?: boolean | subjects$student_subject_interestsArgs<ExtArgs>
    subject_categories?: boolean | subjects$subject_categoriesArgs<ExtArgs>
    tutor_subjects?: boolean | subjects$tutor_subjectsArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>



  export type subjectsSelectScalar = {
    subject_id?: boolean
    category_id?: boolean
    name?: boolean
    description?: boolean
    difficulty_level?: boolean
  }

  export type subjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subject_id" | "category_id" | "name" | "description" | "difficulty_level", ExtArgs["result"]["subjects"]>
  export type subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_sessions?: boolean | subjects$group_sessionsArgs<ExtArgs>
    resources?: boolean | subjects$resourcesArgs<ExtArgs>
    sessions?: boolean | subjects$sessionsArgs<ExtArgs>
    student_subject_interests?: boolean | subjects$student_subject_interestsArgs<ExtArgs>
    subject_categories?: boolean | subjects$subject_categoriesArgs<ExtArgs>
    tutor_subjects?: boolean | subjects$tutor_subjectsArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subjects"
    objects: {
      group_sessions: Prisma.$group_sessionsPayload<ExtArgs>[]
      resources: Prisma.$resourcesPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      student_subject_interests: Prisma.$student_subject_interestsPayload<ExtArgs>[]
      subject_categories: Prisma.$subject_categoriesPayload<ExtArgs> | null
      tutor_subjects: Prisma.$tutor_subjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subject_id: number
      category_id: number | null
      name: string
      description: string | null
      difficulty_level: string | null
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type subjectsGetPayload<S extends boolean | null | undefined | subjectsDefaultArgs> = $Result.GetResult<Prisma.$subjectsPayload, S>

  type subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subjects'], meta: { name: 'subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {subjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectsFindUniqueArgs>(args: SelectSubset<T, subjectsFindUniqueArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectsFindFirstArgs>(args?: SelectSubset<T, subjectsFindFirstArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `subject_id`
     * const subjectsWithSubject_idOnly = await prisma.subjects.findMany({ select: { subject_id: true } })
     * 
     */
    findMany<T extends subjectsFindManyArgs>(args?: SelectSubset<T, subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subjects.
     * @param {subjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends subjectsCreateArgs>(args: SelectSubset<T, subjectsCreateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {subjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectsCreateManyArgs>(args?: SelectSubset<T, subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subjects.
     * @param {subjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends subjectsDeleteArgs>(args: SelectSubset<T, subjectsDeleteArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subjects.
     * @param {subjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectsUpdateArgs>(args: SelectSubset<T, subjectsUpdateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {subjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectsDeleteManyArgs>(args?: SelectSubset<T, subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectsUpdateManyArgs>(args: SelectSubset<T, subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subjects.
     * @param {subjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends subjectsUpsertArgs>(args: SelectSubset<T, subjectsUpsertArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectsCountArgs>(
      args?: Subset<T, subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectsGroupByArgs['orderBy'] }
        : { orderBy?: subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subjects model
   */
  readonly fields: subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group_sessions<T extends subjects$group_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$group_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends subjects$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, subjects$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends subjects$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_subject_interests<T extends subjects$student_subject_interestsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$student_subject_interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_subject_interestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subject_categories<T extends subjects$subject_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, subjects$subject_categoriesArgs<ExtArgs>>): Prisma__subject_categoriesClient<$Result.GetResult<Prisma.$subject_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutor_subjects<T extends subjects$tutor_subjectsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$tutor_subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subjects model
   */
  interface subjectsFieldRefs {
    readonly subject_id: FieldRef<"subjects", 'Int'>
    readonly category_id: FieldRef<"subjects", 'Int'>
    readonly name: FieldRef<"subjects", 'String'>
    readonly description: FieldRef<"subjects", 'String'>
    readonly difficulty_level: FieldRef<"subjects", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subjects findUnique
   */
  export type subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findUniqueOrThrow
   */
  export type subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findFirst
   */
  export type subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findFirstOrThrow
   */
  export type subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findMany
   */
  export type subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects create
   */
  export type subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a subjects.
     */
    data: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
  }

  /**
   * subjects createMany
   */
  export type subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectsCreateManyInput | subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subjects update
   */
  export type subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a subjects.
     */
    data: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
    /**
     * Choose, which subjects to update.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects updateMany
   */
  export type subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to update.
     */
    limit?: number
  }

  /**
   * subjects upsert
   */
  export type subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the subjects to update in case it exists.
     */
    where: subjectsWhereUniqueInput
    /**
     * In case the subjects found by the `where` argument doesn't exist, create a new subjects with this data.
     */
    create: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
    /**
     * In case the subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
  }

  /**
   * subjects delete
   */
  export type subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter which subjects to delete.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects deleteMany
   */
  export type subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to delete.
     */
    limit?: number
  }

  /**
   * subjects.group_sessions
   */
  export type subjects$group_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    where?: group_sessionsWhereInput
    orderBy?: group_sessionsOrderByWithRelationInput | group_sessionsOrderByWithRelationInput[]
    cursor?: group_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Group_sessionsScalarFieldEnum | Group_sessionsScalarFieldEnum[]
  }

  /**
   * subjects.resources
   */
  export type subjects$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    where?: resourcesWhereInput
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    cursor?: resourcesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * subjects.sessions
   */
  export type subjects$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * subjects.student_subject_interests
   */
  export type subjects$student_subject_interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_subject_interests
     */
    select?: student_subject_interestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_subject_interests
     */
    omit?: student_subject_interestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_subject_interestsInclude<ExtArgs> | null
    where?: student_subject_interestsWhereInput
    orderBy?: student_subject_interestsOrderByWithRelationInput | student_subject_interestsOrderByWithRelationInput[]
    cursor?: student_subject_interestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_subject_interestsScalarFieldEnum | Student_subject_interestsScalarFieldEnum[]
  }

  /**
   * subjects.subject_categories
   */
  export type subjects$subject_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_categories
     */
    select?: subject_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_categories
     */
    omit?: subject_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_categoriesInclude<ExtArgs> | null
    where?: subject_categoriesWhereInput
  }

  /**
   * subjects.tutor_subjects
   */
  export type subjects$tutor_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    where?: tutor_subjectsWhereInput
    orderBy?: tutor_subjectsOrderByWithRelationInput | tutor_subjectsOrderByWithRelationInput[]
    cursor?: tutor_subjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tutor_subjectsScalarFieldEnum | Tutor_subjectsScalarFieldEnum[]
  }

  /**
   * subjects without action
   */
  export type subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
  }


  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    subscription_id: number | null
    student_id: number | null
    price: Decimal | null
    sessions_included: number | null
    hours_included: Decimal | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    subscription_id: number | null
    student_id: number | null
    price: Decimal | null
    sessions_included: number | null
    hours_included: Decimal | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    subscription_id: number | null
    student_id: number | null
    plan_name: string | null
    description: string | null
    price: Decimal | null
    billing_cycle: string | null
    sessions_included: number | null
    hours_included: Decimal | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    auto_renew: boolean | null
    payment_method: string | null
    last_billing_date: Date | null
    next_billing_date: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    subscription_id: number | null
    student_id: number | null
    plan_name: string | null
    description: string | null
    price: Decimal | null
    billing_cycle: string | null
    sessions_included: number | null
    hours_included: Decimal | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    auto_renew: boolean | null
    payment_method: string | null
    last_billing_date: Date | null
    next_billing_date: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    subscription_id: number
    student_id: number
    plan_name: number
    description: number
    price: number
    billing_cycle: number
    sessions_included: number
    hours_included: number
    start_date: number
    end_date: number
    is_active: number
    auto_renew: number
    payment_method: number
    last_billing_date: number
    next_billing_date: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    subscription_id?: true
    student_id?: true
    price?: true
    sessions_included?: true
    hours_included?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    subscription_id?: true
    student_id?: true
    price?: true
    sessions_included?: true
    hours_included?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    subscription_id?: true
    student_id?: true
    plan_name?: true
    description?: true
    price?: true
    billing_cycle?: true
    sessions_included?: true
    hours_included?: true
    start_date?: true
    end_date?: true
    is_active?: true
    auto_renew?: true
    payment_method?: true
    last_billing_date?: true
    next_billing_date?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    subscription_id?: true
    student_id?: true
    plan_name?: true
    description?: true
    price?: true
    billing_cycle?: true
    sessions_included?: true
    hours_included?: true
    start_date?: true
    end_date?: true
    is_active?: true
    auto_renew?: true
    payment_method?: true
    last_billing_date?: true
    next_billing_date?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    subscription_id?: true
    student_id?: true
    plan_name?: true
    description?: true
    price?: true
    billing_cycle?: true
    sessions_included?: true
    hours_included?: true
    start_date?: true
    end_date?: true
    is_active?: true
    auto_renew?: true
    payment_method?: true
    last_billing_date?: true
    next_billing_date?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    subscription_id: number
    student_id: number
    plan_name: string
    description: string | null
    price: Decimal
    billing_cycle: string
    sessions_included: number | null
    hours_included: Decimal | null
    start_date: Date
    end_date: Date | null
    is_active: boolean | null
    auto_renew: boolean | null
    payment_method: string | null
    last_billing_date: Date | null
    next_billing_date: Date | null
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscription_id?: boolean
    student_id?: boolean
    plan_name?: boolean
    description?: boolean
    price?: boolean
    billing_cycle?: boolean
    sessions_included?: boolean
    hours_included?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    auto_renew?: boolean
    payment_method?: boolean
    last_billing_date?: boolean
    next_billing_date?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>



  export type subscriptionsSelectScalar = {
    subscription_id?: boolean
    student_id?: boolean
    plan_name?: boolean
    description?: boolean
    price?: boolean
    billing_cycle?: boolean
    sessions_included?: boolean
    hours_included?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    auto_renew?: boolean
    payment_method?: boolean
    last_billing_date?: boolean
    next_billing_date?: boolean
  }

  export type subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subscription_id" | "student_id" | "plan_name" | "description" | "price" | "billing_cycle" | "sessions_included" | "hours_included" | "start_date" | "end_date" | "is_active" | "auto_renew" | "payment_method" | "last_billing_date" | "next_billing_date", ExtArgs["result"]["subscriptions"]>
  export type subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subscription_id: number
      student_id: number
      plan_name: string
      description: string | null
      price: Prisma.Decimal
      billing_cycle: string
      sessions_included: number | null
      hours_included: Prisma.Decimal | null
      start_date: Date
      end_date: Date | null
      is_active: boolean | null
      auto_renew: boolean | null
      payment_method: string | null
      last_billing_date: Date | null
      next_billing_date: Date | null
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$subscriptionsPayload, S>

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'], meta: { name: 'subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `subscription_id`
     * const subscriptionsWithSubscription_idOnly = await prisma.subscriptions.findMany({ select: { subscription_id: true } })
     * 
     */
    findMany<T extends subscriptionsFindManyArgs>(args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends subscriptionsCreateArgs>(args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionsCreateManyArgs>(args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends subscriptionsDeleteArgs>(args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionsUpdateArgs>(args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscriptions model
   */
  readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscriptions model
   */
  interface subscriptionsFieldRefs {
    readonly subscription_id: FieldRef<"subscriptions", 'Int'>
    readonly student_id: FieldRef<"subscriptions", 'Int'>
    readonly plan_name: FieldRef<"subscriptions", 'String'>
    readonly description: FieldRef<"subscriptions", 'String'>
    readonly price: FieldRef<"subscriptions", 'Decimal'>
    readonly billing_cycle: FieldRef<"subscriptions", 'String'>
    readonly sessions_included: FieldRef<"subscriptions", 'Int'>
    readonly hours_included: FieldRef<"subscriptions", 'Decimal'>
    readonly start_date: FieldRef<"subscriptions", 'DateTime'>
    readonly end_date: FieldRef<"subscriptions", 'DateTime'>
    readonly is_active: FieldRef<"subscriptions", 'Boolean'>
    readonly auto_renew: FieldRef<"subscriptions", 'Boolean'>
    readonly payment_method: FieldRef<"subscriptions", 'String'>
    readonly last_billing_date: FieldRef<"subscriptions", 'DateTime'>
    readonly next_billing_date: FieldRef<"subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
  }

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
  }

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model tutor_availability
   */

  export type AggregateTutor_availability = {
    _count: Tutor_availabilityCountAggregateOutputType | null
    _avg: Tutor_availabilityAvgAggregateOutputType | null
    _sum: Tutor_availabilitySumAggregateOutputType | null
    _min: Tutor_availabilityMinAggregateOutputType | null
    _max: Tutor_availabilityMaxAggregateOutputType | null
  }

  export type Tutor_availabilityAvgAggregateOutputType = {
    availability_id: number | null
    tutor_id: number | null
    day_of_week: number | null
  }

  export type Tutor_availabilitySumAggregateOutputType = {
    availability_id: number | null
    tutor_id: number | null
    day_of_week: number | null
  }

  export type Tutor_availabilityMinAggregateOutputType = {
    availability_id: number | null
    tutor_id: number | null
    day_of_week: number | null
    start_time: Date | null
    end_time: Date | null
    is_recurring: boolean | null
    specific_date: Date | null
  }

  export type Tutor_availabilityMaxAggregateOutputType = {
    availability_id: number | null
    tutor_id: number | null
    day_of_week: number | null
    start_time: Date | null
    end_time: Date | null
    is_recurring: boolean | null
    specific_date: Date | null
  }

  export type Tutor_availabilityCountAggregateOutputType = {
    availability_id: number
    tutor_id: number
    day_of_week: number
    start_time: number
    end_time: number
    is_recurring: number
    specific_date: number
    _all: number
  }


  export type Tutor_availabilityAvgAggregateInputType = {
    availability_id?: true
    tutor_id?: true
    day_of_week?: true
  }

  export type Tutor_availabilitySumAggregateInputType = {
    availability_id?: true
    tutor_id?: true
    day_of_week?: true
  }

  export type Tutor_availabilityMinAggregateInputType = {
    availability_id?: true
    tutor_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    is_recurring?: true
    specific_date?: true
  }

  export type Tutor_availabilityMaxAggregateInputType = {
    availability_id?: true
    tutor_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    is_recurring?: true
    specific_date?: true
  }

  export type Tutor_availabilityCountAggregateInputType = {
    availability_id?: true
    tutor_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    is_recurring?: true
    specific_date?: true
    _all?: true
  }

  export type Tutor_availabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutor_availability to aggregate.
     */
    where?: tutor_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_availabilities to fetch.
     */
    orderBy?: tutor_availabilityOrderByWithRelationInput | tutor_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tutor_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tutor_availabilities
    **/
    _count?: true | Tutor_availabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tutor_availabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tutor_availabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tutor_availabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tutor_availabilityMaxAggregateInputType
  }

  export type GetTutor_availabilityAggregateType<T extends Tutor_availabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateTutor_availability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutor_availability[P]>
      : GetScalarType<T[P], AggregateTutor_availability[P]>
  }




  export type tutor_availabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutor_availabilityWhereInput
    orderBy?: tutor_availabilityOrderByWithAggregationInput | tutor_availabilityOrderByWithAggregationInput[]
    by: Tutor_availabilityScalarFieldEnum[] | Tutor_availabilityScalarFieldEnum
    having?: tutor_availabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tutor_availabilityCountAggregateInputType | true
    _avg?: Tutor_availabilityAvgAggregateInputType
    _sum?: Tutor_availabilitySumAggregateInputType
    _min?: Tutor_availabilityMinAggregateInputType
    _max?: Tutor_availabilityMaxAggregateInputType
  }

  export type Tutor_availabilityGroupByOutputType = {
    availability_id: number
    tutor_id: number
    day_of_week: number
    start_time: Date
    end_time: Date
    is_recurring: boolean | null
    specific_date: Date | null
    _count: Tutor_availabilityCountAggregateOutputType | null
    _avg: Tutor_availabilityAvgAggregateOutputType | null
    _sum: Tutor_availabilitySumAggregateOutputType | null
    _min: Tutor_availabilityMinAggregateOutputType | null
    _max: Tutor_availabilityMaxAggregateOutputType | null
  }

  type GetTutor_availabilityGroupByPayload<T extends tutor_availabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tutor_availabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tutor_availabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tutor_availabilityGroupByOutputType[P]>
            : GetScalarType<T[P], Tutor_availabilityGroupByOutputType[P]>
        }
      >
    >


  export type tutor_availabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    availability_id?: boolean
    tutor_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    is_recurring?: boolean
    specific_date?: boolean
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutor_availability"]>



  export type tutor_availabilitySelectScalar = {
    availability_id?: boolean
    tutor_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    is_recurring?: boolean
    specific_date?: boolean
  }

  export type tutor_availabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"availability_id" | "tutor_id" | "day_of_week" | "start_time" | "end_time" | "is_recurring" | "specific_date", ExtArgs["result"]["tutor_availability"]>
  export type tutor_availabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
  }

  export type $tutor_availabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tutor_availability"
    objects: {
      tutors: Prisma.$tutorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      availability_id: number
      tutor_id: number
      day_of_week: number
      start_time: Date
      end_time: Date
      is_recurring: boolean | null
      specific_date: Date | null
    }, ExtArgs["result"]["tutor_availability"]>
    composites: {}
  }

  type tutor_availabilityGetPayload<S extends boolean | null | undefined | tutor_availabilityDefaultArgs> = $Result.GetResult<Prisma.$tutor_availabilityPayload, S>

  type tutor_availabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tutor_availabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tutor_availabilityCountAggregateInputType | true
    }

  export interface tutor_availabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tutor_availability'], meta: { name: 'tutor_availability' } }
    /**
     * Find zero or one Tutor_availability that matches the filter.
     * @param {tutor_availabilityFindUniqueArgs} args - Arguments to find a Tutor_availability
     * @example
     * // Get one Tutor_availability
     * const tutor_availability = await prisma.tutor_availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tutor_availabilityFindUniqueArgs>(args: SelectSubset<T, tutor_availabilityFindUniqueArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tutor_availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tutor_availabilityFindUniqueOrThrowArgs} args - Arguments to find a Tutor_availability
     * @example
     * // Get one Tutor_availability
     * const tutor_availability = await prisma.tutor_availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tutor_availabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, tutor_availabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutor_availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_availabilityFindFirstArgs} args - Arguments to find a Tutor_availability
     * @example
     * // Get one Tutor_availability
     * const tutor_availability = await prisma.tutor_availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tutor_availabilityFindFirstArgs>(args?: SelectSubset<T, tutor_availabilityFindFirstArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutor_availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_availabilityFindFirstOrThrowArgs} args - Arguments to find a Tutor_availability
     * @example
     * // Get one Tutor_availability
     * const tutor_availability = await prisma.tutor_availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tutor_availabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, tutor_availabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tutor_availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_availabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutor_availabilities
     * const tutor_availabilities = await prisma.tutor_availability.findMany()
     * 
     * // Get first 10 Tutor_availabilities
     * const tutor_availabilities = await prisma.tutor_availability.findMany({ take: 10 })
     * 
     * // Only select the `availability_id`
     * const tutor_availabilityWithAvailability_idOnly = await prisma.tutor_availability.findMany({ select: { availability_id: true } })
     * 
     */
    findMany<T extends tutor_availabilityFindManyArgs>(args?: SelectSubset<T, tutor_availabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tutor_availability.
     * @param {tutor_availabilityCreateArgs} args - Arguments to create a Tutor_availability.
     * @example
     * // Create one Tutor_availability
     * const Tutor_availability = await prisma.tutor_availability.create({
     *   data: {
     *     // ... data to create a Tutor_availability
     *   }
     * })
     * 
     */
    create<T extends tutor_availabilityCreateArgs>(args: SelectSubset<T, tutor_availabilityCreateArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tutor_availabilities.
     * @param {tutor_availabilityCreateManyArgs} args - Arguments to create many Tutor_availabilities.
     * @example
     * // Create many Tutor_availabilities
     * const tutor_availability = await prisma.tutor_availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tutor_availabilityCreateManyArgs>(args?: SelectSubset<T, tutor_availabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tutor_availability.
     * @param {tutor_availabilityDeleteArgs} args - Arguments to delete one Tutor_availability.
     * @example
     * // Delete one Tutor_availability
     * const Tutor_availability = await prisma.tutor_availability.delete({
     *   where: {
     *     // ... filter to delete one Tutor_availability
     *   }
     * })
     * 
     */
    delete<T extends tutor_availabilityDeleteArgs>(args: SelectSubset<T, tutor_availabilityDeleteArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tutor_availability.
     * @param {tutor_availabilityUpdateArgs} args - Arguments to update one Tutor_availability.
     * @example
     * // Update one Tutor_availability
     * const tutor_availability = await prisma.tutor_availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tutor_availabilityUpdateArgs>(args: SelectSubset<T, tutor_availabilityUpdateArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tutor_availabilities.
     * @param {tutor_availabilityDeleteManyArgs} args - Arguments to filter Tutor_availabilities to delete.
     * @example
     * // Delete a few Tutor_availabilities
     * const { count } = await prisma.tutor_availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tutor_availabilityDeleteManyArgs>(args?: SelectSubset<T, tutor_availabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutor_availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_availabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutor_availabilities
     * const tutor_availability = await prisma.tutor_availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tutor_availabilityUpdateManyArgs>(args: SelectSubset<T, tutor_availabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tutor_availability.
     * @param {tutor_availabilityUpsertArgs} args - Arguments to update or create a Tutor_availability.
     * @example
     * // Update or create a Tutor_availability
     * const tutor_availability = await prisma.tutor_availability.upsert({
     *   create: {
     *     // ... data to create a Tutor_availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutor_availability we want to update
     *   }
     * })
     */
    upsert<T extends tutor_availabilityUpsertArgs>(args: SelectSubset<T, tutor_availabilityUpsertArgs<ExtArgs>>): Prisma__tutor_availabilityClient<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tutor_availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_availabilityCountArgs} args - Arguments to filter Tutor_availabilities to count.
     * @example
     * // Count the number of Tutor_availabilities
     * const count = await prisma.tutor_availability.count({
     *   where: {
     *     // ... the filter for the Tutor_availabilities we want to count
     *   }
     * })
    **/
    count<T extends tutor_availabilityCountArgs>(
      args?: Subset<T, tutor_availabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tutor_availabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutor_availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tutor_availabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tutor_availabilityAggregateArgs>(args: Subset<T, Tutor_availabilityAggregateArgs>): Prisma.PrismaPromise<GetTutor_availabilityAggregateType<T>>

    /**
     * Group by Tutor_availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_availabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tutor_availabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tutor_availabilityGroupByArgs['orderBy'] }
        : { orderBy?: tutor_availabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tutor_availabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutor_availabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tutor_availability model
   */
  readonly fields: tutor_availabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tutor_availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tutor_availabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutors<T extends tutorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tutorsDefaultArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tutor_availability model
   */
  interface tutor_availabilityFieldRefs {
    readonly availability_id: FieldRef<"tutor_availability", 'Int'>
    readonly tutor_id: FieldRef<"tutor_availability", 'Int'>
    readonly day_of_week: FieldRef<"tutor_availability", 'Int'>
    readonly start_time: FieldRef<"tutor_availability", 'DateTime'>
    readonly end_time: FieldRef<"tutor_availability", 'DateTime'>
    readonly is_recurring: FieldRef<"tutor_availability", 'Boolean'>
    readonly specific_date: FieldRef<"tutor_availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tutor_availability findUnique
   */
  export type tutor_availabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which tutor_availability to fetch.
     */
    where: tutor_availabilityWhereUniqueInput
  }

  /**
   * tutor_availability findUniqueOrThrow
   */
  export type tutor_availabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which tutor_availability to fetch.
     */
    where: tutor_availabilityWhereUniqueInput
  }

  /**
   * tutor_availability findFirst
   */
  export type tutor_availabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which tutor_availability to fetch.
     */
    where?: tutor_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_availabilities to fetch.
     */
    orderBy?: tutor_availabilityOrderByWithRelationInput | tutor_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutor_availabilities.
     */
    cursor?: tutor_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutor_availabilities.
     */
    distinct?: Tutor_availabilityScalarFieldEnum | Tutor_availabilityScalarFieldEnum[]
  }

  /**
   * tutor_availability findFirstOrThrow
   */
  export type tutor_availabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which tutor_availability to fetch.
     */
    where?: tutor_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_availabilities to fetch.
     */
    orderBy?: tutor_availabilityOrderByWithRelationInput | tutor_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutor_availabilities.
     */
    cursor?: tutor_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutor_availabilities.
     */
    distinct?: Tutor_availabilityScalarFieldEnum | Tutor_availabilityScalarFieldEnum[]
  }

  /**
   * tutor_availability findMany
   */
  export type tutor_availabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which tutor_availabilities to fetch.
     */
    where?: tutor_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_availabilities to fetch.
     */
    orderBy?: tutor_availabilityOrderByWithRelationInput | tutor_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tutor_availabilities.
     */
    cursor?: tutor_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_availabilities.
     */
    skip?: number
    distinct?: Tutor_availabilityScalarFieldEnum | Tutor_availabilityScalarFieldEnum[]
  }

  /**
   * tutor_availability create
   */
  export type tutor_availabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a tutor_availability.
     */
    data: XOR<tutor_availabilityCreateInput, tutor_availabilityUncheckedCreateInput>
  }

  /**
   * tutor_availability createMany
   */
  export type tutor_availabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tutor_availabilities.
     */
    data: tutor_availabilityCreateManyInput | tutor_availabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tutor_availability update
   */
  export type tutor_availabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a tutor_availability.
     */
    data: XOR<tutor_availabilityUpdateInput, tutor_availabilityUncheckedUpdateInput>
    /**
     * Choose, which tutor_availability to update.
     */
    where: tutor_availabilityWhereUniqueInput
  }

  /**
   * tutor_availability updateMany
   */
  export type tutor_availabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tutor_availabilities.
     */
    data: XOR<tutor_availabilityUpdateManyMutationInput, tutor_availabilityUncheckedUpdateManyInput>
    /**
     * Filter which tutor_availabilities to update
     */
    where?: tutor_availabilityWhereInput
    /**
     * Limit how many tutor_availabilities to update.
     */
    limit?: number
  }

  /**
   * tutor_availability upsert
   */
  export type tutor_availabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the tutor_availability to update in case it exists.
     */
    where: tutor_availabilityWhereUniqueInput
    /**
     * In case the tutor_availability found by the `where` argument doesn't exist, create a new tutor_availability with this data.
     */
    create: XOR<tutor_availabilityCreateInput, tutor_availabilityUncheckedCreateInput>
    /**
     * In case the tutor_availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tutor_availabilityUpdateInput, tutor_availabilityUncheckedUpdateInput>
  }

  /**
   * tutor_availability delete
   */
  export type tutor_availabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    /**
     * Filter which tutor_availability to delete.
     */
    where: tutor_availabilityWhereUniqueInput
  }

  /**
   * tutor_availability deleteMany
   */
  export type tutor_availabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutor_availabilities to delete
     */
    where?: tutor_availabilityWhereInput
    /**
     * Limit how many tutor_availabilities to delete.
     */
    limit?: number
  }

  /**
   * tutor_availability without action
   */
  export type tutor_availabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
  }


  /**
   * Model tutor_subjects
   */

  export type AggregateTutor_subjects = {
    _count: Tutor_subjectsCountAggregateOutputType | null
    _avg: Tutor_subjectsAvgAggregateOutputType | null
    _sum: Tutor_subjectsSumAggregateOutputType | null
    _min: Tutor_subjectsMinAggregateOutputType | null
    _max: Tutor_subjectsMaxAggregateOutputType | null
  }

  export type Tutor_subjectsAvgAggregateOutputType = {
    tutor_subject_id: number | null
    tutor_id: number | null
    subject_id: number | null
  }

  export type Tutor_subjectsSumAggregateOutputType = {
    tutor_subject_id: number | null
    tutor_id: number | null
    subject_id: number | null
  }

  export type Tutor_subjectsMinAggregateOutputType = {
    tutor_subject_id: number | null
    tutor_id: number | null
    subject_id: number | null
    proficiency_level: string | null
    verified: boolean | null
  }

  export type Tutor_subjectsMaxAggregateOutputType = {
    tutor_subject_id: number | null
    tutor_id: number | null
    subject_id: number | null
    proficiency_level: string | null
    verified: boolean | null
  }

  export type Tutor_subjectsCountAggregateOutputType = {
    tutor_subject_id: number
    tutor_id: number
    subject_id: number
    proficiency_level: number
    verified: number
    _all: number
  }


  export type Tutor_subjectsAvgAggregateInputType = {
    tutor_subject_id?: true
    tutor_id?: true
    subject_id?: true
  }

  export type Tutor_subjectsSumAggregateInputType = {
    tutor_subject_id?: true
    tutor_id?: true
    subject_id?: true
  }

  export type Tutor_subjectsMinAggregateInputType = {
    tutor_subject_id?: true
    tutor_id?: true
    subject_id?: true
    proficiency_level?: true
    verified?: true
  }

  export type Tutor_subjectsMaxAggregateInputType = {
    tutor_subject_id?: true
    tutor_id?: true
    subject_id?: true
    proficiency_level?: true
    verified?: true
  }

  export type Tutor_subjectsCountAggregateInputType = {
    tutor_subject_id?: true
    tutor_id?: true
    subject_id?: true
    proficiency_level?: true
    verified?: true
    _all?: true
  }

  export type Tutor_subjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutor_subjects to aggregate.
     */
    where?: tutor_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_subjects to fetch.
     */
    orderBy?: tutor_subjectsOrderByWithRelationInput | tutor_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tutor_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tutor_subjects
    **/
    _count?: true | Tutor_subjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tutor_subjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tutor_subjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tutor_subjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tutor_subjectsMaxAggregateInputType
  }

  export type GetTutor_subjectsAggregateType<T extends Tutor_subjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateTutor_subjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutor_subjects[P]>
      : GetScalarType<T[P], AggregateTutor_subjects[P]>
  }




  export type tutor_subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutor_subjectsWhereInput
    orderBy?: tutor_subjectsOrderByWithAggregationInput | tutor_subjectsOrderByWithAggregationInput[]
    by: Tutor_subjectsScalarFieldEnum[] | Tutor_subjectsScalarFieldEnum
    having?: tutor_subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tutor_subjectsCountAggregateInputType | true
    _avg?: Tutor_subjectsAvgAggregateInputType
    _sum?: Tutor_subjectsSumAggregateInputType
    _min?: Tutor_subjectsMinAggregateInputType
    _max?: Tutor_subjectsMaxAggregateInputType
  }

  export type Tutor_subjectsGroupByOutputType = {
    tutor_subject_id: number
    tutor_id: number
    subject_id: number
    proficiency_level: string
    verified: boolean | null
    _count: Tutor_subjectsCountAggregateOutputType | null
    _avg: Tutor_subjectsAvgAggregateOutputType | null
    _sum: Tutor_subjectsSumAggregateOutputType | null
    _min: Tutor_subjectsMinAggregateOutputType | null
    _max: Tutor_subjectsMaxAggregateOutputType | null
  }

  type GetTutor_subjectsGroupByPayload<T extends tutor_subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tutor_subjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tutor_subjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tutor_subjectsGroupByOutputType[P]>
            : GetScalarType<T[P], Tutor_subjectsGroupByOutputType[P]>
        }
      >
    >


  export type tutor_subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tutor_subject_id?: boolean
    tutor_id?: boolean
    subject_id?: boolean
    proficiency_level?: boolean
    verified?: boolean
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutor_subjects"]>



  export type tutor_subjectsSelectScalar = {
    tutor_subject_id?: boolean
    tutor_id?: boolean
    subject_id?: boolean
    proficiency_level?: boolean
    verified?: boolean
  }

  export type tutor_subjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tutor_subject_id" | "tutor_id" | "subject_id" | "proficiency_level" | "verified", ExtArgs["result"]["tutor_subjects"]>
  export type tutor_subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutors?: boolean | tutorsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }

  export type $tutor_subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tutor_subjects"
    objects: {
      tutors: Prisma.$tutorsPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tutor_subject_id: number
      tutor_id: number
      subject_id: number
      proficiency_level: string
      verified: boolean | null
    }, ExtArgs["result"]["tutor_subjects"]>
    composites: {}
  }

  type tutor_subjectsGetPayload<S extends boolean | null | undefined | tutor_subjectsDefaultArgs> = $Result.GetResult<Prisma.$tutor_subjectsPayload, S>

  type tutor_subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tutor_subjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tutor_subjectsCountAggregateInputType | true
    }

  export interface tutor_subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tutor_subjects'], meta: { name: 'tutor_subjects' } }
    /**
     * Find zero or one Tutor_subjects that matches the filter.
     * @param {tutor_subjectsFindUniqueArgs} args - Arguments to find a Tutor_subjects
     * @example
     * // Get one Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tutor_subjectsFindUniqueArgs>(args: SelectSubset<T, tutor_subjectsFindUniqueArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tutor_subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tutor_subjectsFindUniqueOrThrowArgs} args - Arguments to find a Tutor_subjects
     * @example
     * // Get one Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tutor_subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, tutor_subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutor_subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_subjectsFindFirstArgs} args - Arguments to find a Tutor_subjects
     * @example
     * // Get one Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tutor_subjectsFindFirstArgs>(args?: SelectSubset<T, tutor_subjectsFindFirstArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutor_subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_subjectsFindFirstOrThrowArgs} args - Arguments to find a Tutor_subjects
     * @example
     * // Get one Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tutor_subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, tutor_subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tutor_subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.findMany()
     * 
     * // Get first 10 Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.findMany({ take: 10 })
     * 
     * // Only select the `tutor_subject_id`
     * const tutor_subjectsWithTutor_subject_idOnly = await prisma.tutor_subjects.findMany({ select: { tutor_subject_id: true } })
     * 
     */
    findMany<T extends tutor_subjectsFindManyArgs>(args?: SelectSubset<T, tutor_subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tutor_subjects.
     * @param {tutor_subjectsCreateArgs} args - Arguments to create a Tutor_subjects.
     * @example
     * // Create one Tutor_subjects
     * const Tutor_subjects = await prisma.tutor_subjects.create({
     *   data: {
     *     // ... data to create a Tutor_subjects
     *   }
     * })
     * 
     */
    create<T extends tutor_subjectsCreateArgs>(args: SelectSubset<T, tutor_subjectsCreateArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tutor_subjects.
     * @param {tutor_subjectsCreateManyArgs} args - Arguments to create many Tutor_subjects.
     * @example
     * // Create many Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tutor_subjectsCreateManyArgs>(args?: SelectSubset<T, tutor_subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tutor_subjects.
     * @param {tutor_subjectsDeleteArgs} args - Arguments to delete one Tutor_subjects.
     * @example
     * // Delete one Tutor_subjects
     * const Tutor_subjects = await prisma.tutor_subjects.delete({
     *   where: {
     *     // ... filter to delete one Tutor_subjects
     *   }
     * })
     * 
     */
    delete<T extends tutor_subjectsDeleteArgs>(args: SelectSubset<T, tutor_subjectsDeleteArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tutor_subjects.
     * @param {tutor_subjectsUpdateArgs} args - Arguments to update one Tutor_subjects.
     * @example
     * // Update one Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tutor_subjectsUpdateArgs>(args: SelectSubset<T, tutor_subjectsUpdateArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tutor_subjects.
     * @param {tutor_subjectsDeleteManyArgs} args - Arguments to filter Tutor_subjects to delete.
     * @example
     * // Delete a few Tutor_subjects
     * const { count } = await prisma.tutor_subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tutor_subjectsDeleteManyArgs>(args?: SelectSubset<T, tutor_subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutor_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tutor_subjectsUpdateManyArgs>(args: SelectSubset<T, tutor_subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tutor_subjects.
     * @param {tutor_subjectsUpsertArgs} args - Arguments to update or create a Tutor_subjects.
     * @example
     * // Update or create a Tutor_subjects
     * const tutor_subjects = await prisma.tutor_subjects.upsert({
     *   create: {
     *     // ... data to create a Tutor_subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutor_subjects we want to update
     *   }
     * })
     */
    upsert<T extends tutor_subjectsUpsertArgs>(args: SelectSubset<T, tutor_subjectsUpsertArgs<ExtArgs>>): Prisma__tutor_subjectsClient<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tutor_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_subjectsCountArgs} args - Arguments to filter Tutor_subjects to count.
     * @example
     * // Count the number of Tutor_subjects
     * const count = await prisma.tutor_subjects.count({
     *   where: {
     *     // ... the filter for the Tutor_subjects we want to count
     *   }
     * })
    **/
    count<T extends tutor_subjectsCountArgs>(
      args?: Subset<T, tutor_subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tutor_subjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutor_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tutor_subjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tutor_subjectsAggregateArgs>(args: Subset<T, Tutor_subjectsAggregateArgs>): Prisma.PrismaPromise<GetTutor_subjectsAggregateType<T>>

    /**
     * Group by Tutor_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutor_subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tutor_subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tutor_subjectsGroupByArgs['orderBy'] }
        : { orderBy?: tutor_subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tutor_subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutor_subjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tutor_subjects model
   */
  readonly fields: tutor_subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tutor_subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tutor_subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutors<T extends tutorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tutorsDefaultArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tutor_subjects model
   */
  interface tutor_subjectsFieldRefs {
    readonly tutor_subject_id: FieldRef<"tutor_subjects", 'Int'>
    readonly tutor_id: FieldRef<"tutor_subjects", 'Int'>
    readonly subject_id: FieldRef<"tutor_subjects", 'Int'>
    readonly proficiency_level: FieldRef<"tutor_subjects", 'String'>
    readonly verified: FieldRef<"tutor_subjects", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * tutor_subjects findUnique
   */
  export type tutor_subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which tutor_subjects to fetch.
     */
    where: tutor_subjectsWhereUniqueInput
  }

  /**
   * tutor_subjects findUniqueOrThrow
   */
  export type tutor_subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which tutor_subjects to fetch.
     */
    where: tutor_subjectsWhereUniqueInput
  }

  /**
   * tutor_subjects findFirst
   */
  export type tutor_subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which tutor_subjects to fetch.
     */
    where?: tutor_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_subjects to fetch.
     */
    orderBy?: tutor_subjectsOrderByWithRelationInput | tutor_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutor_subjects.
     */
    cursor?: tutor_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutor_subjects.
     */
    distinct?: Tutor_subjectsScalarFieldEnum | Tutor_subjectsScalarFieldEnum[]
  }

  /**
   * tutor_subjects findFirstOrThrow
   */
  export type tutor_subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which tutor_subjects to fetch.
     */
    where?: tutor_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_subjects to fetch.
     */
    orderBy?: tutor_subjectsOrderByWithRelationInput | tutor_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutor_subjects.
     */
    cursor?: tutor_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutor_subjects.
     */
    distinct?: Tutor_subjectsScalarFieldEnum | Tutor_subjectsScalarFieldEnum[]
  }

  /**
   * tutor_subjects findMany
   */
  export type tutor_subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which tutor_subjects to fetch.
     */
    where?: tutor_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutor_subjects to fetch.
     */
    orderBy?: tutor_subjectsOrderByWithRelationInput | tutor_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tutor_subjects.
     */
    cursor?: tutor_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutor_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutor_subjects.
     */
    skip?: number
    distinct?: Tutor_subjectsScalarFieldEnum | Tutor_subjectsScalarFieldEnum[]
  }

  /**
   * tutor_subjects create
   */
  export type tutor_subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a tutor_subjects.
     */
    data: XOR<tutor_subjectsCreateInput, tutor_subjectsUncheckedCreateInput>
  }

  /**
   * tutor_subjects createMany
   */
  export type tutor_subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tutor_subjects.
     */
    data: tutor_subjectsCreateManyInput | tutor_subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tutor_subjects update
   */
  export type tutor_subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a tutor_subjects.
     */
    data: XOR<tutor_subjectsUpdateInput, tutor_subjectsUncheckedUpdateInput>
    /**
     * Choose, which tutor_subjects to update.
     */
    where: tutor_subjectsWhereUniqueInput
  }

  /**
   * tutor_subjects updateMany
   */
  export type tutor_subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tutor_subjects.
     */
    data: XOR<tutor_subjectsUpdateManyMutationInput, tutor_subjectsUncheckedUpdateManyInput>
    /**
     * Filter which tutor_subjects to update
     */
    where?: tutor_subjectsWhereInput
    /**
     * Limit how many tutor_subjects to update.
     */
    limit?: number
  }

  /**
   * tutor_subjects upsert
   */
  export type tutor_subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the tutor_subjects to update in case it exists.
     */
    where: tutor_subjectsWhereUniqueInput
    /**
     * In case the tutor_subjects found by the `where` argument doesn't exist, create a new tutor_subjects with this data.
     */
    create: XOR<tutor_subjectsCreateInput, tutor_subjectsUncheckedCreateInput>
    /**
     * In case the tutor_subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tutor_subjectsUpdateInput, tutor_subjectsUncheckedUpdateInput>
  }

  /**
   * tutor_subjects delete
   */
  export type tutor_subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    /**
     * Filter which tutor_subjects to delete.
     */
    where: tutor_subjectsWhereUniqueInput
  }

  /**
   * tutor_subjects deleteMany
   */
  export type tutor_subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutor_subjects to delete
     */
    where?: tutor_subjectsWhereInput
    /**
     * Limit how many tutor_subjects to delete.
     */
    limit?: number
  }

  /**
   * tutor_subjects without action
   */
  export type tutor_subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
  }


  /**
   * Model tutors
   */

  export type AggregateTutors = {
    _count: TutorsCountAggregateOutputType | null
    _avg: TutorsAvgAggregateOutputType | null
    _sum: TutorsSumAggregateOutputType | null
    _min: TutorsMinAggregateOutputType | null
    _max: TutorsMaxAggregateOutputType | null
  }

  export type TutorsAvgAggregateOutputType = {
    tutor_id: number | null
    user_id: number | null
    hourly_rate: Decimal | null
    experience_years: number | null
    avg_rating: Decimal | null
    total_sessions: number | null
  }

  export type TutorsSumAggregateOutputType = {
    tutor_id: number | null
    user_id: number | null
    hourly_rate: Decimal | null
    experience_years: number | null
    avg_rating: Decimal | null
    total_sessions: number | null
  }

  export type TutorsMinAggregateOutputType = {
    tutor_id: number | null
    user_id: number | null
    hourly_rate: Decimal | null
    experience_years: number | null
    qualification: string | null
    background_check_status: string | null
    background_check_date: Date | null
    avg_rating: Decimal | null
    total_sessions: number | null
    is_verified: boolean | null
    verification_date: Date | null
  }

  export type TutorsMaxAggregateOutputType = {
    tutor_id: number | null
    user_id: number | null
    hourly_rate: Decimal | null
    experience_years: number | null
    qualification: string | null
    background_check_status: string | null
    background_check_date: Date | null
    avg_rating: Decimal | null
    total_sessions: number | null
    is_verified: boolean | null
    verification_date: Date | null
  }

  export type TutorsCountAggregateOutputType = {
    tutor_id: number
    user_id: number
    hourly_rate: number
    experience_years: number
    qualification: number
    background_check_status: number
    background_check_date: number
    avg_rating: number
    total_sessions: number
    is_verified: number
    verification_date: number
    payment_details: number
    _all: number
  }


  export type TutorsAvgAggregateInputType = {
    tutor_id?: true
    user_id?: true
    hourly_rate?: true
    experience_years?: true
    avg_rating?: true
    total_sessions?: true
  }

  export type TutorsSumAggregateInputType = {
    tutor_id?: true
    user_id?: true
    hourly_rate?: true
    experience_years?: true
    avg_rating?: true
    total_sessions?: true
  }

  export type TutorsMinAggregateInputType = {
    tutor_id?: true
    user_id?: true
    hourly_rate?: true
    experience_years?: true
    qualification?: true
    background_check_status?: true
    background_check_date?: true
    avg_rating?: true
    total_sessions?: true
    is_verified?: true
    verification_date?: true
  }

  export type TutorsMaxAggregateInputType = {
    tutor_id?: true
    user_id?: true
    hourly_rate?: true
    experience_years?: true
    qualification?: true
    background_check_status?: true
    background_check_date?: true
    avg_rating?: true
    total_sessions?: true
    is_verified?: true
    verification_date?: true
  }

  export type TutorsCountAggregateInputType = {
    tutor_id?: true
    user_id?: true
    hourly_rate?: true
    experience_years?: true
    qualification?: true
    background_check_status?: true
    background_check_date?: true
    avg_rating?: true
    total_sessions?: true
    is_verified?: true
    verification_date?: true
    payment_details?: true
    _all?: true
  }

  export type TutorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutors to aggregate.
     */
    where?: tutorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutors to fetch.
     */
    orderBy?: tutorsOrderByWithRelationInput | tutorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tutorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tutors
    **/
    _count?: true | TutorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorsMaxAggregateInputType
  }

  export type GetTutorsAggregateType<T extends TutorsAggregateArgs> = {
        [P in keyof T & keyof AggregateTutors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutors[P]>
      : GetScalarType<T[P], AggregateTutors[P]>
  }




  export type tutorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutorsWhereInput
    orderBy?: tutorsOrderByWithAggregationInput | tutorsOrderByWithAggregationInput[]
    by: TutorsScalarFieldEnum[] | TutorsScalarFieldEnum
    having?: tutorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorsCountAggregateInputType | true
    _avg?: TutorsAvgAggregateInputType
    _sum?: TutorsSumAggregateInputType
    _min?: TutorsMinAggregateInputType
    _max?: TutorsMaxAggregateInputType
  }

  export type TutorsGroupByOutputType = {
    tutor_id: number
    user_id: number
    hourly_rate: Decimal
    experience_years: number | null
    qualification: string
    background_check_status: string | null
    background_check_date: Date | null
    avg_rating: Decimal | null
    total_sessions: number | null
    is_verified: boolean | null
    verification_date: Date | null
    payment_details: JsonValue | null
    _count: TutorsCountAggregateOutputType | null
    _avg: TutorsAvgAggregateOutputType | null
    _sum: TutorsSumAggregateOutputType | null
    _min: TutorsMinAggregateOutputType | null
    _max: TutorsMaxAggregateOutputType | null
  }

  type GetTutorsGroupByPayload<T extends tutorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorsGroupByOutputType[P]>
            : GetScalarType<T[P], TutorsGroupByOutputType[P]>
        }
      >
    >


  export type tutorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tutor_id?: boolean
    user_id?: boolean
    hourly_rate?: boolean
    experience_years?: boolean
    qualification?: boolean
    background_check_status?: boolean
    background_check_date?: boolean
    avg_rating?: boolean
    total_sessions?: boolean
    is_verified?: boolean
    verification_date?: boolean
    payment_details?: boolean
    group_sessions?: boolean | tutors$group_sessionsArgs<ExtArgs>
    session_ratings?: boolean | tutors$session_ratingsArgs<ExtArgs>
    sessions?: boolean | tutors$sessionsArgs<ExtArgs>
    tutor_availability?: boolean | tutors$tutor_availabilityArgs<ExtArgs>
    tutor_subjects?: boolean | tutors$tutor_subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TutorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutors"]>



  export type tutorsSelectScalar = {
    tutor_id?: boolean
    user_id?: boolean
    hourly_rate?: boolean
    experience_years?: boolean
    qualification?: boolean
    background_check_status?: boolean
    background_check_date?: boolean
    avg_rating?: boolean
    total_sessions?: boolean
    is_verified?: boolean
    verification_date?: boolean
    payment_details?: boolean
  }

  export type tutorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tutor_id" | "user_id" | "hourly_rate" | "experience_years" | "qualification" | "background_check_status" | "background_check_date" | "avg_rating" | "total_sessions" | "is_verified" | "verification_date" | "payment_details", ExtArgs["result"]["tutors"]>
  export type tutorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_sessions?: boolean | tutors$group_sessionsArgs<ExtArgs>
    session_ratings?: boolean | tutors$session_ratingsArgs<ExtArgs>
    sessions?: boolean | tutors$sessionsArgs<ExtArgs>
    tutor_availability?: boolean | tutors$tutor_availabilityArgs<ExtArgs>
    tutor_subjects?: boolean | tutors$tutor_subjectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | TutorsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tutorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tutors"
    objects: {
      group_sessions: Prisma.$group_sessionsPayload<ExtArgs>[]
      session_ratings: Prisma.$session_ratingsPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      tutor_availability: Prisma.$tutor_availabilityPayload<ExtArgs>[]
      tutor_subjects: Prisma.$tutor_subjectsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tutor_id: number
      user_id: number
      hourly_rate: Prisma.Decimal
      experience_years: number | null
      qualification: string
      background_check_status: string | null
      background_check_date: Date | null
      avg_rating: Prisma.Decimal | null
      total_sessions: number | null
      is_verified: boolean | null
      verification_date: Date | null
      payment_details: Prisma.JsonValue | null
    }, ExtArgs["result"]["tutors"]>
    composites: {}
  }

  type tutorsGetPayload<S extends boolean | null | undefined | tutorsDefaultArgs> = $Result.GetResult<Prisma.$tutorsPayload, S>

  type tutorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tutorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TutorsCountAggregateInputType | true
    }

  export interface tutorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tutors'], meta: { name: 'tutors' } }
    /**
     * Find zero or one Tutors that matches the filter.
     * @param {tutorsFindUniqueArgs} args - Arguments to find a Tutors
     * @example
     * // Get one Tutors
     * const tutors = await prisma.tutors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tutorsFindUniqueArgs>(args: SelectSubset<T, tutorsFindUniqueArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tutors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tutorsFindUniqueOrThrowArgs} args - Arguments to find a Tutors
     * @example
     * // Get one Tutors
     * const tutors = await prisma.tutors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tutorsFindUniqueOrThrowArgs>(args: SelectSubset<T, tutorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutorsFindFirstArgs} args - Arguments to find a Tutors
     * @example
     * // Get one Tutors
     * const tutors = await prisma.tutors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tutorsFindFirstArgs>(args?: SelectSubset<T, tutorsFindFirstArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutorsFindFirstOrThrowArgs} args - Arguments to find a Tutors
     * @example
     * // Get one Tutors
     * const tutors = await prisma.tutors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tutorsFindFirstOrThrowArgs>(args?: SelectSubset<T, tutorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutors
     * const tutors = await prisma.tutors.findMany()
     * 
     * // Get first 10 Tutors
     * const tutors = await prisma.tutors.findMany({ take: 10 })
     * 
     * // Only select the `tutor_id`
     * const tutorsWithTutor_idOnly = await prisma.tutors.findMany({ select: { tutor_id: true } })
     * 
     */
    findMany<T extends tutorsFindManyArgs>(args?: SelectSubset<T, tutorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tutors.
     * @param {tutorsCreateArgs} args - Arguments to create a Tutors.
     * @example
     * // Create one Tutors
     * const Tutors = await prisma.tutors.create({
     *   data: {
     *     // ... data to create a Tutors
     *   }
     * })
     * 
     */
    create<T extends tutorsCreateArgs>(args: SelectSubset<T, tutorsCreateArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tutors.
     * @param {tutorsCreateManyArgs} args - Arguments to create many Tutors.
     * @example
     * // Create many Tutors
     * const tutors = await prisma.tutors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tutorsCreateManyArgs>(args?: SelectSubset<T, tutorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tutors.
     * @param {tutorsDeleteArgs} args - Arguments to delete one Tutors.
     * @example
     * // Delete one Tutors
     * const Tutors = await prisma.tutors.delete({
     *   where: {
     *     // ... filter to delete one Tutors
     *   }
     * })
     * 
     */
    delete<T extends tutorsDeleteArgs>(args: SelectSubset<T, tutorsDeleteArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tutors.
     * @param {tutorsUpdateArgs} args - Arguments to update one Tutors.
     * @example
     * // Update one Tutors
     * const tutors = await prisma.tutors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tutorsUpdateArgs>(args: SelectSubset<T, tutorsUpdateArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tutors.
     * @param {tutorsDeleteManyArgs} args - Arguments to filter Tutors to delete.
     * @example
     * // Delete a few Tutors
     * const { count } = await prisma.tutors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tutorsDeleteManyArgs>(args?: SelectSubset<T, tutorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutors
     * const tutors = await prisma.tutors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tutorsUpdateManyArgs>(args: SelectSubset<T, tutorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tutors.
     * @param {tutorsUpsertArgs} args - Arguments to update or create a Tutors.
     * @example
     * // Update or create a Tutors
     * const tutors = await prisma.tutors.upsert({
     *   create: {
     *     // ... data to create a Tutors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutors we want to update
     *   }
     * })
     */
    upsert<T extends tutorsUpsertArgs>(args: SelectSubset<T, tutorsUpsertArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutorsCountArgs} args - Arguments to filter Tutors to count.
     * @example
     * // Count the number of Tutors
     * const count = await prisma.tutors.count({
     *   where: {
     *     // ... the filter for the Tutors we want to count
     *   }
     * })
    **/
    count<T extends tutorsCountArgs>(
      args?: Subset<T, tutorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorsAggregateArgs>(args: Subset<T, TutorsAggregateArgs>): Prisma.PrismaPromise<GetTutorsAggregateType<T>>

    /**
     * Group by Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tutorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tutorsGroupByArgs['orderBy'] }
        : { orderBy?: tutorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tutorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tutors model
   */
  readonly fields: tutorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tutors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tutorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group_sessions<T extends tutors$group_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, tutors$group_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_ratings<T extends tutors$session_ratingsArgs<ExtArgs> = {}>(args?: Subset<T, tutors$session_ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends tutors$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, tutors$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutor_availability<T extends tutors$tutor_availabilityArgs<ExtArgs> = {}>(args?: Subset<T, tutors$tutor_availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutor_availabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutor_subjects<T extends tutors$tutor_subjectsArgs<ExtArgs> = {}>(args?: Subset<T, tutors$tutor_subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutor_subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tutors model
   */
  interface tutorsFieldRefs {
    readonly tutor_id: FieldRef<"tutors", 'Int'>
    readonly user_id: FieldRef<"tutors", 'Int'>
    readonly hourly_rate: FieldRef<"tutors", 'Decimal'>
    readonly experience_years: FieldRef<"tutors", 'Int'>
    readonly qualification: FieldRef<"tutors", 'String'>
    readonly background_check_status: FieldRef<"tutors", 'String'>
    readonly background_check_date: FieldRef<"tutors", 'DateTime'>
    readonly avg_rating: FieldRef<"tutors", 'Decimal'>
    readonly total_sessions: FieldRef<"tutors", 'Int'>
    readonly is_verified: FieldRef<"tutors", 'Boolean'>
    readonly verification_date: FieldRef<"tutors", 'DateTime'>
    readonly payment_details: FieldRef<"tutors", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * tutors findUnique
   */
  export type tutorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * Filter, which tutors to fetch.
     */
    where: tutorsWhereUniqueInput
  }

  /**
   * tutors findUniqueOrThrow
   */
  export type tutorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * Filter, which tutors to fetch.
     */
    where: tutorsWhereUniqueInput
  }

  /**
   * tutors findFirst
   */
  export type tutorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * Filter, which tutors to fetch.
     */
    where?: tutorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutors to fetch.
     */
    orderBy?: tutorsOrderByWithRelationInput | tutorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutors.
     */
    cursor?: tutorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutors.
     */
    distinct?: TutorsScalarFieldEnum | TutorsScalarFieldEnum[]
  }

  /**
   * tutors findFirstOrThrow
   */
  export type tutorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * Filter, which tutors to fetch.
     */
    where?: tutorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutors to fetch.
     */
    orderBy?: tutorsOrderByWithRelationInput | tutorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutors.
     */
    cursor?: tutorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutors.
     */
    distinct?: TutorsScalarFieldEnum | TutorsScalarFieldEnum[]
  }

  /**
   * tutors findMany
   */
  export type tutorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * Filter, which tutors to fetch.
     */
    where?: tutorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutors to fetch.
     */
    orderBy?: tutorsOrderByWithRelationInput | tutorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tutors.
     */
    cursor?: tutorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutors.
     */
    skip?: number
    distinct?: TutorsScalarFieldEnum | TutorsScalarFieldEnum[]
  }

  /**
   * tutors create
   */
  export type tutorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * The data needed to create a tutors.
     */
    data: XOR<tutorsCreateInput, tutorsUncheckedCreateInput>
  }

  /**
   * tutors createMany
   */
  export type tutorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tutors.
     */
    data: tutorsCreateManyInput | tutorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tutors update
   */
  export type tutorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * The data needed to update a tutors.
     */
    data: XOR<tutorsUpdateInput, tutorsUncheckedUpdateInput>
    /**
     * Choose, which tutors to update.
     */
    where: tutorsWhereUniqueInput
  }

  /**
   * tutors updateMany
   */
  export type tutorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tutors.
     */
    data: XOR<tutorsUpdateManyMutationInput, tutorsUncheckedUpdateManyInput>
    /**
     * Filter which tutors to update
     */
    where?: tutorsWhereInput
    /**
     * Limit how many tutors to update.
     */
    limit?: number
  }

  /**
   * tutors upsert
   */
  export type tutorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * The filter to search for the tutors to update in case it exists.
     */
    where: tutorsWhereUniqueInput
    /**
     * In case the tutors found by the `where` argument doesn't exist, create a new tutors with this data.
     */
    create: XOR<tutorsCreateInput, tutorsUncheckedCreateInput>
    /**
     * In case the tutors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tutorsUpdateInput, tutorsUncheckedUpdateInput>
  }

  /**
   * tutors delete
   */
  export type tutorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    /**
     * Filter which tutors to delete.
     */
    where: tutorsWhereUniqueInput
  }

  /**
   * tutors deleteMany
   */
  export type tutorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutors to delete
     */
    where?: tutorsWhereInput
    /**
     * Limit how many tutors to delete.
     */
    limit?: number
  }

  /**
   * tutors.group_sessions
   */
  export type tutors$group_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_sessions
     */
    select?: group_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_sessions
     */
    omit?: group_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: group_sessionsInclude<ExtArgs> | null
    where?: group_sessionsWhereInput
    orderBy?: group_sessionsOrderByWithRelationInput | group_sessionsOrderByWithRelationInput[]
    cursor?: group_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Group_sessionsScalarFieldEnum | Group_sessionsScalarFieldEnum[]
  }

  /**
   * tutors.session_ratings
   */
  export type tutors$session_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_ratings
     */
    select?: session_ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_ratings
     */
    omit?: session_ratingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_ratingsInclude<ExtArgs> | null
    where?: session_ratingsWhereInput
    orderBy?: session_ratingsOrderByWithRelationInput | session_ratingsOrderByWithRelationInput[]
    cursor?: session_ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_ratingsScalarFieldEnum | Session_ratingsScalarFieldEnum[]
  }

  /**
   * tutors.sessions
   */
  export type tutors$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * tutors.tutor_availability
   */
  export type tutors$tutor_availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_availability
     */
    select?: tutor_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_availability
     */
    omit?: tutor_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_availabilityInclude<ExtArgs> | null
    where?: tutor_availabilityWhereInput
    orderBy?: tutor_availabilityOrderByWithRelationInput | tutor_availabilityOrderByWithRelationInput[]
    cursor?: tutor_availabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tutor_availabilityScalarFieldEnum | Tutor_availabilityScalarFieldEnum[]
  }

  /**
   * tutors.tutor_subjects
   */
  export type tutors$tutor_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutor_subjects
     */
    select?: tutor_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutor_subjects
     */
    omit?: tutor_subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutor_subjectsInclude<ExtArgs> | null
    where?: tutor_subjectsWhereInput
    orderBy?: tutor_subjectsOrderByWithRelationInput | tutor_subjectsOrderByWithRelationInput[]
    cursor?: tutor_subjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tutor_subjectsScalarFieldEnum | Tutor_subjectsScalarFieldEnum[]
  }

  /**
   * tutors without action
   */
  export type tutorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: number | null
    email: string | null
    password_hash: string | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    date_of_birth: Date | null
    profile_picture: string | null
    bio: string | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: number | null
    email: string | null
    password_hash: string | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    date_of_birth: Date | null
    profile_picture: string | null
    bio: string | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    email: number
    password_hash: number
    first_name: number
    last_name: number
    phone: number
    date_of_birth: number
    profile_picture: number
    bio: number
    created_at: number
    updated_at: number
    is_active: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_id?: true
  }

  export type UsersSumAggregateInputType = {
    user_id?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    phone?: true
    date_of_birth?: true
    profile_picture?: true
    bio?: true
    created_at?: true
    updated_at?: true
    is_active?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    phone?: true
    date_of_birth?: true
    profile_picture?: true
    bio?: true
    created_at?: true
    updated_at?: true
    is_active?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    phone?: true
    date_of_birth?: true
    profile_picture?: true
    bio?: true
    created_at?: true
    updated_at?: true
    is_active?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone: string | null
    date_of_birth: Date | null
    profile_picture: string | null
    bio: string | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    date_of_birth?: boolean
    profile_picture?: boolean
    bio?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
    messages_messages_sender_idTousers?: boolean | users$messages_messages_sender_idTousersArgs<ExtArgs>
    messages_messages_recipient_idTousers?: boolean | users$messages_messages_recipient_idTousersArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    resources?: boolean | users$resourcesArgs<ExtArgs>
    session_notes?: boolean | users$session_notesArgs<ExtArgs>
    students?: boolean | users$studentsArgs<ExtArgs>
    tutors?: boolean | users$tutorsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    user_id?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    date_of_birth?: boolean
    profile_picture?: boolean
    bio?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "email" | "password_hash" | "first_name" | "last_name" | "phone" | "date_of_birth" | "profile_picture" | "bio" | "created_at" | "updated_at" | "is_active", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages_messages_sender_idTousers?: boolean | users$messages_messages_sender_idTousersArgs<ExtArgs>
    messages_messages_recipient_idTousers?: boolean | users$messages_messages_recipient_idTousersArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    resources?: boolean | users$resourcesArgs<ExtArgs>
    session_notes?: boolean | users$session_notesArgs<ExtArgs>
    students?: boolean | users$studentsArgs<ExtArgs>
    tutors?: boolean | users$tutorsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      messages_messages_sender_idTousers: Prisma.$messagesPayload<ExtArgs>[]
      messages_messages_recipient_idTousers: Prisma.$messagesPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      resources: Prisma.$resourcesPayload<ExtArgs>[]
      session_notes: Prisma.$session_notesPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs> | null
      tutors: Prisma.$tutorsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      email: string
      password_hash: string
      first_name: string
      last_name: string
      phone: string | null
      date_of_birth: Date | null
      profile_picture: string | null
      bio: string | null
      created_at: Date | null
      updated_at: Date | null
      is_active: boolean | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages_messages_sender_idTousers<T extends users$messages_messages_sender_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$messages_messages_sender_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages_messages_recipient_idTousers<T extends users$messages_messages_recipient_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$messages_messages_recipient_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends users$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, users$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$resourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session_notes<T extends users$session_notesArgs<ExtArgs> = {}>(args?: Subset<T, users$session_notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends users$studentsArgs<ExtArgs> = {}>(args?: Subset<T, users$studentsArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutors<T extends users$tutorsArgs<ExtArgs> = {}>(args?: Subset<T, users$tutorsArgs<ExtArgs>>): Prisma__tutorsClient<$Result.GetResult<Prisma.$tutorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'Int'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly date_of_birth: FieldRef<"users", 'DateTime'>
    readonly profile_picture: FieldRef<"users", 'String'>
    readonly bio: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly is_active: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.messages_messages_sender_idTousers
   */
  export type users$messages_messages_sender_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * users.messages_messages_recipient_idTousers
   */
  export type users$messages_messages_recipient_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.resources
   */
  export type users$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the resources
     */
    select?: resourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the resources
     */
    omit?: resourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: resourcesInclude<ExtArgs> | null
    where?: resourcesWhereInput
    orderBy?: resourcesOrderByWithRelationInput | resourcesOrderByWithRelationInput[]
    cursor?: resourcesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourcesScalarFieldEnum | ResourcesScalarFieldEnum[]
  }

  /**
   * users.session_notes
   */
  export type users$session_notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_notes
     */
    select?: session_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_notes
     */
    omit?: session_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_notesInclude<ExtArgs> | null
    where?: session_notesWhereInput
    orderBy?: session_notesOrderByWithRelationInput | session_notesOrderByWithRelationInput[]
    cursor?: session_notesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_notesScalarFieldEnum | Session_notesScalarFieldEnum[]
  }

  /**
   * users.students
   */
  export type users$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * users.tutors
   */
  export type users$tutorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutors
     */
    select?: tutorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tutors
     */
    omit?: tutorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tutorsInclude<ExtArgs> | null
    where?: tutorsWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Group_session_participantsScalarFieldEnum: {
    participation_id: 'participation_id',
    group_session_id: 'group_session_id',
    student_id: 'student_id',
    registration_time: 'registration_time',
    payment_status: 'payment_status',
    attended: 'attended'
  };

  export type Group_session_participantsScalarFieldEnum = (typeof Group_session_participantsScalarFieldEnum)[keyof typeof Group_session_participantsScalarFieldEnum]


  export const Group_sessionsScalarFieldEnum: {
    group_session_id: 'group_session_id',
    tutor_id: 'tutor_id',
    subject_id: 'subject_id',
    title: 'title',
    description: 'description',
    start_time: 'start_time',
    end_time: 'end_time',
    max_participants: 'max_participants',
    current_participants: 'current_participants',
    price_per_student: 'price_per_student',
    meeting_url: 'meeting_url',
    status: 'status',
    created_at: 'created_at'
  };

  export type Group_sessionsScalarFieldEnum = (typeof Group_sessionsScalarFieldEnum)[keyof typeof Group_sessionsScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    message_id: 'message_id',
    sender_id: 'sender_id',
    recipient_id: 'recipient_id',
    content: 'content',
    sent_at: 'sent_at',
    read_at: 'read_at',
    attachment_url: 'attachment_url'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    notification_id: 'notification_id',
    user_id: 'user_id',
    title: 'title',
    content: 'content',
    notification_type: 'notification_type',
    related_id: 'related_id',
    created_at: 'created_at',
    read_at: 'read_at',
    is_read: 'is_read'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    payment_id: 'payment_id',
    session_id: 'session_id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    status: 'status',
    platform_fee: 'platform_fee',
    tutor_payout: 'tutor_payout',
    payout_date: 'payout_date',
    refund_amount: 'refund_amount',
    refund_date: 'refund_date',
    refund_reason: 'refund_reason'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const ResourcesScalarFieldEnum: {
    resource_id: 'resource_id',
    title: 'title',
    description: 'description',
    url: 'url',
    file_path: 'file_path',
    subject_id: 'subject_id',
    uploaded_by: 'uploaded_by',
    resource_type: 'resource_type',
    is_public: 'is_public',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ResourcesScalarFieldEnum = (typeof ResourcesScalarFieldEnum)[keyof typeof ResourcesScalarFieldEnum]


  export const Session_notesScalarFieldEnum: {
    note_id: 'note_id',
    session_id: 'session_id',
    author_id: 'author_id',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_private: 'is_private'
  };

  export type Session_notesScalarFieldEnum = (typeof Session_notesScalarFieldEnum)[keyof typeof Session_notesScalarFieldEnum]


  export const Session_ratingsScalarFieldEnum: {
    rating_id: 'rating_id',
    session_id: 'session_id',
    student_id: 'student_id',
    tutor_id: 'tutor_id',
    rating: 'rating',
    feedback: 'feedback',
    created_at: 'created_at'
  };

  export type Session_ratingsScalarFieldEnum = (typeof Session_ratingsScalarFieldEnum)[keyof typeof Session_ratingsScalarFieldEnum]


  export const Session_resourcesScalarFieldEnum: {
    session_resource_id: 'session_resource_id',
    session_id: 'session_id',
    resource_id: 'resource_id'
  };

  export type Session_resourcesScalarFieldEnum = (typeof Session_resourcesScalarFieldEnum)[keyof typeof Session_resourcesScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    session_id: 'session_id',
    tutor_id: 'tutor_id',
    student_id: 'student_id',
    subject_id: 'subject_id',
    start_time: 'start_time',
    end_time: 'end_time',
    duration_minutes: 'duration_minutes',
    hourly_rate: 'hourly_rate',
    session_cost: 'session_cost',
    status: 'status',
    meeting_url: 'meeting_url',
    notes: 'notes',
    materials_url: 'materials_url',
    created_at: 'created_at',
    canceled_at: 'canceled_at',
    cancellation_reason: 'cancellation_reason',
    cancellation_fee: 'cancellation_fee'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const Student_subject_interestsScalarFieldEnum: {
    interest_id: 'interest_id',
    student_id: 'student_id',
    subject_id: 'subject_id',
    interest_level: 'interest_level'
  };

  export type Student_subject_interestsScalarFieldEnum = (typeof Student_subject_interestsScalarFieldEnum)[keyof typeof Student_subject_interestsScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    student_id: 'student_id',
    user_id: 'user_id',
    education_level: 'education_level',
    grade_year: 'grade_year',
    parent_guardian_name: 'parent_guardian_name',
    parent_guardian_email: 'parent_guardian_email',
    parent_guardian_phone: 'parent_guardian_phone',
    special_needs: 'special_needs',
    learning_preferences: 'learning_preferences'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const Subject_categoriesScalarFieldEnum: {
    category_id: 'category_id',
    name: 'name',
    description: 'description'
  };

  export type Subject_categoriesScalarFieldEnum = (typeof Subject_categoriesScalarFieldEnum)[keyof typeof Subject_categoriesScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    subject_id: 'subject_id',
    category_id: 'category_id',
    name: 'name',
    description: 'description',
    difficulty_level: 'difficulty_level'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    subscription_id: 'subscription_id',
    student_id: 'student_id',
    plan_name: 'plan_name',
    description: 'description',
    price: 'price',
    billing_cycle: 'billing_cycle',
    sessions_included: 'sessions_included',
    hours_included: 'hours_included',
    start_date: 'start_date',
    end_date: 'end_date',
    is_active: 'is_active',
    auto_renew: 'auto_renew',
    payment_method: 'payment_method',
    last_billing_date: 'last_billing_date',
    next_billing_date: 'next_billing_date'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const Tutor_availabilityScalarFieldEnum: {
    availability_id: 'availability_id',
    tutor_id: 'tutor_id',
    day_of_week: 'day_of_week',
    start_time: 'start_time',
    end_time: 'end_time',
    is_recurring: 'is_recurring',
    specific_date: 'specific_date'
  };

  export type Tutor_availabilityScalarFieldEnum = (typeof Tutor_availabilityScalarFieldEnum)[keyof typeof Tutor_availabilityScalarFieldEnum]


  export const Tutor_subjectsScalarFieldEnum: {
    tutor_subject_id: 'tutor_subject_id',
    tutor_id: 'tutor_id',
    subject_id: 'subject_id',
    proficiency_level: 'proficiency_level',
    verified: 'verified'
  };

  export type Tutor_subjectsScalarFieldEnum = (typeof Tutor_subjectsScalarFieldEnum)[keyof typeof Tutor_subjectsScalarFieldEnum]


  export const TutorsScalarFieldEnum: {
    tutor_id: 'tutor_id',
    user_id: 'user_id',
    hourly_rate: 'hourly_rate',
    experience_years: 'experience_years',
    qualification: 'qualification',
    background_check_status: 'background_check_status',
    background_check_date: 'background_check_date',
    avg_rating: 'avg_rating',
    total_sessions: 'total_sessions',
    is_verified: 'is_verified',
    verification_date: 'verification_date',
    payment_details: 'payment_details'
  };

  export type TutorsScalarFieldEnum = (typeof TutorsScalarFieldEnum)[keyof typeof TutorsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    email: 'email',
    password_hash: 'password_hash',
    first_name: 'first_name',
    last_name: 'last_name',
    phone: 'phone',
    date_of_birth: 'date_of_birth',
    profile_picture: 'profile_picture',
    bio: 'bio',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_active: 'is_active'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const group_session_participantsOrderByRelevanceFieldEnum: {
    payment_status: 'payment_status'
  };

  export type group_session_participantsOrderByRelevanceFieldEnum = (typeof group_session_participantsOrderByRelevanceFieldEnum)[keyof typeof group_session_participantsOrderByRelevanceFieldEnum]


  export const group_sessionsOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    meeting_url: 'meeting_url',
    status: 'status'
  };

  export type group_sessionsOrderByRelevanceFieldEnum = (typeof group_sessionsOrderByRelevanceFieldEnum)[keyof typeof group_sessionsOrderByRelevanceFieldEnum]


  export const messagesOrderByRelevanceFieldEnum: {
    content: 'content',
    attachment_url: 'attachment_url'
  };

  export type messagesOrderByRelevanceFieldEnum = (typeof messagesOrderByRelevanceFieldEnum)[keyof typeof messagesOrderByRelevanceFieldEnum]


  export const notificationsOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    notification_type: 'notification_type'
  };

  export type notificationsOrderByRelevanceFieldEnum = (typeof notificationsOrderByRelevanceFieldEnum)[keyof typeof notificationsOrderByRelevanceFieldEnum]


  export const paymentsOrderByRelevanceFieldEnum: {
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    status: 'status',
    refund_reason: 'refund_reason'
  };

  export type paymentsOrderByRelevanceFieldEnum = (typeof paymentsOrderByRelevanceFieldEnum)[keyof typeof paymentsOrderByRelevanceFieldEnum]


  export const resourcesOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    url: 'url',
    file_path: 'file_path',
    resource_type: 'resource_type'
  };

  export type resourcesOrderByRelevanceFieldEnum = (typeof resourcesOrderByRelevanceFieldEnum)[keyof typeof resourcesOrderByRelevanceFieldEnum]


  export const session_notesOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type session_notesOrderByRelevanceFieldEnum = (typeof session_notesOrderByRelevanceFieldEnum)[keyof typeof session_notesOrderByRelevanceFieldEnum]


  export const session_ratingsOrderByRelevanceFieldEnum: {
    feedback: 'feedback'
  };

  export type session_ratingsOrderByRelevanceFieldEnum = (typeof session_ratingsOrderByRelevanceFieldEnum)[keyof typeof session_ratingsOrderByRelevanceFieldEnum]


  export const sessionsOrderByRelevanceFieldEnum: {
    status: 'status',
    meeting_url: 'meeting_url',
    notes: 'notes',
    materials_url: 'materials_url',
    cancellation_reason: 'cancellation_reason'
  };

  export type sessionsOrderByRelevanceFieldEnum = (typeof sessionsOrderByRelevanceFieldEnum)[keyof typeof sessionsOrderByRelevanceFieldEnum]


  export const student_subject_interestsOrderByRelevanceFieldEnum: {
    interest_level: 'interest_level'
  };

  export type student_subject_interestsOrderByRelevanceFieldEnum = (typeof student_subject_interestsOrderByRelevanceFieldEnum)[keyof typeof student_subject_interestsOrderByRelevanceFieldEnum]


  export const studentsOrderByRelevanceFieldEnum: {
    education_level: 'education_level',
    grade_year: 'grade_year',
    parent_guardian_name: 'parent_guardian_name',
    parent_guardian_email: 'parent_guardian_email',
    parent_guardian_phone: 'parent_guardian_phone',
    special_needs: 'special_needs',
    learning_preferences: 'learning_preferences'
  };

  export type studentsOrderByRelevanceFieldEnum = (typeof studentsOrderByRelevanceFieldEnum)[keyof typeof studentsOrderByRelevanceFieldEnum]


  export const subject_categoriesOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type subject_categoriesOrderByRelevanceFieldEnum = (typeof subject_categoriesOrderByRelevanceFieldEnum)[keyof typeof subject_categoriesOrderByRelevanceFieldEnum]


  export const subjectsOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    difficulty_level: 'difficulty_level'
  };

  export type subjectsOrderByRelevanceFieldEnum = (typeof subjectsOrderByRelevanceFieldEnum)[keyof typeof subjectsOrderByRelevanceFieldEnum]


  export const subscriptionsOrderByRelevanceFieldEnum: {
    plan_name: 'plan_name',
    description: 'description',
    billing_cycle: 'billing_cycle',
    payment_method: 'payment_method'
  };

  export type subscriptionsOrderByRelevanceFieldEnum = (typeof subscriptionsOrderByRelevanceFieldEnum)[keyof typeof subscriptionsOrderByRelevanceFieldEnum]


  export const tutor_subjectsOrderByRelevanceFieldEnum: {
    proficiency_level: 'proficiency_level'
  };

  export type tutor_subjectsOrderByRelevanceFieldEnum = (typeof tutor_subjectsOrderByRelevanceFieldEnum)[keyof typeof tutor_subjectsOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const tutorsOrderByRelevanceFieldEnum: {
    qualification: 'qualification',
    background_check_status: 'background_check_status'
  };

  export type tutorsOrderByRelevanceFieldEnum = (typeof tutorsOrderByRelevanceFieldEnum)[keyof typeof tutorsOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    email: 'email',
    password_hash: 'password_hash',
    first_name: 'first_name',
    last_name: 'last_name',
    phone: 'phone',
    profile_picture: 'profile_picture',
    bio: 'bio'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type group_session_participantsWhereInput = {
    AND?: group_session_participantsWhereInput | group_session_participantsWhereInput[]
    OR?: group_session_participantsWhereInput[]
    NOT?: group_session_participantsWhereInput | group_session_participantsWhereInput[]
    participation_id?: IntFilter<"group_session_participants"> | number
    group_session_id?: IntFilter<"group_session_participants"> | number
    student_id?: IntFilter<"group_session_participants"> | number
    registration_time?: DateTimeNullableFilter<"group_session_participants"> | Date | string | null
    payment_status?: StringNullableFilter<"group_session_participants"> | string | null
    attended?: BoolNullableFilter<"group_session_participants"> | boolean | null
    group_sessions?: XOR<Group_sessionsScalarRelationFilter, group_sessionsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type group_session_participantsOrderByWithRelationInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
    registration_time?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    attended?: SortOrderInput | SortOrder
    group_sessions?: group_sessionsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
    _relevance?: group_session_participantsOrderByRelevanceInput
  }

  export type group_session_participantsWhereUniqueInput = Prisma.AtLeast<{
    participation_id?: number
    group_session_id_student_id?: group_session_participantsGroup_session_idStudent_idCompoundUniqueInput
    AND?: group_session_participantsWhereInput | group_session_participantsWhereInput[]
    OR?: group_session_participantsWhereInput[]
    NOT?: group_session_participantsWhereInput | group_session_participantsWhereInput[]
    group_session_id?: IntFilter<"group_session_participants"> | number
    student_id?: IntFilter<"group_session_participants"> | number
    registration_time?: DateTimeNullableFilter<"group_session_participants"> | Date | string | null
    payment_status?: StringNullableFilter<"group_session_participants"> | string | null
    attended?: BoolNullableFilter<"group_session_participants"> | boolean | null
    group_sessions?: XOR<Group_sessionsScalarRelationFilter, group_sessionsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "participation_id" | "group_session_id_student_id">

  export type group_session_participantsOrderByWithAggregationInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
    registration_time?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    attended?: SortOrderInput | SortOrder
    _count?: group_session_participantsCountOrderByAggregateInput
    _avg?: group_session_participantsAvgOrderByAggregateInput
    _max?: group_session_participantsMaxOrderByAggregateInput
    _min?: group_session_participantsMinOrderByAggregateInput
    _sum?: group_session_participantsSumOrderByAggregateInput
  }

  export type group_session_participantsScalarWhereWithAggregatesInput = {
    AND?: group_session_participantsScalarWhereWithAggregatesInput | group_session_participantsScalarWhereWithAggregatesInput[]
    OR?: group_session_participantsScalarWhereWithAggregatesInput[]
    NOT?: group_session_participantsScalarWhereWithAggregatesInput | group_session_participantsScalarWhereWithAggregatesInput[]
    participation_id?: IntWithAggregatesFilter<"group_session_participants"> | number
    group_session_id?: IntWithAggregatesFilter<"group_session_participants"> | number
    student_id?: IntWithAggregatesFilter<"group_session_participants"> | number
    registration_time?: DateTimeNullableWithAggregatesFilter<"group_session_participants"> | Date | string | null
    payment_status?: StringNullableWithAggregatesFilter<"group_session_participants"> | string | null
    attended?: BoolNullableWithAggregatesFilter<"group_session_participants"> | boolean | null
  }

  export type group_sessionsWhereInput = {
    AND?: group_sessionsWhereInput | group_sessionsWhereInput[]
    OR?: group_sessionsWhereInput[]
    NOT?: group_sessionsWhereInput | group_sessionsWhereInput[]
    group_session_id?: IntFilter<"group_sessions"> | number
    tutor_id?: IntFilter<"group_sessions"> | number
    subject_id?: IntFilter<"group_sessions"> | number
    title?: StringFilter<"group_sessions"> | string
    description?: StringNullableFilter<"group_sessions"> | string | null
    start_time?: DateTimeFilter<"group_sessions"> | Date | string
    end_time?: DateTimeFilter<"group_sessions"> | Date | string
    max_participants?: IntFilter<"group_sessions"> | number
    current_participants?: IntNullableFilter<"group_sessions"> | number | null
    price_per_student?: DecimalFilter<"group_sessions"> | Decimal | DecimalJsLike | number | string
    meeting_url?: StringNullableFilter<"group_sessions"> | string | null
    status?: StringFilter<"group_sessions"> | string
    created_at?: DateTimeNullableFilter<"group_sessions"> | Date | string | null
    group_session_participants?: Group_session_participantsListRelationFilter
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }

  export type group_sessionsOrderByWithRelationInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrderInput | SortOrder
    price_per_student?: SortOrder
    meeting_url?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    group_session_participants?: group_session_participantsOrderByRelationAggregateInput
    tutors?: tutorsOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    _relevance?: group_sessionsOrderByRelevanceInput
  }

  export type group_sessionsWhereUniqueInput = Prisma.AtLeast<{
    group_session_id?: number
    AND?: group_sessionsWhereInput | group_sessionsWhereInput[]
    OR?: group_sessionsWhereInput[]
    NOT?: group_sessionsWhereInput | group_sessionsWhereInput[]
    tutor_id?: IntFilter<"group_sessions"> | number
    subject_id?: IntFilter<"group_sessions"> | number
    title?: StringFilter<"group_sessions"> | string
    description?: StringNullableFilter<"group_sessions"> | string | null
    start_time?: DateTimeFilter<"group_sessions"> | Date | string
    end_time?: DateTimeFilter<"group_sessions"> | Date | string
    max_participants?: IntFilter<"group_sessions"> | number
    current_participants?: IntNullableFilter<"group_sessions"> | number | null
    price_per_student?: DecimalFilter<"group_sessions"> | Decimal | DecimalJsLike | number | string
    meeting_url?: StringNullableFilter<"group_sessions"> | string | null
    status?: StringFilter<"group_sessions"> | string
    created_at?: DateTimeNullableFilter<"group_sessions"> | Date | string | null
    group_session_participants?: Group_session_participantsListRelationFilter
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }, "group_session_id">

  export type group_sessionsOrderByWithAggregationInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrderInput | SortOrder
    price_per_student?: SortOrder
    meeting_url?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: group_sessionsCountOrderByAggregateInput
    _avg?: group_sessionsAvgOrderByAggregateInput
    _max?: group_sessionsMaxOrderByAggregateInput
    _min?: group_sessionsMinOrderByAggregateInput
    _sum?: group_sessionsSumOrderByAggregateInput
  }

  export type group_sessionsScalarWhereWithAggregatesInput = {
    AND?: group_sessionsScalarWhereWithAggregatesInput | group_sessionsScalarWhereWithAggregatesInput[]
    OR?: group_sessionsScalarWhereWithAggregatesInput[]
    NOT?: group_sessionsScalarWhereWithAggregatesInput | group_sessionsScalarWhereWithAggregatesInput[]
    group_session_id?: IntWithAggregatesFilter<"group_sessions"> | number
    tutor_id?: IntWithAggregatesFilter<"group_sessions"> | number
    subject_id?: IntWithAggregatesFilter<"group_sessions"> | number
    title?: StringWithAggregatesFilter<"group_sessions"> | string
    description?: StringNullableWithAggregatesFilter<"group_sessions"> | string | null
    start_time?: DateTimeWithAggregatesFilter<"group_sessions"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"group_sessions"> | Date | string
    max_participants?: IntWithAggregatesFilter<"group_sessions"> | number
    current_participants?: IntNullableWithAggregatesFilter<"group_sessions"> | number | null
    price_per_student?: DecimalWithAggregatesFilter<"group_sessions"> | Decimal | DecimalJsLike | number | string
    meeting_url?: StringNullableWithAggregatesFilter<"group_sessions"> | string | null
    status?: StringWithAggregatesFilter<"group_sessions"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"group_sessions"> | Date | string | null
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    message_id?: IntFilter<"messages"> | number
    sender_id?: IntFilter<"messages"> | number
    recipient_id?: IntFilter<"messages"> | number
    content?: StringFilter<"messages"> | string
    sent_at?: DateTimeNullableFilter<"messages"> | Date | string | null
    read_at?: DateTimeNullableFilter<"messages"> | Date | string | null
    attachment_url?: StringNullableFilter<"messages"> | string | null
    users_messages_sender_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_messages_recipient_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type messagesOrderByWithRelationInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
    content?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    attachment_url?: SortOrderInput | SortOrder
    users_messages_sender_idTousers?: usersOrderByWithRelationInput
    users_messages_recipient_idTousers?: usersOrderByWithRelationInput
    _relevance?: messagesOrderByRelevanceInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    message_id?: number
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    sender_id?: IntFilter<"messages"> | number
    recipient_id?: IntFilter<"messages"> | number
    content?: StringFilter<"messages"> | string
    sent_at?: DateTimeNullableFilter<"messages"> | Date | string | null
    read_at?: DateTimeNullableFilter<"messages"> | Date | string | null
    attachment_url?: StringNullableFilter<"messages"> | string | null
    users_messages_sender_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_messages_recipient_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "message_id">

  export type messagesOrderByWithAggregationInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
    content?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    attachment_url?: SortOrderInput | SortOrder
    _count?: messagesCountOrderByAggregateInput
    _avg?: messagesAvgOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
    _sum?: messagesSumOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    message_id?: IntWithAggregatesFilter<"messages"> | number
    sender_id?: IntWithAggregatesFilter<"messages"> | number
    recipient_id?: IntWithAggregatesFilter<"messages"> | number
    content?: StringWithAggregatesFilter<"messages"> | string
    sent_at?: DateTimeNullableWithAggregatesFilter<"messages"> | Date | string | null
    read_at?: DateTimeNullableWithAggregatesFilter<"messages"> | Date | string | null
    attachment_url?: StringNullableWithAggregatesFilter<"messages"> | string | null
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    notification_id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    notification_type?: StringFilter<"notifications"> | string
    related_id?: IntNullableFilter<"notifications"> | number | null
    created_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    is_read?: BoolNullableFilter<"notifications"> | boolean | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    notification_type?: SortOrder
    related_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: notificationsOrderByRelevanceInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    notification_id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    notification_type?: StringFilter<"notifications"> | string
    related_id?: IntNullableFilter<"notifications"> | number | null
    created_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    is_read?: BoolNullableFilter<"notifications"> | boolean | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "notification_id">

  export type notificationsOrderByWithAggregationInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    notification_type?: SortOrder
    related_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    notification_id?: IntWithAggregatesFilter<"notifications"> | number
    user_id?: IntWithAggregatesFilter<"notifications"> | number
    title?: StringWithAggregatesFilter<"notifications"> | string
    content?: StringWithAggregatesFilter<"notifications"> | string
    notification_type?: StringWithAggregatesFilter<"notifications"> | string
    related_id?: IntNullableWithAggregatesFilter<"notifications"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    is_read?: BoolNullableWithAggregatesFilter<"notifications"> | boolean | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    payment_id?: IntFilter<"payments"> | number
    session_id?: IntFilter<"payments"> | number
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    payment_method?: StringFilter<"payments"> | string
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: StringFilter<"payments"> | string
    platform_fee?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payout_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_reason?: StringNullableFilter<"payments"> | string | null
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrderInput | SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    payout_date?: SortOrderInput | SortOrder
    refund_amount?: SortOrderInput | SortOrder
    refund_date?: SortOrderInput | SortOrder
    refund_reason?: SortOrderInput | SortOrder
    sessions?: sessionsOrderByWithRelationInput
    _relevance?: paymentsOrderByRelevanceInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    payment_id?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    session_id?: IntFilter<"payments"> | number
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    payment_method?: StringFilter<"payments"> | string
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: StringFilter<"payments"> | string
    platform_fee?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payout_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_reason?: StringNullableFilter<"payments"> | string | null
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
  }, "payment_id">

  export type paymentsOrderByWithAggregationInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrderInput | SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    payout_date?: SortOrderInput | SortOrder
    refund_amount?: SortOrderInput | SortOrder
    refund_date?: SortOrderInput | SortOrder
    refund_reason?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    payment_id?: IntWithAggregatesFilter<"payments"> | number
    session_id?: IntWithAggregatesFilter<"payments"> | number
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    payment_method?: StringWithAggregatesFilter<"payments"> | string
    transaction_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    status?: StringWithAggregatesFilter<"payments"> | string
    platform_fee?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payout_date?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_date?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    refund_reason?: StringNullableWithAggregatesFilter<"payments"> | string | null
  }

  export type resourcesWhereInput = {
    AND?: resourcesWhereInput | resourcesWhereInput[]
    OR?: resourcesWhereInput[]
    NOT?: resourcesWhereInput | resourcesWhereInput[]
    resource_id?: IntFilter<"resources"> | number
    title?: StringFilter<"resources"> | string
    description?: StringNullableFilter<"resources"> | string | null
    url?: StringNullableFilter<"resources"> | string | null
    file_path?: StringNullableFilter<"resources"> | string | null
    subject_id?: IntNullableFilter<"resources"> | number | null
    uploaded_by?: IntFilter<"resources"> | number
    resource_type?: StringFilter<"resources"> | string
    is_public?: BoolNullableFilter<"resources"> | boolean | null
    created_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    subjects?: XOR<SubjectsNullableScalarRelationFilter, subjectsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    session_resources?: Session_resourcesListRelationFilter
  }

  export type resourcesOrderByWithRelationInput = {
    resource_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    subject_id?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    resource_type?: SortOrder
    is_public?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    subjects?: subjectsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    session_resources?: session_resourcesOrderByRelationAggregateInput
    _relevance?: resourcesOrderByRelevanceInput
  }

  export type resourcesWhereUniqueInput = Prisma.AtLeast<{
    resource_id?: number
    AND?: resourcesWhereInput | resourcesWhereInput[]
    OR?: resourcesWhereInput[]
    NOT?: resourcesWhereInput | resourcesWhereInput[]
    title?: StringFilter<"resources"> | string
    description?: StringNullableFilter<"resources"> | string | null
    url?: StringNullableFilter<"resources"> | string | null
    file_path?: StringNullableFilter<"resources"> | string | null
    subject_id?: IntNullableFilter<"resources"> | number | null
    uploaded_by?: IntFilter<"resources"> | number
    resource_type?: StringFilter<"resources"> | string
    is_public?: BoolNullableFilter<"resources"> | boolean | null
    created_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    subjects?: XOR<SubjectsNullableScalarRelationFilter, subjectsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    session_resources?: Session_resourcesListRelationFilter
  }, "resource_id">

  export type resourcesOrderByWithAggregationInput = {
    resource_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    subject_id?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    resource_type?: SortOrder
    is_public?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: resourcesCountOrderByAggregateInput
    _avg?: resourcesAvgOrderByAggregateInput
    _max?: resourcesMaxOrderByAggregateInput
    _min?: resourcesMinOrderByAggregateInput
    _sum?: resourcesSumOrderByAggregateInput
  }

  export type resourcesScalarWhereWithAggregatesInput = {
    AND?: resourcesScalarWhereWithAggregatesInput | resourcesScalarWhereWithAggregatesInput[]
    OR?: resourcesScalarWhereWithAggregatesInput[]
    NOT?: resourcesScalarWhereWithAggregatesInput | resourcesScalarWhereWithAggregatesInput[]
    resource_id?: IntWithAggregatesFilter<"resources"> | number
    title?: StringWithAggregatesFilter<"resources"> | string
    description?: StringNullableWithAggregatesFilter<"resources"> | string | null
    url?: StringNullableWithAggregatesFilter<"resources"> | string | null
    file_path?: StringNullableWithAggregatesFilter<"resources"> | string | null
    subject_id?: IntNullableWithAggregatesFilter<"resources"> | number | null
    uploaded_by?: IntWithAggregatesFilter<"resources"> | number
    resource_type?: StringWithAggregatesFilter<"resources"> | string
    is_public?: BoolNullableWithAggregatesFilter<"resources"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"resources"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"resources"> | Date | string | null
  }

  export type session_notesWhereInput = {
    AND?: session_notesWhereInput | session_notesWhereInput[]
    OR?: session_notesWhereInput[]
    NOT?: session_notesWhereInput | session_notesWhereInput[]
    note_id?: IntFilter<"session_notes"> | number
    session_id?: IntFilter<"session_notes"> | number
    author_id?: IntFilter<"session_notes"> | number
    content?: StringFilter<"session_notes"> | string
    created_at?: DateTimeNullableFilter<"session_notes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"session_notes"> | Date | string | null
    is_private?: BoolNullableFilter<"session_notes"> | boolean | null
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type session_notesOrderByWithRelationInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    is_private?: SortOrderInput | SortOrder
    sessions?: sessionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    _relevance?: session_notesOrderByRelevanceInput
  }

  export type session_notesWhereUniqueInput = Prisma.AtLeast<{
    note_id?: number
    AND?: session_notesWhereInput | session_notesWhereInput[]
    OR?: session_notesWhereInput[]
    NOT?: session_notesWhereInput | session_notesWhereInput[]
    session_id?: IntFilter<"session_notes"> | number
    author_id?: IntFilter<"session_notes"> | number
    content?: StringFilter<"session_notes"> | string
    created_at?: DateTimeNullableFilter<"session_notes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"session_notes"> | Date | string | null
    is_private?: BoolNullableFilter<"session_notes"> | boolean | null
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "note_id">

  export type session_notesOrderByWithAggregationInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    is_private?: SortOrderInput | SortOrder
    _count?: session_notesCountOrderByAggregateInput
    _avg?: session_notesAvgOrderByAggregateInput
    _max?: session_notesMaxOrderByAggregateInput
    _min?: session_notesMinOrderByAggregateInput
    _sum?: session_notesSumOrderByAggregateInput
  }

  export type session_notesScalarWhereWithAggregatesInput = {
    AND?: session_notesScalarWhereWithAggregatesInput | session_notesScalarWhereWithAggregatesInput[]
    OR?: session_notesScalarWhereWithAggregatesInput[]
    NOT?: session_notesScalarWhereWithAggregatesInput | session_notesScalarWhereWithAggregatesInput[]
    note_id?: IntWithAggregatesFilter<"session_notes"> | number
    session_id?: IntWithAggregatesFilter<"session_notes"> | number
    author_id?: IntWithAggregatesFilter<"session_notes"> | number
    content?: StringWithAggregatesFilter<"session_notes"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"session_notes"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"session_notes"> | Date | string | null
    is_private?: BoolNullableWithAggregatesFilter<"session_notes"> | boolean | null
  }

  export type session_ratingsWhereInput = {
    AND?: session_ratingsWhereInput | session_ratingsWhereInput[]
    OR?: session_ratingsWhereInput[]
    NOT?: session_ratingsWhereInput | session_ratingsWhereInput[]
    rating_id?: IntFilter<"session_ratings"> | number
    session_id?: IntFilter<"session_ratings"> | number
    student_id?: IntFilter<"session_ratings"> | number
    tutor_id?: IntFilter<"session_ratings"> | number
    rating?: DecimalFilter<"session_ratings"> | Decimal | DecimalJsLike | number | string
    feedback?: StringNullableFilter<"session_ratings"> | string | null
    created_at?: DateTimeNullableFilter<"session_ratings"> | Date | string | null
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
  }

  export type session_ratingsOrderByWithRelationInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    sessions?: sessionsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
    tutors?: tutorsOrderByWithRelationInput
    _relevance?: session_ratingsOrderByRelevanceInput
  }

  export type session_ratingsWhereUniqueInput = Prisma.AtLeast<{
    rating_id?: number
    session_id?: number
    AND?: session_ratingsWhereInput | session_ratingsWhereInput[]
    OR?: session_ratingsWhereInput[]
    NOT?: session_ratingsWhereInput | session_ratingsWhereInput[]
    student_id?: IntFilter<"session_ratings"> | number
    tutor_id?: IntFilter<"session_ratings"> | number
    rating?: DecimalFilter<"session_ratings"> | Decimal | DecimalJsLike | number | string
    feedback?: StringNullableFilter<"session_ratings"> | string | null
    created_at?: DateTimeNullableFilter<"session_ratings"> | Date | string | null
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
  }, "rating_id" | "session_id">

  export type session_ratingsOrderByWithAggregationInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: session_ratingsCountOrderByAggregateInput
    _avg?: session_ratingsAvgOrderByAggregateInput
    _max?: session_ratingsMaxOrderByAggregateInput
    _min?: session_ratingsMinOrderByAggregateInput
    _sum?: session_ratingsSumOrderByAggregateInput
  }

  export type session_ratingsScalarWhereWithAggregatesInput = {
    AND?: session_ratingsScalarWhereWithAggregatesInput | session_ratingsScalarWhereWithAggregatesInput[]
    OR?: session_ratingsScalarWhereWithAggregatesInput[]
    NOT?: session_ratingsScalarWhereWithAggregatesInput | session_ratingsScalarWhereWithAggregatesInput[]
    rating_id?: IntWithAggregatesFilter<"session_ratings"> | number
    session_id?: IntWithAggregatesFilter<"session_ratings"> | number
    student_id?: IntWithAggregatesFilter<"session_ratings"> | number
    tutor_id?: IntWithAggregatesFilter<"session_ratings"> | number
    rating?: DecimalWithAggregatesFilter<"session_ratings"> | Decimal | DecimalJsLike | number | string
    feedback?: StringNullableWithAggregatesFilter<"session_ratings"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"session_ratings"> | Date | string | null
  }

  export type session_resourcesWhereInput = {
    AND?: session_resourcesWhereInput | session_resourcesWhereInput[]
    OR?: session_resourcesWhereInput[]
    NOT?: session_resourcesWhereInput | session_resourcesWhereInput[]
    session_resource_id?: IntFilter<"session_resources"> | number
    session_id?: IntFilter<"session_resources"> | number
    resource_id?: IntFilter<"session_resources"> | number
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
    resources?: XOR<ResourcesScalarRelationFilter, resourcesWhereInput>
  }

  export type session_resourcesOrderByWithRelationInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
    sessions?: sessionsOrderByWithRelationInput
    resources?: resourcesOrderByWithRelationInput
  }

  export type session_resourcesWhereUniqueInput = Prisma.AtLeast<{
    session_resource_id?: number
    session_id_resource_id?: session_resourcesSession_idResource_idCompoundUniqueInput
    AND?: session_resourcesWhereInput | session_resourcesWhereInput[]
    OR?: session_resourcesWhereInput[]
    NOT?: session_resourcesWhereInput | session_resourcesWhereInput[]
    session_id?: IntFilter<"session_resources"> | number
    resource_id?: IntFilter<"session_resources"> | number
    sessions?: XOR<SessionsScalarRelationFilter, sessionsWhereInput>
    resources?: XOR<ResourcesScalarRelationFilter, resourcesWhereInput>
  }, "session_resource_id" | "session_id_resource_id">

  export type session_resourcesOrderByWithAggregationInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
    _count?: session_resourcesCountOrderByAggregateInput
    _avg?: session_resourcesAvgOrderByAggregateInput
    _max?: session_resourcesMaxOrderByAggregateInput
    _min?: session_resourcesMinOrderByAggregateInput
    _sum?: session_resourcesSumOrderByAggregateInput
  }

  export type session_resourcesScalarWhereWithAggregatesInput = {
    AND?: session_resourcesScalarWhereWithAggregatesInput | session_resourcesScalarWhereWithAggregatesInput[]
    OR?: session_resourcesScalarWhereWithAggregatesInput[]
    NOT?: session_resourcesScalarWhereWithAggregatesInput | session_resourcesScalarWhereWithAggregatesInput[]
    session_resource_id?: IntWithAggregatesFilter<"session_resources"> | number
    session_id?: IntWithAggregatesFilter<"session_resources"> | number
    resource_id?: IntWithAggregatesFilter<"session_resources"> | number
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    session_id?: IntFilter<"sessions"> | number
    tutor_id?: IntFilter<"sessions"> | number
    student_id?: IntFilter<"sessions"> | number
    subject_id?: IntFilter<"sessions"> | number
    start_time?: DateTimeFilter<"sessions"> | Date | string
    end_time?: DateTimeFilter<"sessions"> | Date | string
    duration_minutes?: IntNullableFilter<"sessions"> | number | null
    hourly_rate?: DecimalFilter<"sessions"> | Decimal | DecimalJsLike | number | string
    session_cost?: DecimalNullableFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"sessions"> | string
    meeting_url?: StringNullableFilter<"sessions"> | string | null
    notes?: StringNullableFilter<"sessions"> | string | null
    materials_url?: StringNullableFilter<"sessions"> | string | null
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    canceled_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"sessions"> | string | null
    cancellation_fee?: DecimalNullableFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
    payments?: PaymentsListRelationFilter
    session_notes?: Session_notesListRelationFilter
    session_ratings?: XOR<Session_ratingsNullableScalarRelationFilter, session_ratingsWhereInput> | null
    session_resources?: Session_resourcesListRelationFilter
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrderInput | SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrderInput | SortOrder
    status?: SortOrder
    meeting_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    materials_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    canceled_at?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    cancellation_fee?: SortOrderInput | SortOrder
    payments?: paymentsOrderByRelationAggregateInput
    session_notes?: session_notesOrderByRelationAggregateInput
    session_ratings?: session_ratingsOrderByWithRelationInput
    session_resources?: session_resourcesOrderByRelationAggregateInput
    tutors?: tutorsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    _relevance?: sessionsOrderByRelevanceInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    session_id?: number
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    tutor_id?: IntFilter<"sessions"> | number
    student_id?: IntFilter<"sessions"> | number
    subject_id?: IntFilter<"sessions"> | number
    start_time?: DateTimeFilter<"sessions"> | Date | string
    end_time?: DateTimeFilter<"sessions"> | Date | string
    duration_minutes?: IntNullableFilter<"sessions"> | number | null
    hourly_rate?: DecimalFilter<"sessions"> | Decimal | DecimalJsLike | number | string
    session_cost?: DecimalNullableFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"sessions"> | string
    meeting_url?: StringNullableFilter<"sessions"> | string | null
    notes?: StringNullableFilter<"sessions"> | string | null
    materials_url?: StringNullableFilter<"sessions"> | string | null
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    canceled_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"sessions"> | string | null
    cancellation_fee?: DecimalNullableFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
    payments?: PaymentsListRelationFilter
    session_notes?: Session_notesListRelationFilter
    session_ratings?: XOR<Session_ratingsNullableScalarRelationFilter, session_ratingsWhereInput> | null
    session_resources?: Session_resourcesListRelationFilter
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }, "session_id">

  export type sessionsOrderByWithAggregationInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrderInput | SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrderInput | SortOrder
    status?: SortOrder
    meeting_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    materials_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    canceled_at?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    cancellation_fee?: SortOrderInput | SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    session_id?: IntWithAggregatesFilter<"sessions"> | number
    tutor_id?: IntWithAggregatesFilter<"sessions"> | number
    student_id?: IntWithAggregatesFilter<"sessions"> | number
    subject_id?: IntWithAggregatesFilter<"sessions"> | number
    start_time?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    duration_minutes?: IntNullableWithAggregatesFilter<"sessions"> | number | null
    hourly_rate?: DecimalWithAggregatesFilter<"sessions"> | Decimal | DecimalJsLike | number | string
    session_cost?: DecimalNullableWithAggregatesFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"sessions"> | string
    meeting_url?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    notes?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    materials_url?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    canceled_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    cancellation_reason?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    cancellation_fee?: DecimalNullableWithAggregatesFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsWhereInput = {
    AND?: student_subject_interestsWhereInput | student_subject_interestsWhereInput[]
    OR?: student_subject_interestsWhereInput[]
    NOT?: student_subject_interestsWhereInput | student_subject_interestsWhereInput[]
    interest_id?: IntFilter<"student_subject_interests"> | number
    student_id?: IntFilter<"student_subject_interests"> | number
    subject_id?: IntFilter<"student_subject_interests"> | number
    interest_level?: StringNullableFilter<"student_subject_interests"> | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }

  export type student_subject_interestsOrderByWithRelationInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    interest_level?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    _relevance?: student_subject_interestsOrderByRelevanceInput
  }

  export type student_subject_interestsWhereUniqueInput = Prisma.AtLeast<{
    interest_id?: number
    student_id_subject_id?: student_subject_interestsStudent_idSubject_idCompoundUniqueInput
    AND?: student_subject_interestsWhereInput | student_subject_interestsWhereInput[]
    OR?: student_subject_interestsWhereInput[]
    NOT?: student_subject_interestsWhereInput | student_subject_interestsWhereInput[]
    student_id?: IntFilter<"student_subject_interests"> | number
    subject_id?: IntFilter<"student_subject_interests"> | number
    interest_level?: StringNullableFilter<"student_subject_interests"> | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }, "interest_id" | "student_id_subject_id">

  export type student_subject_interestsOrderByWithAggregationInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    interest_level?: SortOrderInput | SortOrder
    _count?: student_subject_interestsCountOrderByAggregateInput
    _avg?: student_subject_interestsAvgOrderByAggregateInput
    _max?: student_subject_interestsMaxOrderByAggregateInput
    _min?: student_subject_interestsMinOrderByAggregateInput
    _sum?: student_subject_interestsSumOrderByAggregateInput
  }

  export type student_subject_interestsScalarWhereWithAggregatesInput = {
    AND?: student_subject_interestsScalarWhereWithAggregatesInput | student_subject_interestsScalarWhereWithAggregatesInput[]
    OR?: student_subject_interestsScalarWhereWithAggregatesInput[]
    NOT?: student_subject_interestsScalarWhereWithAggregatesInput | student_subject_interestsScalarWhereWithAggregatesInput[]
    interest_id?: IntWithAggregatesFilter<"student_subject_interests"> | number
    student_id?: IntWithAggregatesFilter<"student_subject_interests"> | number
    subject_id?: IntWithAggregatesFilter<"student_subject_interests"> | number
    interest_level?: StringNullableWithAggregatesFilter<"student_subject_interests"> | string | null
  }

  export type studentsWhereInput = {
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    student_id?: IntFilter<"students"> | number
    user_id?: IntFilter<"students"> | number
    education_level?: StringNullableFilter<"students"> | string | null
    grade_year?: StringNullableFilter<"students"> | string | null
    parent_guardian_name?: StringNullableFilter<"students"> | string | null
    parent_guardian_email?: StringNullableFilter<"students"> | string | null
    parent_guardian_phone?: StringNullableFilter<"students"> | string | null
    special_needs?: StringNullableFilter<"students"> | string | null
    learning_preferences?: StringNullableFilter<"students"> | string | null
    group_session_participants?: Group_session_participantsListRelationFilter
    session_ratings?: Session_ratingsListRelationFilter
    sessions?: SessionsListRelationFilter
    student_subject_interests?: Student_subject_interestsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    subscriptions?: SubscriptionsListRelationFilter
  }

  export type studentsOrderByWithRelationInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    education_level?: SortOrderInput | SortOrder
    grade_year?: SortOrderInput | SortOrder
    parent_guardian_name?: SortOrderInput | SortOrder
    parent_guardian_email?: SortOrderInput | SortOrder
    parent_guardian_phone?: SortOrderInput | SortOrder
    special_needs?: SortOrderInput | SortOrder
    learning_preferences?: SortOrderInput | SortOrder
    group_session_participants?: group_session_participantsOrderByRelationAggregateInput
    session_ratings?: session_ratingsOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    student_subject_interests?: student_subject_interestsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    subscriptions?: subscriptionsOrderByRelationAggregateInput
    _relevance?: studentsOrderByRelevanceInput
  }

  export type studentsWhereUniqueInput = Prisma.AtLeast<{
    student_id?: number
    user_id?: number
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    education_level?: StringNullableFilter<"students"> | string | null
    grade_year?: StringNullableFilter<"students"> | string | null
    parent_guardian_name?: StringNullableFilter<"students"> | string | null
    parent_guardian_email?: StringNullableFilter<"students"> | string | null
    parent_guardian_phone?: StringNullableFilter<"students"> | string | null
    special_needs?: StringNullableFilter<"students"> | string | null
    learning_preferences?: StringNullableFilter<"students"> | string | null
    group_session_participants?: Group_session_participantsListRelationFilter
    session_ratings?: Session_ratingsListRelationFilter
    sessions?: SessionsListRelationFilter
    student_subject_interests?: Student_subject_interestsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    subscriptions?: SubscriptionsListRelationFilter
  }, "student_id" | "user_id">

  export type studentsOrderByWithAggregationInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    education_level?: SortOrderInput | SortOrder
    grade_year?: SortOrderInput | SortOrder
    parent_guardian_name?: SortOrderInput | SortOrder
    parent_guardian_email?: SortOrderInput | SortOrder
    parent_guardian_phone?: SortOrderInput | SortOrder
    special_needs?: SortOrderInput | SortOrder
    learning_preferences?: SortOrderInput | SortOrder
    _count?: studentsCountOrderByAggregateInput
    _avg?: studentsAvgOrderByAggregateInput
    _max?: studentsMaxOrderByAggregateInput
    _min?: studentsMinOrderByAggregateInput
    _sum?: studentsSumOrderByAggregateInput
  }

  export type studentsScalarWhereWithAggregatesInput = {
    AND?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    OR?: studentsScalarWhereWithAggregatesInput[]
    NOT?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    student_id?: IntWithAggregatesFilter<"students"> | number
    user_id?: IntWithAggregatesFilter<"students"> | number
    education_level?: StringNullableWithAggregatesFilter<"students"> | string | null
    grade_year?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_guardian_name?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_guardian_email?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_guardian_phone?: StringNullableWithAggregatesFilter<"students"> | string | null
    special_needs?: StringNullableWithAggregatesFilter<"students"> | string | null
    learning_preferences?: StringNullableWithAggregatesFilter<"students"> | string | null
  }

  export type subject_categoriesWhereInput = {
    AND?: subject_categoriesWhereInput | subject_categoriesWhereInput[]
    OR?: subject_categoriesWhereInput[]
    NOT?: subject_categoriesWhereInput | subject_categoriesWhereInput[]
    category_id?: IntFilter<"subject_categories"> | number
    name?: StringFilter<"subject_categories"> | string
    description?: StringNullableFilter<"subject_categories"> | string | null
    subjects?: SubjectsListRelationFilter
  }

  export type subject_categoriesOrderByWithRelationInput = {
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    subjects?: subjectsOrderByRelationAggregateInput
    _relevance?: subject_categoriesOrderByRelevanceInput
  }

  export type subject_categoriesWhereUniqueInput = Prisma.AtLeast<{
    category_id?: number
    AND?: subject_categoriesWhereInput | subject_categoriesWhereInput[]
    OR?: subject_categoriesWhereInput[]
    NOT?: subject_categoriesWhereInput | subject_categoriesWhereInput[]
    name?: StringFilter<"subject_categories"> | string
    description?: StringNullableFilter<"subject_categories"> | string | null
    subjects?: SubjectsListRelationFilter
  }, "category_id">

  export type subject_categoriesOrderByWithAggregationInput = {
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: subject_categoriesCountOrderByAggregateInput
    _avg?: subject_categoriesAvgOrderByAggregateInput
    _max?: subject_categoriesMaxOrderByAggregateInput
    _min?: subject_categoriesMinOrderByAggregateInput
    _sum?: subject_categoriesSumOrderByAggregateInput
  }

  export type subject_categoriesScalarWhereWithAggregatesInput = {
    AND?: subject_categoriesScalarWhereWithAggregatesInput | subject_categoriesScalarWhereWithAggregatesInput[]
    OR?: subject_categoriesScalarWhereWithAggregatesInput[]
    NOT?: subject_categoriesScalarWhereWithAggregatesInput | subject_categoriesScalarWhereWithAggregatesInput[]
    category_id?: IntWithAggregatesFilter<"subject_categories"> | number
    name?: StringWithAggregatesFilter<"subject_categories"> | string
    description?: StringNullableWithAggregatesFilter<"subject_categories"> | string | null
  }

  export type subjectsWhereInput = {
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    subject_id?: IntFilter<"subjects"> | number
    category_id?: IntNullableFilter<"subjects"> | number | null
    name?: StringFilter<"subjects"> | string
    description?: StringNullableFilter<"subjects"> | string | null
    difficulty_level?: StringNullableFilter<"subjects"> | string | null
    group_sessions?: Group_sessionsListRelationFilter
    resources?: ResourcesListRelationFilter
    sessions?: SessionsListRelationFilter
    student_subject_interests?: Student_subject_interestsListRelationFilter
    subject_categories?: XOR<Subject_categoriesNullableScalarRelationFilter, subject_categoriesWhereInput> | null
    tutor_subjects?: Tutor_subjectsListRelationFilter
  }

  export type subjectsOrderByWithRelationInput = {
    subject_id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty_level?: SortOrderInput | SortOrder
    group_sessions?: group_sessionsOrderByRelationAggregateInput
    resources?: resourcesOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    student_subject_interests?: student_subject_interestsOrderByRelationAggregateInput
    subject_categories?: subject_categoriesOrderByWithRelationInput
    tutor_subjects?: tutor_subjectsOrderByRelationAggregateInput
    _relevance?: subjectsOrderByRelevanceInput
  }

  export type subjectsWhereUniqueInput = Prisma.AtLeast<{
    subject_id?: number
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    category_id?: IntNullableFilter<"subjects"> | number | null
    name?: StringFilter<"subjects"> | string
    description?: StringNullableFilter<"subjects"> | string | null
    difficulty_level?: StringNullableFilter<"subjects"> | string | null
    group_sessions?: Group_sessionsListRelationFilter
    resources?: ResourcesListRelationFilter
    sessions?: SessionsListRelationFilter
    student_subject_interests?: Student_subject_interestsListRelationFilter
    subject_categories?: XOR<Subject_categoriesNullableScalarRelationFilter, subject_categoriesWhereInput> | null
    tutor_subjects?: Tutor_subjectsListRelationFilter
  }, "subject_id">

  export type subjectsOrderByWithAggregationInput = {
    subject_id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty_level?: SortOrderInput | SortOrder
    _count?: subjectsCountOrderByAggregateInput
    _avg?: subjectsAvgOrderByAggregateInput
    _max?: subjectsMaxOrderByAggregateInput
    _min?: subjectsMinOrderByAggregateInput
    _sum?: subjectsSumOrderByAggregateInput
  }

  export type subjectsScalarWhereWithAggregatesInput = {
    AND?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    OR?: subjectsScalarWhereWithAggregatesInput[]
    NOT?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    subject_id?: IntWithAggregatesFilter<"subjects"> | number
    category_id?: IntNullableWithAggregatesFilter<"subjects"> | number | null
    name?: StringWithAggregatesFilter<"subjects"> | string
    description?: StringNullableWithAggregatesFilter<"subjects"> | string | null
    difficulty_level?: StringNullableWithAggregatesFilter<"subjects"> | string | null
  }

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    subscription_id?: IntFilter<"subscriptions"> | number
    student_id?: IntFilter<"subscriptions"> | number
    plan_name?: StringFilter<"subscriptions"> | string
    description?: StringNullableFilter<"subscriptions"> | string | null
    price?: DecimalFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFilter<"subscriptions"> | string
    sessions_included?: IntNullableFilter<"subscriptions"> | number | null
    hours_included?: DecimalNullableFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFilter<"subscriptions"> | Date | string
    end_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    is_active?: BoolNullableFilter<"subscriptions"> | boolean | null
    auto_renew?: BoolNullableFilter<"subscriptions"> | boolean | null
    payment_method?: StringNullableFilter<"subscriptions"> | string | null
    last_billing_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }

  export type subscriptionsOrderByWithRelationInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    sessions_included?: SortOrderInput | SortOrder
    hours_included?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    auto_renew?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    last_billing_date?: SortOrderInput | SortOrder
    next_billing_date?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
    _relevance?: subscriptionsOrderByRelevanceInput
  }

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    subscription_id?: number
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    student_id?: IntFilter<"subscriptions"> | number
    plan_name?: StringFilter<"subscriptions"> | string
    description?: StringNullableFilter<"subscriptions"> | string | null
    price?: DecimalFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFilter<"subscriptions"> | string
    sessions_included?: IntNullableFilter<"subscriptions"> | number | null
    hours_included?: DecimalNullableFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFilter<"subscriptions"> | Date | string
    end_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    is_active?: BoolNullableFilter<"subscriptions"> | boolean | null
    auto_renew?: BoolNullableFilter<"subscriptions"> | boolean | null
    payment_method?: StringNullableFilter<"subscriptions"> | string | null
    last_billing_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
  }, "subscription_id">

  export type subscriptionsOrderByWithAggregationInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    sessions_included?: SortOrderInput | SortOrder
    hours_included?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    auto_renew?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    last_billing_date?: SortOrderInput | SortOrder
    next_billing_date?: SortOrderInput | SortOrder
    _count?: subscriptionsCountOrderByAggregateInput
    _avg?: subscriptionsAvgOrderByAggregateInput
    _max?: subscriptionsMaxOrderByAggregateInput
    _min?: subscriptionsMinOrderByAggregateInput
    _sum?: subscriptionsSumOrderByAggregateInput
  }

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    OR?: subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    subscription_id?: IntWithAggregatesFilter<"subscriptions"> | number
    student_id?: IntWithAggregatesFilter<"subscriptions"> | number
    plan_name?: StringWithAggregatesFilter<"subscriptions"> | string
    description?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null
    price?: DecimalWithAggregatesFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringWithAggregatesFilter<"subscriptions"> | string
    sessions_included?: IntNullableWithAggregatesFilter<"subscriptions"> | number | null
    hours_included?: DecimalNullableWithAggregatesFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    end_date?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"subscriptions"> | boolean | null
    auto_renew?: BoolNullableWithAggregatesFilter<"subscriptions"> | boolean | null
    payment_method?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null
    last_billing_date?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    next_billing_date?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
  }

  export type tutor_availabilityWhereInput = {
    AND?: tutor_availabilityWhereInput | tutor_availabilityWhereInput[]
    OR?: tutor_availabilityWhereInput[]
    NOT?: tutor_availabilityWhereInput | tutor_availabilityWhereInput[]
    availability_id?: IntFilter<"tutor_availability"> | number
    tutor_id?: IntFilter<"tutor_availability"> | number
    day_of_week?: IntFilter<"tutor_availability"> | number
    start_time?: DateTimeFilter<"tutor_availability"> | Date | string
    end_time?: DateTimeFilter<"tutor_availability"> | Date | string
    is_recurring?: BoolNullableFilter<"tutor_availability"> | boolean | null
    specific_date?: DateTimeNullableFilter<"tutor_availability"> | Date | string | null
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
  }

  export type tutor_availabilityOrderByWithRelationInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_recurring?: SortOrderInput | SortOrder
    specific_date?: SortOrderInput | SortOrder
    tutors?: tutorsOrderByWithRelationInput
  }

  export type tutor_availabilityWhereUniqueInput = Prisma.AtLeast<{
    availability_id?: number
    AND?: tutor_availabilityWhereInput | tutor_availabilityWhereInput[]
    OR?: tutor_availabilityWhereInput[]
    NOT?: tutor_availabilityWhereInput | tutor_availabilityWhereInput[]
    tutor_id?: IntFilter<"tutor_availability"> | number
    day_of_week?: IntFilter<"tutor_availability"> | number
    start_time?: DateTimeFilter<"tutor_availability"> | Date | string
    end_time?: DateTimeFilter<"tutor_availability"> | Date | string
    is_recurring?: BoolNullableFilter<"tutor_availability"> | boolean | null
    specific_date?: DateTimeNullableFilter<"tutor_availability"> | Date | string | null
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
  }, "availability_id">

  export type tutor_availabilityOrderByWithAggregationInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_recurring?: SortOrderInput | SortOrder
    specific_date?: SortOrderInput | SortOrder
    _count?: tutor_availabilityCountOrderByAggregateInput
    _avg?: tutor_availabilityAvgOrderByAggregateInput
    _max?: tutor_availabilityMaxOrderByAggregateInput
    _min?: tutor_availabilityMinOrderByAggregateInput
    _sum?: tutor_availabilitySumOrderByAggregateInput
  }

  export type tutor_availabilityScalarWhereWithAggregatesInput = {
    AND?: tutor_availabilityScalarWhereWithAggregatesInput | tutor_availabilityScalarWhereWithAggregatesInput[]
    OR?: tutor_availabilityScalarWhereWithAggregatesInput[]
    NOT?: tutor_availabilityScalarWhereWithAggregatesInput | tutor_availabilityScalarWhereWithAggregatesInput[]
    availability_id?: IntWithAggregatesFilter<"tutor_availability"> | number
    tutor_id?: IntWithAggregatesFilter<"tutor_availability"> | number
    day_of_week?: IntWithAggregatesFilter<"tutor_availability"> | number
    start_time?: DateTimeWithAggregatesFilter<"tutor_availability"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"tutor_availability"> | Date | string
    is_recurring?: BoolNullableWithAggregatesFilter<"tutor_availability"> | boolean | null
    specific_date?: DateTimeNullableWithAggregatesFilter<"tutor_availability"> | Date | string | null
  }

  export type tutor_subjectsWhereInput = {
    AND?: tutor_subjectsWhereInput | tutor_subjectsWhereInput[]
    OR?: tutor_subjectsWhereInput[]
    NOT?: tutor_subjectsWhereInput | tutor_subjectsWhereInput[]
    tutor_subject_id?: IntFilter<"tutor_subjects"> | number
    tutor_id?: IntFilter<"tutor_subjects"> | number
    subject_id?: IntFilter<"tutor_subjects"> | number
    proficiency_level?: StringFilter<"tutor_subjects"> | string
    verified?: BoolNullableFilter<"tutor_subjects"> | boolean | null
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }

  export type tutor_subjectsOrderByWithRelationInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    proficiency_level?: SortOrder
    verified?: SortOrderInput | SortOrder
    tutors?: tutorsOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    _relevance?: tutor_subjectsOrderByRelevanceInput
  }

  export type tutor_subjectsWhereUniqueInput = Prisma.AtLeast<{
    tutor_subject_id?: number
    tutor_id_subject_id?: tutor_subjectsTutor_idSubject_idCompoundUniqueInput
    AND?: tutor_subjectsWhereInput | tutor_subjectsWhereInput[]
    OR?: tutor_subjectsWhereInput[]
    NOT?: tutor_subjectsWhereInput | tutor_subjectsWhereInput[]
    tutor_id?: IntFilter<"tutor_subjects"> | number
    subject_id?: IntFilter<"tutor_subjects"> | number
    proficiency_level?: StringFilter<"tutor_subjects"> | string
    verified?: BoolNullableFilter<"tutor_subjects"> | boolean | null
    tutors?: XOR<TutorsScalarRelationFilter, tutorsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }, "tutor_subject_id" | "tutor_id_subject_id">

  export type tutor_subjectsOrderByWithAggregationInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    proficiency_level?: SortOrder
    verified?: SortOrderInput | SortOrder
    _count?: tutor_subjectsCountOrderByAggregateInput
    _avg?: tutor_subjectsAvgOrderByAggregateInput
    _max?: tutor_subjectsMaxOrderByAggregateInput
    _min?: tutor_subjectsMinOrderByAggregateInput
    _sum?: tutor_subjectsSumOrderByAggregateInput
  }

  export type tutor_subjectsScalarWhereWithAggregatesInput = {
    AND?: tutor_subjectsScalarWhereWithAggregatesInput | tutor_subjectsScalarWhereWithAggregatesInput[]
    OR?: tutor_subjectsScalarWhereWithAggregatesInput[]
    NOT?: tutor_subjectsScalarWhereWithAggregatesInput | tutor_subjectsScalarWhereWithAggregatesInput[]
    tutor_subject_id?: IntWithAggregatesFilter<"tutor_subjects"> | number
    tutor_id?: IntWithAggregatesFilter<"tutor_subjects"> | number
    subject_id?: IntWithAggregatesFilter<"tutor_subjects"> | number
    proficiency_level?: StringWithAggregatesFilter<"tutor_subjects"> | string
    verified?: BoolNullableWithAggregatesFilter<"tutor_subjects"> | boolean | null
  }

  export type tutorsWhereInput = {
    AND?: tutorsWhereInput | tutorsWhereInput[]
    OR?: tutorsWhereInput[]
    NOT?: tutorsWhereInput | tutorsWhereInput[]
    tutor_id?: IntFilter<"tutors"> | number
    user_id?: IntFilter<"tutors"> | number
    hourly_rate?: DecimalFilter<"tutors"> | Decimal | DecimalJsLike | number | string
    experience_years?: IntNullableFilter<"tutors"> | number | null
    qualification?: StringFilter<"tutors"> | string
    background_check_status?: StringNullableFilter<"tutors"> | string | null
    background_check_date?: DateTimeNullableFilter<"tutors"> | Date | string | null
    avg_rating?: DecimalNullableFilter<"tutors"> | Decimal | DecimalJsLike | number | string | null
    total_sessions?: IntNullableFilter<"tutors"> | number | null
    is_verified?: BoolNullableFilter<"tutors"> | boolean | null
    verification_date?: DateTimeNullableFilter<"tutors"> | Date | string | null
    payment_details?: JsonNullableFilter<"tutors">
    group_sessions?: Group_sessionsListRelationFilter
    session_ratings?: Session_ratingsListRelationFilter
    sessions?: SessionsListRelationFilter
    tutor_availability?: Tutor_availabilityListRelationFilter
    tutor_subjects?: Tutor_subjectsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type tutorsOrderByWithRelationInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrderInput | SortOrder
    qualification?: SortOrder
    background_check_status?: SortOrderInput | SortOrder
    background_check_date?: SortOrderInput | SortOrder
    avg_rating?: SortOrderInput | SortOrder
    total_sessions?: SortOrderInput | SortOrder
    is_verified?: SortOrderInput | SortOrder
    verification_date?: SortOrderInput | SortOrder
    payment_details?: SortOrderInput | SortOrder
    group_sessions?: group_sessionsOrderByRelationAggregateInput
    session_ratings?: session_ratingsOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    tutor_availability?: tutor_availabilityOrderByRelationAggregateInput
    tutor_subjects?: tutor_subjectsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    _relevance?: tutorsOrderByRelevanceInput
  }

  export type tutorsWhereUniqueInput = Prisma.AtLeast<{
    tutor_id?: number
    user_id?: number
    AND?: tutorsWhereInput | tutorsWhereInput[]
    OR?: tutorsWhereInput[]
    NOT?: tutorsWhereInput | tutorsWhereInput[]
    hourly_rate?: DecimalFilter<"tutors"> | Decimal | DecimalJsLike | number | string
    experience_years?: IntNullableFilter<"tutors"> | number | null
    qualification?: StringFilter<"tutors"> | string
    background_check_status?: StringNullableFilter<"tutors"> | string | null
    background_check_date?: DateTimeNullableFilter<"tutors"> | Date | string | null
    avg_rating?: DecimalNullableFilter<"tutors"> | Decimal | DecimalJsLike | number | string | null
    total_sessions?: IntNullableFilter<"tutors"> | number | null
    is_verified?: BoolNullableFilter<"tutors"> | boolean | null
    verification_date?: DateTimeNullableFilter<"tutors"> | Date | string | null
    payment_details?: JsonNullableFilter<"tutors">
    group_sessions?: Group_sessionsListRelationFilter
    session_ratings?: Session_ratingsListRelationFilter
    sessions?: SessionsListRelationFilter
    tutor_availability?: Tutor_availabilityListRelationFilter
    tutor_subjects?: Tutor_subjectsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "tutor_id" | "user_id">

  export type tutorsOrderByWithAggregationInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrderInput | SortOrder
    qualification?: SortOrder
    background_check_status?: SortOrderInput | SortOrder
    background_check_date?: SortOrderInput | SortOrder
    avg_rating?: SortOrderInput | SortOrder
    total_sessions?: SortOrderInput | SortOrder
    is_verified?: SortOrderInput | SortOrder
    verification_date?: SortOrderInput | SortOrder
    payment_details?: SortOrderInput | SortOrder
    _count?: tutorsCountOrderByAggregateInput
    _avg?: tutorsAvgOrderByAggregateInput
    _max?: tutorsMaxOrderByAggregateInput
    _min?: tutorsMinOrderByAggregateInput
    _sum?: tutorsSumOrderByAggregateInput
  }

  export type tutorsScalarWhereWithAggregatesInput = {
    AND?: tutorsScalarWhereWithAggregatesInput | tutorsScalarWhereWithAggregatesInput[]
    OR?: tutorsScalarWhereWithAggregatesInput[]
    NOT?: tutorsScalarWhereWithAggregatesInput | tutorsScalarWhereWithAggregatesInput[]
    tutor_id?: IntWithAggregatesFilter<"tutors"> | number
    user_id?: IntWithAggregatesFilter<"tutors"> | number
    hourly_rate?: DecimalWithAggregatesFilter<"tutors"> | Decimal | DecimalJsLike | number | string
    experience_years?: IntNullableWithAggregatesFilter<"tutors"> | number | null
    qualification?: StringWithAggregatesFilter<"tutors"> | string
    background_check_status?: StringNullableWithAggregatesFilter<"tutors"> | string | null
    background_check_date?: DateTimeNullableWithAggregatesFilter<"tutors"> | Date | string | null
    avg_rating?: DecimalNullableWithAggregatesFilter<"tutors"> | Decimal | DecimalJsLike | number | string | null
    total_sessions?: IntNullableWithAggregatesFilter<"tutors"> | number | null
    is_verified?: BoolNullableWithAggregatesFilter<"tutors"> | boolean | null
    verification_date?: DateTimeNullableWithAggregatesFilter<"tutors"> | Date | string | null
    payment_details?: JsonNullableWithAggregatesFilter<"tutors">
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: IntFilter<"users"> | number
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    date_of_birth?: DateTimeNullableFilter<"users"> | Date | string | null
    profile_picture?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_active?: BoolNullableFilter<"users"> | boolean | null
    messages_messages_sender_idTousers?: MessagesListRelationFilter
    messages_messages_recipient_idTousers?: MessagesListRelationFilter
    notifications?: NotificationsListRelationFilter
    resources?: ResourcesListRelationFilter
    session_notes?: Session_notesListRelationFilter
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
    tutors?: XOR<TutorsNullableScalarRelationFilter, tutorsWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    profile_picture?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    messages_messages_sender_idTousers?: messagesOrderByRelationAggregateInput
    messages_messages_recipient_idTousers?: messagesOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    resources?: resourcesOrderByRelationAggregateInput
    session_notes?: session_notesOrderByRelationAggregateInput
    students?: studentsOrderByWithRelationInput
    tutors?: tutorsOrderByWithRelationInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password_hash?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    date_of_birth?: DateTimeNullableFilter<"users"> | Date | string | null
    profile_picture?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_active?: BoolNullableFilter<"users"> | boolean | null
    messages_messages_sender_idTousers?: MessagesListRelationFilter
    messages_messages_recipient_idTousers?: MessagesListRelationFilter
    notifications?: NotificationsListRelationFilter
    resources?: ResourcesListRelationFilter
    session_notes?: Session_notesListRelationFilter
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
    tutors?: XOR<TutorsNullableScalarRelationFilter, tutorsWhereInput> | null
  }, "user_id" | "email">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    profile_picture?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"users"> | number
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    first_name?: StringWithAggregatesFilter<"users"> | string
    last_name?: StringWithAggregatesFilter<"users"> | string
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    profile_picture?: StringNullableWithAggregatesFilter<"users"> | string | null
    bio?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
  }

  export type group_session_participantsCreateInput = {
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
    group_sessions: group_sessionsCreateNestedOneWithoutGroup_session_participantsInput
    students: studentsCreateNestedOneWithoutGroup_session_participantsInput
  }

  export type group_session_participantsUncheckedCreateInput = {
    participation_id?: number
    group_session_id: number
    student_id: number
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
  }

  export type group_session_participantsUpdateInput = {
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    group_sessions?: group_sessionsUpdateOneRequiredWithoutGroup_session_participantsNestedInput
    students?: studentsUpdateOneRequiredWithoutGroup_session_participantsNestedInput
  }

  export type group_session_participantsUncheckedUpdateInput = {
    participation_id?: IntFieldUpdateOperationsInput | number
    group_session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_session_participantsCreateManyInput = {
    participation_id?: number
    group_session_id: number
    student_id: number
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
  }

  export type group_session_participantsUpdateManyMutationInput = {
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_session_participantsUncheckedUpdateManyInput = {
    participation_id?: IntFieldUpdateOperationsInput | number
    group_session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_sessionsCreateInput = {
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutGroup_sessionsInput
    tutors: tutorsCreateNestedOneWithoutGroup_sessionsInput
    subjects: subjectsCreateNestedOneWithoutGroup_sessionsInput
  }

  export type group_sessionsUncheckedCreateInput = {
    group_session_id?: number
    tutor_id: number
    subject_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutGroup_sessionsInput
  }

  export type group_sessionsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutGroup_sessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutGroup_sessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsUncheckedUpdateInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsCreateManyInput = {
    group_session_id?: number
    tutor_id: number
    subject_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
  }

  export type group_sessionsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_sessionsUncheckedUpdateManyInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messagesCreateInput = {
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
    users_messages_sender_idTousers: usersCreateNestedOneWithoutMessages_messages_sender_idTousersInput
    users_messages_recipient_idTousers: usersCreateNestedOneWithoutMessages_messages_recipient_idTousersInput
  }

  export type messagesUncheckedCreateInput = {
    message_id?: number
    sender_id: number
    recipient_id: number
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
  }

  export type messagesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    users_messages_sender_idTousers?: usersUpdateOneRequiredWithoutMessages_messages_sender_idTousersNestedInput
    users_messages_recipient_idTousers?: usersUpdateOneRequiredWithoutMessages_messages_recipient_idTousersNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    recipient_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesCreateManyInput = {
    message_id?: number
    sender_id: number
    recipient_id: number
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
  }

  export type messagesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesUncheckedUpdateManyInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    recipient_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsCreateInput = {
    title: string
    content: string
    notification_type: string
    related_id?: number | null
    created_at?: Date | string | null
    read_at?: Date | string | null
    is_read?: boolean | null
    users: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    notification_id?: number
    user_id: number
    title: string
    content: string
    notification_type: string
    related_id?: number | null
    created_at?: Date | string | null
    read_at?: Date | string | null
    is_read?: boolean | null
  }

  export type notificationsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    notification_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notificationsCreateManyInput = {
    notification_id?: number
    user_id: number
    title: string
    content: string
    notification_type: string
    related_id?: number | null
    created_at?: Date | string | null
    read_at?: Date | string | null
    is_read?: boolean | null
  }

  export type notificationsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notificationsUncheckedUpdateManyInput = {
    notification_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentsCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_method: string
    transaction_id?: string | null
    status: string
    platform_fee: Decimal | DecimalJsLike | number | string
    tutor_payout: Decimal | DecimalJsLike | number | string
    payout_date?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_date?: Date | string | null
    refund_reason?: string | null
    sessions: sessionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    payment_id?: number
    session_id: number
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_method: string
    transaction_id?: string | null
    status: string
    platform_fee: Decimal | DecimalJsLike | number | string
    tutor_payout: Decimal | DecimalJsLike | number | string
    payout_date?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_date?: Date | string | null
    refund_reason?: string | null
  }

  export type paymentsUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: sessionsUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsCreateManyInput = {
    payment_id?: number
    session_id: number
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_method: string
    transaction_id?: string | null
    status: string
    platform_fee: Decimal | DecimalJsLike | number | string
    tutor_payout: Decimal | DecimalJsLike | number | string
    payout_date?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_date?: Date | string | null
    refund_reason?: string | null
  }

  export type paymentsUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type resourcesCreateInput = {
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    subjects?: subjectsCreateNestedOneWithoutResourcesInput
    users: usersCreateNestedOneWithoutResourcesInput
    session_resources?: session_resourcesCreateNestedManyWithoutResourcesInput
  }

  export type resourcesUncheckedCreateInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    subject_id?: number | null
    uploaded_by: number
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutResourcesInput
  }

  export type resourcesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subjects?: subjectsUpdateOneWithoutResourcesNestedInput
    users?: usersUpdateOneRequiredWithoutResourcesNestedInput
    session_resources?: session_resourcesUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_resources?: session_resourcesUncheckedUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesCreateManyInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    subject_id?: number | null
    uploaded_by: number
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type resourcesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourcesUncheckedUpdateManyInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_notesCreateInput = {
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
    sessions: sessionsCreateNestedOneWithoutSession_notesInput
    users: usersCreateNestedOneWithoutSession_notesInput
  }

  export type session_notesUncheckedCreateInput = {
    note_id?: number
    session_id: number
    author_id: number
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
  }

  export type session_notesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: sessionsUpdateOneRequiredWithoutSession_notesNestedInput
    users?: usersUpdateOneRequiredWithoutSession_notesNestedInput
  }

  export type session_notesUncheckedUpdateInput = {
    note_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_notesCreateManyInput = {
    note_id?: number
    session_id: number
    author_id: number
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
  }

  export type session_notesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_notesUncheckedUpdateManyInput = {
    note_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_ratingsCreateInput = {
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
    sessions: sessionsCreateNestedOneWithoutSession_ratingsInput
    students: studentsCreateNestedOneWithoutSession_ratingsInput
    tutors: tutorsCreateNestedOneWithoutSession_ratingsInput
  }

  export type session_ratingsUncheckedCreateInput = {
    rating_id?: number
    session_id: number
    student_id: number
    tutor_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type session_ratingsUpdateInput = {
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: sessionsUpdateOneRequiredWithoutSession_ratingsNestedInput
    students?: studentsUpdateOneRequiredWithoutSession_ratingsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSession_ratingsNestedInput
  }

  export type session_ratingsUncheckedUpdateInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_ratingsCreateManyInput = {
    rating_id?: number
    session_id: number
    student_id: number
    tutor_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type session_ratingsUpdateManyMutationInput = {
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_ratingsUncheckedUpdateManyInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_resourcesCreateInput = {
    sessions: sessionsCreateNestedOneWithoutSession_resourcesInput
    resources: resourcesCreateNestedOneWithoutSession_resourcesInput
  }

  export type session_resourcesUncheckedCreateInput = {
    session_resource_id?: number
    session_id: number
    resource_id: number
  }

  export type session_resourcesUpdateInput = {
    sessions?: sessionsUpdateOneRequiredWithoutSession_resourcesNestedInput
    resources?: resourcesUpdateOneRequiredWithoutSession_resourcesNestedInput
  }

  export type session_resourcesUncheckedUpdateInput = {
    session_resource_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    resource_id?: IntFieldUpdateOperationsInput | number
  }

  export type session_resourcesCreateManyInput = {
    session_resource_id?: number
    session_id: number
    resource_id: number
  }

  export type session_resourcesUpdateManyMutationInput = {

  }

  export type session_resourcesUncheckedUpdateManyInput = {
    session_resource_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    resource_id?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsCreateInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsUpdateInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsCreateManyInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type sessionsUpdateManyMutationInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type sessionsUncheckedUpdateManyInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsCreateInput = {
    interest_level?: string | null
    students: studentsCreateNestedOneWithoutStudent_subject_interestsInput
    subjects: subjectsCreateNestedOneWithoutStudent_subject_interestsInput
  }

  export type student_subject_interestsUncheckedCreateInput = {
    interest_id?: number
    student_id: number
    subject_id: number
    interest_level?: string | null
  }

  export type student_subject_interestsUpdateInput = {
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_subject_interestsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutStudent_subject_interestsNestedInput
  }

  export type student_subject_interestsUncheckedUpdateInput = {
    interest_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_subject_interestsCreateManyInput = {
    interest_id?: number
    student_id: number
    subject_id: number
    interest_level?: string | null
  }

  export type student_subject_interestsUpdateManyMutationInput = {
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_subject_interestsUncheckedUpdateManyInput = {
    interest_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentsCreateInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutStudentsInput
    sessions?: sessionsCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    subscriptions?: subscriptionsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutStudentsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsUpdateInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsCreateManyInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
  }

  export type studentsUpdateManyMutationInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentsUncheckedUpdateManyInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subject_categoriesCreateInput = {
    name: string
    description?: string | null
    subjects?: subjectsCreateNestedManyWithoutSubject_categoriesInput
  }

  export type subject_categoriesUncheckedCreateInput = {
    category_id?: number
    name: string
    description?: string | null
    subjects?: subjectsUncheckedCreateNestedManyWithoutSubject_categoriesInput
  }

  export type subject_categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: subjectsUpdateManyWithoutSubject_categoriesNestedInput
  }

  export type subject_categoriesUncheckedUpdateInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: subjectsUncheckedUpdateManyWithoutSubject_categoriesNestedInput
  }

  export type subject_categoriesCreateManyInput = {
    category_id?: number
    name: string
    description?: string | null
  }

  export type subject_categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subject_categoriesUncheckedUpdateManyInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subjectsCreateInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsCreateNestedManyWithoutSubjectsInput
    resources?: resourcesCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutSubjectsInput
    subject_categories?: subject_categoriesCreateNestedOneWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    resources?: resourcesUncheckedCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutSubjectsNestedInput
    subject_categories?: subject_categoriesUpdateOneWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsCreateManyInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
  }

  export type subjectsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subjectsUncheckedUpdateManyInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subscriptionsCreateInput = {
    plan_name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle: string
    sessions_included?: number | null
    hours_included?: Decimal | DecimalJsLike | number | string | null
    start_date: Date | string
    end_date?: Date | string | null
    is_active?: boolean | null
    auto_renew?: boolean | null
    payment_method?: string | null
    last_billing_date?: Date | string | null
    next_billing_date?: Date | string | null
    students: studentsCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateInput = {
    subscription_id?: number
    student_id: number
    plan_name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle: string
    sessions_included?: number | null
    hours_included?: Decimal | DecimalJsLike | number | string | null
    start_date: Date | string
    end_date?: Date | string | null
    is_active?: boolean | null
    auto_renew?: boolean | null
    payment_method?: string | null
    last_billing_date?: Date | string | null
    next_billing_date?: Date | string | null
  }

  export type subscriptionsUpdateInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsCreateManyInput = {
    subscription_id?: number
    student_id: number
    plan_name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle: string
    sessions_included?: number | null
    hours_included?: Decimal | DecimalJsLike | number | string | null
    start_date: Date | string
    end_date?: Date | string | null
    is_active?: boolean | null
    auto_renew?: boolean | null
    payment_method?: string | null
    last_billing_date?: Date | string | null
    next_billing_date?: Date | string | null
  }

  export type subscriptionsUpdateManyMutationInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsUncheckedUpdateManyInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_availabilityCreateInput = {
    day_of_week: number
    start_time: Date | string
    end_time: Date | string
    is_recurring?: boolean | null
    specific_date?: Date | string | null
    tutors: tutorsCreateNestedOneWithoutTutor_availabilityInput
  }

  export type tutor_availabilityUncheckedCreateInput = {
    availability_id?: number
    tutor_id: number
    day_of_week: number
    start_time: Date | string
    end_time: Date | string
    is_recurring?: boolean | null
    specific_date?: Date | string | null
  }

  export type tutor_availabilityUpdateInput = {
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutors?: tutorsUpdateOneRequiredWithoutTutor_availabilityNestedInput
  }

  export type tutor_availabilityUncheckedUpdateInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_availabilityCreateManyInput = {
    availability_id?: number
    tutor_id: number
    day_of_week: number
    start_time: Date | string
    end_time: Date | string
    is_recurring?: boolean | null
    specific_date?: Date | string | null
  }

  export type tutor_availabilityUpdateManyMutationInput = {
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_availabilityUncheckedUpdateManyInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_subjectsCreateInput = {
    proficiency_level: string
    verified?: boolean | null
    tutors: tutorsCreateNestedOneWithoutTutor_subjectsInput
    subjects: subjectsCreateNestedOneWithoutTutor_subjectsInput
  }

  export type tutor_subjectsUncheckedCreateInput = {
    tutor_subject_id?: number
    tutor_id: number
    subject_id: number
    proficiency_level: string
    verified?: boolean | null
  }

  export type tutor_subjectsUpdateInput = {
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tutors?: tutorsUpdateOneRequiredWithoutTutor_subjectsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutTutor_subjectsNestedInput
  }

  export type tutor_subjectsUncheckedUpdateInput = {
    tutor_subject_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tutor_subjectsCreateManyInput = {
    tutor_subject_id?: number
    tutor_id: number
    subject_id: number
    proficiency_level: string
    verified?: boolean | null
  }

  export type tutor_subjectsUpdateManyMutationInput = {
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tutor_subjectsUncheckedUpdateManyInput = {
    tutor_subject_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tutorsCreateInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutTutorsInput
    sessions?: sessionsCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutTutorsInput
    users: usersCreateNestedOneWithoutTutorsInput
  }

  export type tutorsUncheckedCreateInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutTutorsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsUpdateInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutTutorsNestedInput
    users?: usersUpdateOneRequiredWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type tutorsCreateManyInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tutorsUpdateManyMutationInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tutorsUncheckedUpdateManyInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type usersCreateInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Group_sessionsScalarRelationFilter = {
    is?: group_sessionsWhereInput
    isNot?: group_sessionsWhereInput
  }

  export type StudentsScalarRelationFilter = {
    is?: studentsWhereInput
    isNot?: studentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type group_session_participantsOrderByRelevanceInput = {
    fields: group_session_participantsOrderByRelevanceFieldEnum | group_session_participantsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type group_session_participantsGroup_session_idStudent_idCompoundUniqueInput = {
    group_session_id: number
    student_id: number
  }

  export type group_session_participantsCountOrderByAggregateInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
    registration_time?: SortOrder
    payment_status?: SortOrder
    attended?: SortOrder
  }

  export type group_session_participantsAvgOrderByAggregateInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
  }

  export type group_session_participantsMaxOrderByAggregateInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
    registration_time?: SortOrder
    payment_status?: SortOrder
    attended?: SortOrder
  }

  export type group_session_participantsMinOrderByAggregateInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
    registration_time?: SortOrder
    payment_status?: SortOrder
    attended?: SortOrder
  }

  export type group_session_participantsSumOrderByAggregateInput = {
    participation_id?: SortOrder
    group_session_id?: SortOrder
    student_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Group_session_participantsListRelationFilter = {
    every?: group_session_participantsWhereInput
    some?: group_session_participantsWhereInput
    none?: group_session_participantsWhereInput
  }

  export type TutorsScalarRelationFilter = {
    is?: tutorsWhereInput
    isNot?: tutorsWhereInput
  }

  export type SubjectsScalarRelationFilter = {
    is?: subjectsWhereInput
    isNot?: subjectsWhereInput
  }

  export type group_session_participantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type group_sessionsOrderByRelevanceInput = {
    fields: group_sessionsOrderByRelevanceFieldEnum | group_sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type group_sessionsCountOrderByAggregateInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrder
    price_per_student?: SortOrder
    meeting_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type group_sessionsAvgOrderByAggregateInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrder
    price_per_student?: SortOrder
  }

  export type group_sessionsMaxOrderByAggregateInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrder
    price_per_student?: SortOrder
    meeting_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type group_sessionsMinOrderByAggregateInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrder
    price_per_student?: SortOrder
    meeting_url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type group_sessionsSumOrderByAggregateInput = {
    group_session_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    max_participants?: SortOrder
    current_participants?: SortOrder
    price_per_student?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type messagesOrderByRelevanceInput = {
    fields: messagesOrderByRelevanceFieldEnum | messagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type messagesCountOrderByAggregateInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
    attachment_url?: SortOrder
  }

  export type messagesAvgOrderByAggregateInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
    attachment_url?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
    attachment_url?: SortOrder
  }

  export type messagesSumOrderByAggregateInput = {
    message_id?: SortOrder
    sender_id?: SortOrder
    recipient_id?: SortOrder
  }

  export type notificationsOrderByRelevanceInput = {
    fields: notificationsOrderByRelevanceFieldEnum | notificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationsCountOrderByAggregateInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    notification_type?: SortOrder
    related_id?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
    is_read?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    related_id?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    notification_type?: SortOrder
    related_id?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
    is_read?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    notification_type?: SortOrder
    related_id?: SortOrder
    created_at?: SortOrder
    read_at?: SortOrder
    is_read?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    notification_id?: SortOrder
    user_id?: SortOrder
    related_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SessionsScalarRelationFilter = {
    is?: sessionsWhereInput
    isNot?: sessionsWhereInput
  }

  export type paymentsOrderByRelevanceInput = {
    fields: paymentsOrderByRelevanceFieldEnum | paymentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paymentsCountOrderByAggregateInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    payout_date?: SortOrder
    refund_amount?: SortOrder
    refund_date?: SortOrder
    refund_reason?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    refund_amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    payout_date?: SortOrder
    refund_amount?: SortOrder
    refund_date?: SortOrder
    refund_reason?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    payout_date?: SortOrder
    refund_amount?: SortOrder
    refund_date?: SortOrder
    refund_reason?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    payment_id?: SortOrder
    session_id?: SortOrder
    amount?: SortOrder
    platform_fee?: SortOrder
    tutor_payout?: SortOrder
    refund_amount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type SubjectsNullableScalarRelationFilter = {
    is?: subjectsWhereInput | null
    isNot?: subjectsWhereInput | null
  }

  export type Session_resourcesListRelationFilter = {
    every?: session_resourcesWhereInput
    some?: session_resourcesWhereInput
    none?: session_resourcesWhereInput
  }

  export type session_resourcesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resourcesOrderByRelevanceInput = {
    fields: resourcesOrderByRelevanceFieldEnum | resourcesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type resourcesCountOrderByAggregateInput = {
    resource_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    file_path?: SortOrder
    subject_id?: SortOrder
    uploaded_by?: SortOrder
    resource_type?: SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resourcesAvgOrderByAggregateInput = {
    resource_id?: SortOrder
    subject_id?: SortOrder
    uploaded_by?: SortOrder
  }

  export type resourcesMaxOrderByAggregateInput = {
    resource_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    file_path?: SortOrder
    subject_id?: SortOrder
    uploaded_by?: SortOrder
    resource_type?: SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resourcesMinOrderByAggregateInput = {
    resource_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    file_path?: SortOrder
    subject_id?: SortOrder
    uploaded_by?: SortOrder
    resource_type?: SortOrder
    is_public?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type resourcesSumOrderByAggregateInput = {
    resource_id?: SortOrder
    subject_id?: SortOrder
    uploaded_by?: SortOrder
  }

  export type session_notesOrderByRelevanceInput = {
    fields: session_notesOrderByRelevanceFieldEnum | session_notesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type session_notesCountOrderByAggregateInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_private?: SortOrder
  }

  export type session_notesAvgOrderByAggregateInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
  }

  export type session_notesMaxOrderByAggregateInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_private?: SortOrder
  }

  export type session_notesMinOrderByAggregateInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_private?: SortOrder
  }

  export type session_notesSumOrderByAggregateInput = {
    note_id?: SortOrder
    session_id?: SortOrder
    author_id?: SortOrder
  }

  export type session_ratingsOrderByRelevanceInput = {
    fields: session_ratingsOrderByRelevanceFieldEnum | session_ratingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type session_ratingsCountOrderByAggregateInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    created_at?: SortOrder
  }

  export type session_ratingsAvgOrderByAggregateInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
  }

  export type session_ratingsMaxOrderByAggregateInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    created_at?: SortOrder
  }

  export type session_ratingsMinOrderByAggregateInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    created_at?: SortOrder
  }

  export type session_ratingsSumOrderByAggregateInput = {
    rating_id?: SortOrder
    session_id?: SortOrder
    student_id?: SortOrder
    tutor_id?: SortOrder
    rating?: SortOrder
  }

  export type ResourcesScalarRelationFilter = {
    is?: resourcesWhereInput
    isNot?: resourcesWhereInput
  }

  export type session_resourcesSession_idResource_idCompoundUniqueInput = {
    session_id: number
    resource_id: number
  }

  export type session_resourcesCountOrderByAggregateInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
  }

  export type session_resourcesAvgOrderByAggregateInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
  }

  export type session_resourcesMaxOrderByAggregateInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
  }

  export type session_resourcesMinOrderByAggregateInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
  }

  export type session_resourcesSumOrderByAggregateInput = {
    session_resource_id?: SortOrder
    session_id?: SortOrder
    resource_id?: SortOrder
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type Session_notesListRelationFilter = {
    every?: session_notesWhereInput
    some?: session_notesWhereInput
    none?: session_notesWhereInput
  }

  export type Session_ratingsNullableScalarRelationFilter = {
    is?: session_ratingsWhereInput | null
    isNot?: session_ratingsWhereInput | null
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type session_notesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelevanceInput = {
    fields: sessionsOrderByRelevanceFieldEnum | sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionsCountOrderByAggregateInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrder
    status?: SortOrder
    meeting_url?: SortOrder
    notes?: SortOrder
    materials_url?: SortOrder
    created_at?: SortOrder
    canceled_at?: SortOrder
    cancellation_reason?: SortOrder
    cancellation_fee?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    duration_minutes?: SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrder
    cancellation_fee?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrder
    status?: SortOrder
    meeting_url?: SortOrder
    notes?: SortOrder
    materials_url?: SortOrder
    created_at?: SortOrder
    canceled_at?: SortOrder
    cancellation_reason?: SortOrder
    cancellation_fee?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrder
    status?: SortOrder
    meeting_url?: SortOrder
    notes?: SortOrder
    materials_url?: SortOrder
    created_at?: SortOrder
    canceled_at?: SortOrder
    cancellation_reason?: SortOrder
    cancellation_fee?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    session_id?: SortOrder
    tutor_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    duration_minutes?: SortOrder
    hourly_rate?: SortOrder
    session_cost?: SortOrder
    cancellation_fee?: SortOrder
  }

  export type student_subject_interestsOrderByRelevanceInput = {
    fields: student_subject_interestsOrderByRelevanceFieldEnum | student_subject_interestsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type student_subject_interestsStudent_idSubject_idCompoundUniqueInput = {
    student_id: number
    subject_id: number
  }

  export type student_subject_interestsCountOrderByAggregateInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    interest_level?: SortOrder
  }

  export type student_subject_interestsAvgOrderByAggregateInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
  }

  export type student_subject_interestsMaxOrderByAggregateInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    interest_level?: SortOrder
  }

  export type student_subject_interestsMinOrderByAggregateInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    interest_level?: SortOrder
  }

  export type student_subject_interestsSumOrderByAggregateInput = {
    interest_id?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
  }

  export type Session_ratingsListRelationFilter = {
    every?: session_ratingsWhereInput
    some?: session_ratingsWhereInput
    none?: session_ratingsWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type Student_subject_interestsListRelationFilter = {
    every?: student_subject_interestsWhereInput
    some?: student_subject_interestsWhereInput
    none?: student_subject_interestsWhereInput
  }

  export type SubscriptionsListRelationFilter = {
    every?: subscriptionsWhereInput
    some?: subscriptionsWhereInput
    none?: subscriptionsWhereInput
  }

  export type session_ratingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_subject_interestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsOrderByRelevanceInput = {
    fields: studentsOrderByRelevanceFieldEnum | studentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type studentsCountOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    education_level?: SortOrder
    grade_year?: SortOrder
    parent_guardian_name?: SortOrder
    parent_guardian_email?: SortOrder
    parent_guardian_phone?: SortOrder
    special_needs?: SortOrder
    learning_preferences?: SortOrder
  }

  export type studentsAvgOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentsMaxOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    education_level?: SortOrder
    grade_year?: SortOrder
    parent_guardian_name?: SortOrder
    parent_guardian_email?: SortOrder
    parent_guardian_phone?: SortOrder
    special_needs?: SortOrder
    learning_preferences?: SortOrder
  }

  export type studentsMinOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    education_level?: SortOrder
    grade_year?: SortOrder
    parent_guardian_name?: SortOrder
    parent_guardian_email?: SortOrder
    parent_guardian_phone?: SortOrder
    special_needs?: SortOrder
    learning_preferences?: SortOrder
  }

  export type studentsSumOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
  }

  export type SubjectsListRelationFilter = {
    every?: subjectsWhereInput
    some?: subjectsWhereInput
    none?: subjectsWhereInput
  }

  export type subjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subject_categoriesOrderByRelevanceInput = {
    fields: subject_categoriesOrderByRelevanceFieldEnum | subject_categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subject_categoriesCountOrderByAggregateInput = {
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type subject_categoriesAvgOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type subject_categoriesMaxOrderByAggregateInput = {
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type subject_categoriesMinOrderByAggregateInput = {
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type subject_categoriesSumOrderByAggregateInput = {
    category_id?: SortOrder
  }

  export type Group_sessionsListRelationFilter = {
    every?: group_sessionsWhereInput
    some?: group_sessionsWhereInput
    none?: group_sessionsWhereInput
  }

  export type ResourcesListRelationFilter = {
    every?: resourcesWhereInput
    some?: resourcesWhereInput
    none?: resourcesWhereInput
  }

  export type Subject_categoriesNullableScalarRelationFilter = {
    is?: subject_categoriesWhereInput | null
    isNot?: subject_categoriesWhereInput | null
  }

  export type Tutor_subjectsListRelationFilter = {
    every?: tutor_subjectsWhereInput
    some?: tutor_subjectsWhereInput
    none?: tutor_subjectsWhereInput
  }

  export type group_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type resourcesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tutor_subjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectsOrderByRelevanceInput = {
    fields: subjectsOrderByRelevanceFieldEnum | subjectsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subjectsCountOrderByAggregateInput = {
    subject_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty_level?: SortOrder
  }

  export type subjectsAvgOrderByAggregateInput = {
    subject_id?: SortOrder
    category_id?: SortOrder
  }

  export type subjectsMaxOrderByAggregateInput = {
    subject_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty_level?: SortOrder
  }

  export type subjectsMinOrderByAggregateInput = {
    subject_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty_level?: SortOrder
  }

  export type subjectsSumOrderByAggregateInput = {
    subject_id?: SortOrder
    category_id?: SortOrder
  }

  export type subscriptionsOrderByRelevanceInput = {
    fields: subscriptionsOrderByRelevanceFieldEnum | subscriptionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subscriptionsCountOrderByAggregateInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    sessions_included?: SortOrder
    hours_included?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    auto_renew?: SortOrder
    payment_method?: SortOrder
    last_billing_date?: SortOrder
    next_billing_date?: SortOrder
  }

  export type subscriptionsAvgOrderByAggregateInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    price?: SortOrder
    sessions_included?: SortOrder
    hours_included?: SortOrder
  }

  export type subscriptionsMaxOrderByAggregateInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    sessions_included?: SortOrder
    hours_included?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    auto_renew?: SortOrder
    payment_method?: SortOrder
    last_billing_date?: SortOrder
    next_billing_date?: SortOrder
  }

  export type subscriptionsMinOrderByAggregateInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    billing_cycle?: SortOrder
    sessions_included?: SortOrder
    hours_included?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    auto_renew?: SortOrder
    payment_method?: SortOrder
    last_billing_date?: SortOrder
    next_billing_date?: SortOrder
  }

  export type subscriptionsSumOrderByAggregateInput = {
    subscription_id?: SortOrder
    student_id?: SortOrder
    price?: SortOrder
    sessions_included?: SortOrder
    hours_included?: SortOrder
  }

  export type tutor_availabilityCountOrderByAggregateInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_recurring?: SortOrder
    specific_date?: SortOrder
  }

  export type tutor_availabilityAvgOrderByAggregateInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
  }

  export type tutor_availabilityMaxOrderByAggregateInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_recurring?: SortOrder
    specific_date?: SortOrder
  }

  export type tutor_availabilityMinOrderByAggregateInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_recurring?: SortOrder
    specific_date?: SortOrder
  }

  export type tutor_availabilitySumOrderByAggregateInput = {
    availability_id?: SortOrder
    tutor_id?: SortOrder
    day_of_week?: SortOrder
  }

  export type tutor_subjectsOrderByRelevanceInput = {
    fields: tutor_subjectsOrderByRelevanceFieldEnum | tutor_subjectsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tutor_subjectsTutor_idSubject_idCompoundUniqueInput = {
    tutor_id: number
    subject_id: number
  }

  export type tutor_subjectsCountOrderByAggregateInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    proficiency_level?: SortOrder
    verified?: SortOrder
  }

  export type tutor_subjectsAvgOrderByAggregateInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
  }

  export type tutor_subjectsMaxOrderByAggregateInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    proficiency_level?: SortOrder
    verified?: SortOrder
  }

  export type tutor_subjectsMinOrderByAggregateInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
    proficiency_level?: SortOrder
    verified?: SortOrder
  }

  export type tutor_subjectsSumOrderByAggregateInput = {
    tutor_subject_id?: SortOrder
    tutor_id?: SortOrder
    subject_id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Tutor_availabilityListRelationFilter = {
    every?: tutor_availabilityWhereInput
    some?: tutor_availabilityWhereInput
    none?: tutor_availabilityWhereInput
  }

  export type tutor_availabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tutorsOrderByRelevanceInput = {
    fields: tutorsOrderByRelevanceFieldEnum | tutorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tutorsCountOrderByAggregateInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrder
    qualification?: SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrder
    avg_rating?: SortOrder
    total_sessions?: SortOrder
    is_verified?: SortOrder
    verification_date?: SortOrder
    payment_details?: SortOrder
  }

  export type tutorsAvgOrderByAggregateInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrder
    avg_rating?: SortOrder
    total_sessions?: SortOrder
  }

  export type tutorsMaxOrderByAggregateInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrder
    qualification?: SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrder
    avg_rating?: SortOrder
    total_sessions?: SortOrder
    is_verified?: SortOrder
    verification_date?: SortOrder
  }

  export type tutorsMinOrderByAggregateInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrder
    qualification?: SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrder
    avg_rating?: SortOrder
    total_sessions?: SortOrder
    is_verified?: SortOrder
    verification_date?: SortOrder
  }

  export type tutorsSumOrderByAggregateInput = {
    tutor_id?: SortOrder
    user_id?: SortOrder
    hourly_rate?: SortOrder
    experience_years?: SortOrder
    avg_rating?: SortOrder
    total_sessions?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type StudentsNullableScalarRelationFilter = {
    is?: studentsWhereInput | null
    isNot?: studentsWhereInput | null
  }

  export type TutorsNullableScalarRelationFilter = {
    is?: tutorsWhereInput | null
    isNot?: tutorsWhereInput | null
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    date_of_birth?: SortOrder
    profile_picture?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    date_of_birth?: SortOrder
    profile_picture?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    date_of_birth?: SortOrder
    profile_picture?: SortOrder
    bio?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type group_sessionsCreateNestedOneWithoutGroup_session_participantsInput = {
    create?: XOR<group_sessionsCreateWithoutGroup_session_participantsInput, group_sessionsUncheckedCreateWithoutGroup_session_participantsInput>
    connectOrCreate?: group_sessionsCreateOrConnectWithoutGroup_session_participantsInput
    connect?: group_sessionsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutGroup_session_participantsInput = {
    create?: XOR<studentsCreateWithoutGroup_session_participantsInput, studentsUncheckedCreateWithoutGroup_session_participantsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutGroup_session_participantsInput
    connect?: studentsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type group_sessionsUpdateOneRequiredWithoutGroup_session_participantsNestedInput = {
    create?: XOR<group_sessionsCreateWithoutGroup_session_participantsInput, group_sessionsUncheckedCreateWithoutGroup_session_participantsInput>
    connectOrCreate?: group_sessionsCreateOrConnectWithoutGroup_session_participantsInput
    upsert?: group_sessionsUpsertWithoutGroup_session_participantsInput
    connect?: group_sessionsWhereUniqueInput
    update?: XOR<XOR<group_sessionsUpdateToOneWithWhereWithoutGroup_session_participantsInput, group_sessionsUpdateWithoutGroup_session_participantsInput>, group_sessionsUncheckedUpdateWithoutGroup_session_participantsInput>
  }

  export type studentsUpdateOneRequiredWithoutGroup_session_participantsNestedInput = {
    create?: XOR<studentsCreateWithoutGroup_session_participantsInput, studentsUncheckedCreateWithoutGroup_session_participantsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutGroup_session_participantsInput
    upsert?: studentsUpsertWithoutGroup_session_participantsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutGroup_session_participantsInput, studentsUpdateWithoutGroup_session_participantsInput>, studentsUncheckedUpdateWithoutGroup_session_participantsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type group_session_participantsCreateNestedManyWithoutGroup_sessionsInput = {
    create?: XOR<group_session_participantsCreateWithoutGroup_sessionsInput, group_session_participantsUncheckedCreateWithoutGroup_sessionsInput> | group_session_participantsCreateWithoutGroup_sessionsInput[] | group_session_participantsUncheckedCreateWithoutGroup_sessionsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutGroup_sessionsInput | group_session_participantsCreateOrConnectWithoutGroup_sessionsInput[]
    createMany?: group_session_participantsCreateManyGroup_sessionsInputEnvelope
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
  }

  export type tutorsCreateNestedOneWithoutGroup_sessionsInput = {
    create?: XOR<tutorsCreateWithoutGroup_sessionsInput, tutorsUncheckedCreateWithoutGroup_sessionsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutGroup_sessionsInput
    connect?: tutorsWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutGroup_sessionsInput = {
    create?: XOR<subjectsCreateWithoutGroup_sessionsInput, subjectsUncheckedCreateWithoutGroup_sessionsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutGroup_sessionsInput
    connect?: subjectsWhereUniqueInput
  }

  export type group_session_participantsUncheckedCreateNestedManyWithoutGroup_sessionsInput = {
    create?: XOR<group_session_participantsCreateWithoutGroup_sessionsInput, group_session_participantsUncheckedCreateWithoutGroup_sessionsInput> | group_session_participantsCreateWithoutGroup_sessionsInput[] | group_session_participantsUncheckedCreateWithoutGroup_sessionsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutGroup_sessionsInput | group_session_participantsCreateOrConnectWithoutGroup_sessionsInput[]
    createMany?: group_session_participantsCreateManyGroup_sessionsInputEnvelope
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type group_session_participantsUpdateManyWithoutGroup_sessionsNestedInput = {
    create?: XOR<group_session_participantsCreateWithoutGroup_sessionsInput, group_session_participantsUncheckedCreateWithoutGroup_sessionsInput> | group_session_participantsCreateWithoutGroup_sessionsInput[] | group_session_participantsUncheckedCreateWithoutGroup_sessionsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutGroup_sessionsInput | group_session_participantsCreateOrConnectWithoutGroup_sessionsInput[]
    upsert?: group_session_participantsUpsertWithWhereUniqueWithoutGroup_sessionsInput | group_session_participantsUpsertWithWhereUniqueWithoutGroup_sessionsInput[]
    createMany?: group_session_participantsCreateManyGroup_sessionsInputEnvelope
    set?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    disconnect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    delete?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    update?: group_session_participantsUpdateWithWhereUniqueWithoutGroup_sessionsInput | group_session_participantsUpdateWithWhereUniqueWithoutGroup_sessionsInput[]
    updateMany?: group_session_participantsUpdateManyWithWhereWithoutGroup_sessionsInput | group_session_participantsUpdateManyWithWhereWithoutGroup_sessionsInput[]
    deleteMany?: group_session_participantsScalarWhereInput | group_session_participantsScalarWhereInput[]
  }

  export type tutorsUpdateOneRequiredWithoutGroup_sessionsNestedInput = {
    create?: XOR<tutorsCreateWithoutGroup_sessionsInput, tutorsUncheckedCreateWithoutGroup_sessionsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutGroup_sessionsInput
    upsert?: tutorsUpsertWithoutGroup_sessionsInput
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutGroup_sessionsInput, tutorsUpdateWithoutGroup_sessionsInput>, tutorsUncheckedUpdateWithoutGroup_sessionsInput>
  }

  export type subjectsUpdateOneRequiredWithoutGroup_sessionsNestedInput = {
    create?: XOR<subjectsCreateWithoutGroup_sessionsInput, subjectsUncheckedCreateWithoutGroup_sessionsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutGroup_sessionsInput
    upsert?: subjectsUpsertWithoutGroup_sessionsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutGroup_sessionsInput, subjectsUpdateWithoutGroup_sessionsInput>, subjectsUncheckedUpdateWithoutGroup_sessionsInput>
  }

  export type group_session_participantsUncheckedUpdateManyWithoutGroup_sessionsNestedInput = {
    create?: XOR<group_session_participantsCreateWithoutGroup_sessionsInput, group_session_participantsUncheckedCreateWithoutGroup_sessionsInput> | group_session_participantsCreateWithoutGroup_sessionsInput[] | group_session_participantsUncheckedCreateWithoutGroup_sessionsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutGroup_sessionsInput | group_session_participantsCreateOrConnectWithoutGroup_sessionsInput[]
    upsert?: group_session_participantsUpsertWithWhereUniqueWithoutGroup_sessionsInput | group_session_participantsUpsertWithWhereUniqueWithoutGroup_sessionsInput[]
    createMany?: group_session_participantsCreateManyGroup_sessionsInputEnvelope
    set?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    disconnect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    delete?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    update?: group_session_participantsUpdateWithWhereUniqueWithoutGroup_sessionsInput | group_session_participantsUpdateWithWhereUniqueWithoutGroup_sessionsInput[]
    updateMany?: group_session_participantsUpdateManyWithWhereWithoutGroup_sessionsInput | group_session_participantsUpdateManyWithWhereWithoutGroup_sessionsInput[]
    deleteMany?: group_session_participantsScalarWhereInput | group_session_participantsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutMessages_messages_sender_idTousersInput = {
    create?: XOR<usersCreateWithoutMessages_messages_sender_idTousersInput, usersUncheckedCreateWithoutMessages_messages_sender_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_sender_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMessages_messages_recipient_idTousersInput = {
    create?: XOR<usersCreateWithoutMessages_messages_recipient_idTousersInput, usersUncheckedCreateWithoutMessages_messages_recipient_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_recipient_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutMessages_messages_sender_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutMessages_messages_sender_idTousersInput, usersUncheckedCreateWithoutMessages_messages_sender_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_sender_idTousersInput
    upsert?: usersUpsertWithoutMessages_messages_sender_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMessages_messages_sender_idTousersInput, usersUpdateWithoutMessages_messages_sender_idTousersInput>, usersUncheckedUpdateWithoutMessages_messages_sender_idTousersInput>
  }

  export type usersUpdateOneRequiredWithoutMessages_messages_recipient_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutMessages_messages_recipient_idTousersInput, usersUncheckedCreateWithoutMessages_messages_recipient_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_recipient_idTousersInput
    upsert?: usersUpsertWithoutMessages_messages_recipient_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMessages_messages_recipient_idTousersInput, usersUpdateWithoutMessages_messages_recipient_idTousersInput>, usersUncheckedUpdateWithoutMessages_messages_recipient_idTousersInput>
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type sessionsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<sessionsCreateWithoutPaymentsInput, sessionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutPaymentsInput
    connect?: sessionsWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type sessionsUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<sessionsCreateWithoutPaymentsInput, sessionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutPaymentsInput
    upsert?: sessionsUpsertWithoutPaymentsInput
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutPaymentsInput, sessionsUpdateWithoutPaymentsInput>, sessionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type subjectsCreateNestedOneWithoutResourcesInput = {
    create?: XOR<subjectsCreateWithoutResourcesInput, subjectsUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutResourcesInput
    connect?: subjectsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutResourcesInput = {
    create?: XOR<usersCreateWithoutResourcesInput, usersUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: usersCreateOrConnectWithoutResourcesInput
    connect?: usersWhereUniqueInput
  }

  export type session_resourcesCreateNestedManyWithoutResourcesInput = {
    create?: XOR<session_resourcesCreateWithoutResourcesInput, session_resourcesUncheckedCreateWithoutResourcesInput> | session_resourcesCreateWithoutResourcesInput[] | session_resourcesUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutResourcesInput | session_resourcesCreateOrConnectWithoutResourcesInput[]
    createMany?: session_resourcesCreateManyResourcesInputEnvelope
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
  }

  export type session_resourcesUncheckedCreateNestedManyWithoutResourcesInput = {
    create?: XOR<session_resourcesCreateWithoutResourcesInput, session_resourcesUncheckedCreateWithoutResourcesInput> | session_resourcesCreateWithoutResourcesInput[] | session_resourcesUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutResourcesInput | session_resourcesCreateOrConnectWithoutResourcesInput[]
    createMany?: session_resourcesCreateManyResourcesInputEnvelope
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
  }

  export type subjectsUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<subjectsCreateWithoutResourcesInput, subjectsUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutResourcesInput
    upsert?: subjectsUpsertWithoutResourcesInput
    disconnect?: subjectsWhereInput | boolean
    delete?: subjectsWhereInput | boolean
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutResourcesInput, subjectsUpdateWithoutResourcesInput>, subjectsUncheckedUpdateWithoutResourcesInput>
  }

  export type usersUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<usersCreateWithoutResourcesInput, usersUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: usersCreateOrConnectWithoutResourcesInput
    upsert?: usersUpsertWithoutResourcesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutResourcesInput, usersUpdateWithoutResourcesInput>, usersUncheckedUpdateWithoutResourcesInput>
  }

  export type session_resourcesUpdateManyWithoutResourcesNestedInput = {
    create?: XOR<session_resourcesCreateWithoutResourcesInput, session_resourcesUncheckedCreateWithoutResourcesInput> | session_resourcesCreateWithoutResourcesInput[] | session_resourcesUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutResourcesInput | session_resourcesCreateOrConnectWithoutResourcesInput[]
    upsert?: session_resourcesUpsertWithWhereUniqueWithoutResourcesInput | session_resourcesUpsertWithWhereUniqueWithoutResourcesInput[]
    createMany?: session_resourcesCreateManyResourcesInputEnvelope
    set?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    disconnect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    delete?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    update?: session_resourcesUpdateWithWhereUniqueWithoutResourcesInput | session_resourcesUpdateWithWhereUniqueWithoutResourcesInput[]
    updateMany?: session_resourcesUpdateManyWithWhereWithoutResourcesInput | session_resourcesUpdateManyWithWhereWithoutResourcesInput[]
    deleteMany?: session_resourcesScalarWhereInput | session_resourcesScalarWhereInput[]
  }

  export type session_resourcesUncheckedUpdateManyWithoutResourcesNestedInput = {
    create?: XOR<session_resourcesCreateWithoutResourcesInput, session_resourcesUncheckedCreateWithoutResourcesInput> | session_resourcesCreateWithoutResourcesInput[] | session_resourcesUncheckedCreateWithoutResourcesInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutResourcesInput | session_resourcesCreateOrConnectWithoutResourcesInput[]
    upsert?: session_resourcesUpsertWithWhereUniqueWithoutResourcesInput | session_resourcesUpsertWithWhereUniqueWithoutResourcesInput[]
    createMany?: session_resourcesCreateManyResourcesInputEnvelope
    set?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    disconnect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    delete?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    update?: session_resourcesUpdateWithWhereUniqueWithoutResourcesInput | session_resourcesUpdateWithWhereUniqueWithoutResourcesInput[]
    updateMany?: session_resourcesUpdateManyWithWhereWithoutResourcesInput | session_resourcesUpdateManyWithWhereWithoutResourcesInput[]
    deleteMany?: session_resourcesScalarWhereInput | session_resourcesScalarWhereInput[]
  }

  export type sessionsCreateNestedOneWithoutSession_notesInput = {
    create?: XOR<sessionsCreateWithoutSession_notesInput, sessionsUncheckedCreateWithoutSession_notesInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutSession_notesInput
    connect?: sessionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSession_notesInput = {
    create?: XOR<usersCreateWithoutSession_notesInput, usersUncheckedCreateWithoutSession_notesInput>
    connectOrCreate?: usersCreateOrConnectWithoutSession_notesInput
    connect?: usersWhereUniqueInput
  }

  export type sessionsUpdateOneRequiredWithoutSession_notesNestedInput = {
    create?: XOR<sessionsCreateWithoutSession_notesInput, sessionsUncheckedCreateWithoutSession_notesInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutSession_notesInput
    upsert?: sessionsUpsertWithoutSession_notesInput
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutSession_notesInput, sessionsUpdateWithoutSession_notesInput>, sessionsUncheckedUpdateWithoutSession_notesInput>
  }

  export type usersUpdateOneRequiredWithoutSession_notesNestedInput = {
    create?: XOR<usersCreateWithoutSession_notesInput, usersUncheckedCreateWithoutSession_notesInput>
    connectOrCreate?: usersCreateOrConnectWithoutSession_notesInput
    upsert?: usersUpsertWithoutSession_notesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSession_notesInput, usersUpdateWithoutSession_notesInput>, usersUncheckedUpdateWithoutSession_notesInput>
  }

  export type sessionsCreateNestedOneWithoutSession_ratingsInput = {
    create?: XOR<sessionsCreateWithoutSession_ratingsInput, sessionsUncheckedCreateWithoutSession_ratingsInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutSession_ratingsInput
    connect?: sessionsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutSession_ratingsInput = {
    create?: XOR<studentsCreateWithoutSession_ratingsInput, studentsUncheckedCreateWithoutSession_ratingsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutSession_ratingsInput
    connect?: studentsWhereUniqueInput
  }

  export type tutorsCreateNestedOneWithoutSession_ratingsInput = {
    create?: XOR<tutorsCreateWithoutSession_ratingsInput, tutorsUncheckedCreateWithoutSession_ratingsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutSession_ratingsInput
    connect?: tutorsWhereUniqueInput
  }

  export type sessionsUpdateOneRequiredWithoutSession_ratingsNestedInput = {
    create?: XOR<sessionsCreateWithoutSession_ratingsInput, sessionsUncheckedCreateWithoutSession_ratingsInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutSession_ratingsInput
    upsert?: sessionsUpsertWithoutSession_ratingsInput
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutSession_ratingsInput, sessionsUpdateWithoutSession_ratingsInput>, sessionsUncheckedUpdateWithoutSession_ratingsInput>
  }

  export type studentsUpdateOneRequiredWithoutSession_ratingsNestedInput = {
    create?: XOR<studentsCreateWithoutSession_ratingsInput, studentsUncheckedCreateWithoutSession_ratingsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutSession_ratingsInput
    upsert?: studentsUpsertWithoutSession_ratingsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutSession_ratingsInput, studentsUpdateWithoutSession_ratingsInput>, studentsUncheckedUpdateWithoutSession_ratingsInput>
  }

  export type tutorsUpdateOneRequiredWithoutSession_ratingsNestedInput = {
    create?: XOR<tutorsCreateWithoutSession_ratingsInput, tutorsUncheckedCreateWithoutSession_ratingsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutSession_ratingsInput
    upsert?: tutorsUpsertWithoutSession_ratingsInput
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutSession_ratingsInput, tutorsUpdateWithoutSession_ratingsInput>, tutorsUncheckedUpdateWithoutSession_ratingsInput>
  }

  export type sessionsCreateNestedOneWithoutSession_resourcesInput = {
    create?: XOR<sessionsCreateWithoutSession_resourcesInput, sessionsUncheckedCreateWithoutSession_resourcesInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutSession_resourcesInput
    connect?: sessionsWhereUniqueInput
  }

  export type resourcesCreateNestedOneWithoutSession_resourcesInput = {
    create?: XOR<resourcesCreateWithoutSession_resourcesInput, resourcesUncheckedCreateWithoutSession_resourcesInput>
    connectOrCreate?: resourcesCreateOrConnectWithoutSession_resourcesInput
    connect?: resourcesWhereUniqueInput
  }

  export type sessionsUpdateOneRequiredWithoutSession_resourcesNestedInput = {
    create?: XOR<sessionsCreateWithoutSession_resourcesInput, sessionsUncheckedCreateWithoutSession_resourcesInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutSession_resourcesInput
    upsert?: sessionsUpsertWithoutSession_resourcesInput
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutSession_resourcesInput, sessionsUpdateWithoutSession_resourcesInput>, sessionsUncheckedUpdateWithoutSession_resourcesInput>
  }

  export type resourcesUpdateOneRequiredWithoutSession_resourcesNestedInput = {
    create?: XOR<resourcesCreateWithoutSession_resourcesInput, resourcesUncheckedCreateWithoutSession_resourcesInput>
    connectOrCreate?: resourcesCreateOrConnectWithoutSession_resourcesInput
    upsert?: resourcesUpsertWithoutSession_resourcesInput
    connect?: resourcesWhereUniqueInput
    update?: XOR<XOR<resourcesUpdateToOneWithWhereWithoutSession_resourcesInput, resourcesUpdateWithoutSession_resourcesInput>, resourcesUncheckedUpdateWithoutSession_resourcesInput>
  }

  export type paymentsCreateNestedManyWithoutSessionsInput = {
    create?: XOR<paymentsCreateWithoutSessionsInput, paymentsUncheckedCreateWithoutSessionsInput> | paymentsCreateWithoutSessionsInput[] | paymentsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSessionsInput | paymentsCreateOrConnectWithoutSessionsInput[]
    createMany?: paymentsCreateManySessionsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type session_notesCreateNestedManyWithoutSessionsInput = {
    create?: XOR<session_notesCreateWithoutSessionsInput, session_notesUncheckedCreateWithoutSessionsInput> | session_notesCreateWithoutSessionsInput[] | session_notesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutSessionsInput | session_notesCreateOrConnectWithoutSessionsInput[]
    createMany?: session_notesCreateManySessionsInputEnvelope
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
  }

  export type session_ratingsCreateNestedOneWithoutSessionsInput = {
    create?: XOR<session_ratingsCreateWithoutSessionsInput, session_ratingsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: session_ratingsCreateOrConnectWithoutSessionsInput
    connect?: session_ratingsWhereUniqueInput
  }

  export type session_resourcesCreateNestedManyWithoutSessionsInput = {
    create?: XOR<session_resourcesCreateWithoutSessionsInput, session_resourcesUncheckedCreateWithoutSessionsInput> | session_resourcesCreateWithoutSessionsInput[] | session_resourcesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutSessionsInput | session_resourcesCreateOrConnectWithoutSessionsInput[]
    createMany?: session_resourcesCreateManySessionsInputEnvelope
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
  }

  export type tutorsCreateNestedOneWithoutSessionsInput = {
    create?: XOR<tutorsCreateWithoutSessionsInput, tutorsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutSessionsInput
    connect?: tutorsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutSessionsInput = {
    create?: XOR<studentsCreateWithoutSessionsInput, studentsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutSessionsInput
    connect?: studentsWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutSessionsInput = {
    create?: XOR<subjectsCreateWithoutSessionsInput, subjectsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutSessionsInput
    connect?: subjectsWhereUniqueInput
  }

  export type paymentsUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<paymentsCreateWithoutSessionsInput, paymentsUncheckedCreateWithoutSessionsInput> | paymentsCreateWithoutSessionsInput[] | paymentsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSessionsInput | paymentsCreateOrConnectWithoutSessionsInput[]
    createMany?: paymentsCreateManySessionsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type session_notesUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<session_notesCreateWithoutSessionsInput, session_notesUncheckedCreateWithoutSessionsInput> | session_notesCreateWithoutSessionsInput[] | session_notesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutSessionsInput | session_notesCreateOrConnectWithoutSessionsInput[]
    createMany?: session_notesCreateManySessionsInputEnvelope
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
  }

  export type session_ratingsUncheckedCreateNestedOneWithoutSessionsInput = {
    create?: XOR<session_ratingsCreateWithoutSessionsInput, session_ratingsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: session_ratingsCreateOrConnectWithoutSessionsInput
    connect?: session_ratingsWhereUniqueInput
  }

  export type session_resourcesUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<session_resourcesCreateWithoutSessionsInput, session_resourcesUncheckedCreateWithoutSessionsInput> | session_resourcesCreateWithoutSessionsInput[] | session_resourcesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutSessionsInput | session_resourcesCreateOrConnectWithoutSessionsInput[]
    createMany?: session_resourcesCreateManySessionsInputEnvelope
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
  }

  export type paymentsUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<paymentsCreateWithoutSessionsInput, paymentsUncheckedCreateWithoutSessionsInput> | paymentsCreateWithoutSessionsInput[] | paymentsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSessionsInput | paymentsCreateOrConnectWithoutSessionsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutSessionsInput | paymentsUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: paymentsCreateManySessionsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutSessionsInput | paymentsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutSessionsInput | paymentsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type session_notesUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<session_notesCreateWithoutSessionsInput, session_notesUncheckedCreateWithoutSessionsInput> | session_notesCreateWithoutSessionsInput[] | session_notesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutSessionsInput | session_notesCreateOrConnectWithoutSessionsInput[]
    upsert?: session_notesUpsertWithWhereUniqueWithoutSessionsInput | session_notesUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: session_notesCreateManySessionsInputEnvelope
    set?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    disconnect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    delete?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    update?: session_notesUpdateWithWhereUniqueWithoutSessionsInput | session_notesUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: session_notesUpdateManyWithWhereWithoutSessionsInput | session_notesUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: session_notesScalarWhereInput | session_notesScalarWhereInput[]
  }

  export type session_ratingsUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<session_ratingsCreateWithoutSessionsInput, session_ratingsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: session_ratingsCreateOrConnectWithoutSessionsInput
    upsert?: session_ratingsUpsertWithoutSessionsInput
    disconnect?: session_ratingsWhereInput | boolean
    delete?: session_ratingsWhereInput | boolean
    connect?: session_ratingsWhereUniqueInput
    update?: XOR<XOR<session_ratingsUpdateToOneWithWhereWithoutSessionsInput, session_ratingsUpdateWithoutSessionsInput>, session_ratingsUncheckedUpdateWithoutSessionsInput>
  }

  export type session_resourcesUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<session_resourcesCreateWithoutSessionsInput, session_resourcesUncheckedCreateWithoutSessionsInput> | session_resourcesCreateWithoutSessionsInput[] | session_resourcesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutSessionsInput | session_resourcesCreateOrConnectWithoutSessionsInput[]
    upsert?: session_resourcesUpsertWithWhereUniqueWithoutSessionsInput | session_resourcesUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: session_resourcesCreateManySessionsInputEnvelope
    set?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    disconnect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    delete?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    update?: session_resourcesUpdateWithWhereUniqueWithoutSessionsInput | session_resourcesUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: session_resourcesUpdateManyWithWhereWithoutSessionsInput | session_resourcesUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: session_resourcesScalarWhereInput | session_resourcesScalarWhereInput[]
  }

  export type tutorsUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<tutorsCreateWithoutSessionsInput, tutorsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutSessionsInput
    upsert?: tutorsUpsertWithoutSessionsInput
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutSessionsInput, tutorsUpdateWithoutSessionsInput>, tutorsUncheckedUpdateWithoutSessionsInput>
  }

  export type studentsUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<studentsCreateWithoutSessionsInput, studentsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutSessionsInput
    upsert?: studentsUpsertWithoutSessionsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutSessionsInput, studentsUpdateWithoutSessionsInput>, studentsUncheckedUpdateWithoutSessionsInput>
  }

  export type subjectsUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<subjectsCreateWithoutSessionsInput, subjectsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutSessionsInput
    upsert?: subjectsUpsertWithoutSessionsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutSessionsInput, subjectsUpdateWithoutSessionsInput>, subjectsUncheckedUpdateWithoutSessionsInput>
  }

  export type paymentsUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<paymentsCreateWithoutSessionsInput, paymentsUncheckedCreateWithoutSessionsInput> | paymentsCreateWithoutSessionsInput[] | paymentsUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutSessionsInput | paymentsCreateOrConnectWithoutSessionsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutSessionsInput | paymentsUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: paymentsCreateManySessionsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutSessionsInput | paymentsUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutSessionsInput | paymentsUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type session_notesUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<session_notesCreateWithoutSessionsInput, session_notesUncheckedCreateWithoutSessionsInput> | session_notesCreateWithoutSessionsInput[] | session_notesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutSessionsInput | session_notesCreateOrConnectWithoutSessionsInput[]
    upsert?: session_notesUpsertWithWhereUniqueWithoutSessionsInput | session_notesUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: session_notesCreateManySessionsInputEnvelope
    set?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    disconnect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    delete?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    update?: session_notesUpdateWithWhereUniqueWithoutSessionsInput | session_notesUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: session_notesUpdateManyWithWhereWithoutSessionsInput | session_notesUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: session_notesScalarWhereInput | session_notesScalarWhereInput[]
  }

  export type session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<session_ratingsCreateWithoutSessionsInput, session_ratingsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: session_ratingsCreateOrConnectWithoutSessionsInput
    upsert?: session_ratingsUpsertWithoutSessionsInput
    disconnect?: session_ratingsWhereInput | boolean
    delete?: session_ratingsWhereInput | boolean
    connect?: session_ratingsWhereUniqueInput
    update?: XOR<XOR<session_ratingsUpdateToOneWithWhereWithoutSessionsInput, session_ratingsUpdateWithoutSessionsInput>, session_ratingsUncheckedUpdateWithoutSessionsInput>
  }

  export type session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<session_resourcesCreateWithoutSessionsInput, session_resourcesUncheckedCreateWithoutSessionsInput> | session_resourcesCreateWithoutSessionsInput[] | session_resourcesUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: session_resourcesCreateOrConnectWithoutSessionsInput | session_resourcesCreateOrConnectWithoutSessionsInput[]
    upsert?: session_resourcesUpsertWithWhereUniqueWithoutSessionsInput | session_resourcesUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: session_resourcesCreateManySessionsInputEnvelope
    set?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    disconnect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    delete?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    connect?: session_resourcesWhereUniqueInput | session_resourcesWhereUniqueInput[]
    update?: session_resourcesUpdateWithWhereUniqueWithoutSessionsInput | session_resourcesUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: session_resourcesUpdateManyWithWhereWithoutSessionsInput | session_resourcesUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: session_resourcesScalarWhereInput | session_resourcesScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutStudent_subject_interestsInput = {
    create?: XOR<studentsCreateWithoutStudent_subject_interestsInput, studentsUncheckedCreateWithoutStudent_subject_interestsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_subject_interestsInput
    connect?: studentsWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutStudent_subject_interestsInput = {
    create?: XOR<subjectsCreateWithoutStudent_subject_interestsInput, subjectsUncheckedCreateWithoutStudent_subject_interestsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutStudent_subject_interestsInput
    connect?: subjectsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutStudent_subject_interestsNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_subject_interestsInput, studentsUncheckedCreateWithoutStudent_subject_interestsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_subject_interestsInput
    upsert?: studentsUpsertWithoutStudent_subject_interestsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_subject_interestsInput, studentsUpdateWithoutStudent_subject_interestsInput>, studentsUncheckedUpdateWithoutStudent_subject_interestsInput>
  }

  export type subjectsUpdateOneRequiredWithoutStudent_subject_interestsNestedInput = {
    create?: XOR<subjectsCreateWithoutStudent_subject_interestsInput, subjectsUncheckedCreateWithoutStudent_subject_interestsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutStudent_subject_interestsInput
    upsert?: subjectsUpsertWithoutStudent_subject_interestsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutStudent_subject_interestsInput, subjectsUpdateWithoutStudent_subject_interestsInput>, subjectsUncheckedUpdateWithoutStudent_subject_interestsInput>
  }

  export type group_session_participantsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<group_session_participantsCreateWithoutStudentsInput, group_session_participantsUncheckedCreateWithoutStudentsInput> | group_session_participantsCreateWithoutStudentsInput[] | group_session_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutStudentsInput | group_session_participantsCreateOrConnectWithoutStudentsInput[]
    createMany?: group_session_participantsCreateManyStudentsInputEnvelope
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
  }

  export type session_ratingsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<session_ratingsCreateWithoutStudentsInput, session_ratingsUncheckedCreateWithoutStudentsInput> | session_ratingsCreateWithoutStudentsInput[] | session_ratingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutStudentsInput | session_ratingsCreateOrConnectWithoutStudentsInput[]
    createMany?: session_ratingsCreateManyStudentsInputEnvelope
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<sessionsCreateWithoutStudentsInput, sessionsUncheckedCreateWithoutStudentsInput> | sessionsCreateWithoutStudentsInput[] | sessionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutStudentsInput | sessionsCreateOrConnectWithoutStudentsInput[]
    createMany?: sessionsCreateManyStudentsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type student_subject_interestsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_subject_interestsCreateWithoutStudentsInput, student_subject_interestsUncheckedCreateWithoutStudentsInput> | student_subject_interestsCreateWithoutStudentsInput[] | student_subject_interestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutStudentsInput | student_subject_interestsCreateOrConnectWithoutStudentsInput[]
    createMany?: student_subject_interestsCreateManyStudentsInputEnvelope
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutStudentsInput = {
    create?: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentsInput
    connect?: usersWhereUniqueInput
  }

  export type subscriptionsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<subscriptionsCreateWithoutStudentsInput, subscriptionsUncheckedCreateWithoutStudentsInput> | subscriptionsCreateWithoutStudentsInput[] | subscriptionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutStudentsInput | subscriptionsCreateOrConnectWithoutStudentsInput[]
    createMany?: subscriptionsCreateManyStudentsInputEnvelope
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
  }

  export type group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<group_session_participantsCreateWithoutStudentsInput, group_session_participantsUncheckedCreateWithoutStudentsInput> | group_session_participantsCreateWithoutStudentsInput[] | group_session_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutStudentsInput | group_session_participantsCreateOrConnectWithoutStudentsInput[]
    createMany?: group_session_participantsCreateManyStudentsInputEnvelope
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
  }

  export type session_ratingsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<session_ratingsCreateWithoutStudentsInput, session_ratingsUncheckedCreateWithoutStudentsInput> | session_ratingsCreateWithoutStudentsInput[] | session_ratingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutStudentsInput | session_ratingsCreateOrConnectWithoutStudentsInput[]
    createMany?: session_ratingsCreateManyStudentsInputEnvelope
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<sessionsCreateWithoutStudentsInput, sessionsUncheckedCreateWithoutStudentsInput> | sessionsCreateWithoutStudentsInput[] | sessionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutStudentsInput | sessionsCreateOrConnectWithoutStudentsInput[]
    createMany?: sessionsCreateManyStudentsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_subject_interestsCreateWithoutStudentsInput, student_subject_interestsUncheckedCreateWithoutStudentsInput> | student_subject_interestsCreateWithoutStudentsInput[] | student_subject_interestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutStudentsInput | student_subject_interestsCreateOrConnectWithoutStudentsInput[]
    createMany?: student_subject_interestsCreateManyStudentsInputEnvelope
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
  }

  export type subscriptionsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<subscriptionsCreateWithoutStudentsInput, subscriptionsUncheckedCreateWithoutStudentsInput> | subscriptionsCreateWithoutStudentsInput[] | subscriptionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutStudentsInput | subscriptionsCreateOrConnectWithoutStudentsInput[]
    createMany?: subscriptionsCreateManyStudentsInputEnvelope
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
  }

  export type group_session_participantsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<group_session_participantsCreateWithoutStudentsInput, group_session_participantsUncheckedCreateWithoutStudentsInput> | group_session_participantsCreateWithoutStudentsInput[] | group_session_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutStudentsInput | group_session_participantsCreateOrConnectWithoutStudentsInput[]
    upsert?: group_session_participantsUpsertWithWhereUniqueWithoutStudentsInput | group_session_participantsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: group_session_participantsCreateManyStudentsInputEnvelope
    set?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    disconnect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    delete?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    update?: group_session_participantsUpdateWithWhereUniqueWithoutStudentsInput | group_session_participantsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: group_session_participantsUpdateManyWithWhereWithoutStudentsInput | group_session_participantsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: group_session_participantsScalarWhereInput | group_session_participantsScalarWhereInput[]
  }

  export type session_ratingsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<session_ratingsCreateWithoutStudentsInput, session_ratingsUncheckedCreateWithoutStudentsInput> | session_ratingsCreateWithoutStudentsInput[] | session_ratingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutStudentsInput | session_ratingsCreateOrConnectWithoutStudentsInput[]
    upsert?: session_ratingsUpsertWithWhereUniqueWithoutStudentsInput | session_ratingsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: session_ratingsCreateManyStudentsInputEnvelope
    set?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    disconnect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    delete?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    update?: session_ratingsUpdateWithWhereUniqueWithoutStudentsInput | session_ratingsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: session_ratingsUpdateManyWithWhereWithoutStudentsInput | session_ratingsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: session_ratingsScalarWhereInput | session_ratingsScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<sessionsCreateWithoutStudentsInput, sessionsUncheckedCreateWithoutStudentsInput> | sessionsCreateWithoutStudentsInput[] | sessionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutStudentsInput | sessionsCreateOrConnectWithoutStudentsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutStudentsInput | sessionsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: sessionsCreateManyStudentsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutStudentsInput | sessionsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutStudentsInput | sessionsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type student_subject_interestsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_subject_interestsCreateWithoutStudentsInput, student_subject_interestsUncheckedCreateWithoutStudentsInput> | student_subject_interestsCreateWithoutStudentsInput[] | student_subject_interestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutStudentsInput | student_subject_interestsCreateOrConnectWithoutStudentsInput[]
    upsert?: student_subject_interestsUpsertWithWhereUniqueWithoutStudentsInput | student_subject_interestsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_subject_interestsCreateManyStudentsInputEnvelope
    set?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    disconnect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    delete?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    update?: student_subject_interestsUpdateWithWhereUniqueWithoutStudentsInput | student_subject_interestsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_subject_interestsUpdateManyWithWhereWithoutStudentsInput | student_subject_interestsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_subject_interestsScalarWhereInput | student_subject_interestsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentsInput
    upsert?: usersUpsertWithoutStudentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudentsInput, usersUpdateWithoutStudentsInput>, usersUncheckedUpdateWithoutStudentsInput>
  }

  export type subscriptionsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<subscriptionsCreateWithoutStudentsInput, subscriptionsUncheckedCreateWithoutStudentsInput> | subscriptionsCreateWithoutStudentsInput[] | subscriptionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutStudentsInput | subscriptionsCreateOrConnectWithoutStudentsInput[]
    upsert?: subscriptionsUpsertWithWhereUniqueWithoutStudentsInput | subscriptionsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: subscriptionsCreateManyStudentsInputEnvelope
    set?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    disconnect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    delete?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    update?: subscriptionsUpdateWithWhereUniqueWithoutStudentsInput | subscriptionsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: subscriptionsUpdateManyWithWhereWithoutStudentsInput | subscriptionsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
  }

  export type group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<group_session_participantsCreateWithoutStudentsInput, group_session_participantsUncheckedCreateWithoutStudentsInput> | group_session_participantsCreateWithoutStudentsInput[] | group_session_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: group_session_participantsCreateOrConnectWithoutStudentsInput | group_session_participantsCreateOrConnectWithoutStudentsInput[]
    upsert?: group_session_participantsUpsertWithWhereUniqueWithoutStudentsInput | group_session_participantsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: group_session_participantsCreateManyStudentsInputEnvelope
    set?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    disconnect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    delete?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    connect?: group_session_participantsWhereUniqueInput | group_session_participantsWhereUniqueInput[]
    update?: group_session_participantsUpdateWithWhereUniqueWithoutStudentsInput | group_session_participantsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: group_session_participantsUpdateManyWithWhereWithoutStudentsInput | group_session_participantsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: group_session_participantsScalarWhereInput | group_session_participantsScalarWhereInput[]
  }

  export type session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<session_ratingsCreateWithoutStudentsInput, session_ratingsUncheckedCreateWithoutStudentsInput> | session_ratingsCreateWithoutStudentsInput[] | session_ratingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutStudentsInput | session_ratingsCreateOrConnectWithoutStudentsInput[]
    upsert?: session_ratingsUpsertWithWhereUniqueWithoutStudentsInput | session_ratingsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: session_ratingsCreateManyStudentsInputEnvelope
    set?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    disconnect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    delete?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    update?: session_ratingsUpdateWithWhereUniqueWithoutStudentsInput | session_ratingsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: session_ratingsUpdateManyWithWhereWithoutStudentsInput | session_ratingsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: session_ratingsScalarWhereInput | session_ratingsScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<sessionsCreateWithoutStudentsInput, sessionsUncheckedCreateWithoutStudentsInput> | sessionsCreateWithoutStudentsInput[] | sessionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutStudentsInput | sessionsCreateOrConnectWithoutStudentsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutStudentsInput | sessionsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: sessionsCreateManyStudentsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutStudentsInput | sessionsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutStudentsInput | sessionsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_subject_interestsCreateWithoutStudentsInput, student_subject_interestsUncheckedCreateWithoutStudentsInput> | student_subject_interestsCreateWithoutStudentsInput[] | student_subject_interestsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutStudentsInput | student_subject_interestsCreateOrConnectWithoutStudentsInput[]
    upsert?: student_subject_interestsUpsertWithWhereUniqueWithoutStudentsInput | student_subject_interestsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_subject_interestsCreateManyStudentsInputEnvelope
    set?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    disconnect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    delete?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    update?: student_subject_interestsUpdateWithWhereUniqueWithoutStudentsInput | student_subject_interestsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_subject_interestsUpdateManyWithWhereWithoutStudentsInput | student_subject_interestsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_subject_interestsScalarWhereInput | student_subject_interestsScalarWhereInput[]
  }

  export type subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<subscriptionsCreateWithoutStudentsInput, subscriptionsUncheckedCreateWithoutStudentsInput> | subscriptionsCreateWithoutStudentsInput[] | subscriptionsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutStudentsInput | subscriptionsCreateOrConnectWithoutStudentsInput[]
    upsert?: subscriptionsUpsertWithWhereUniqueWithoutStudentsInput | subscriptionsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: subscriptionsCreateManyStudentsInputEnvelope
    set?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    disconnect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    delete?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    update?: subscriptionsUpdateWithWhereUniqueWithoutStudentsInput | subscriptionsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: subscriptionsUpdateManyWithWhereWithoutStudentsInput | subscriptionsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
  }

  export type subjectsCreateNestedManyWithoutSubject_categoriesInput = {
    create?: XOR<subjectsCreateWithoutSubject_categoriesInput, subjectsUncheckedCreateWithoutSubject_categoriesInput> | subjectsCreateWithoutSubject_categoriesInput[] | subjectsUncheckedCreateWithoutSubject_categoriesInput[]
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_categoriesInput | subjectsCreateOrConnectWithoutSubject_categoriesInput[]
    createMany?: subjectsCreateManySubject_categoriesInputEnvelope
    connect?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
  }

  export type subjectsUncheckedCreateNestedManyWithoutSubject_categoriesInput = {
    create?: XOR<subjectsCreateWithoutSubject_categoriesInput, subjectsUncheckedCreateWithoutSubject_categoriesInput> | subjectsCreateWithoutSubject_categoriesInput[] | subjectsUncheckedCreateWithoutSubject_categoriesInput[]
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_categoriesInput | subjectsCreateOrConnectWithoutSubject_categoriesInput[]
    createMany?: subjectsCreateManySubject_categoriesInputEnvelope
    connect?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
  }

  export type subjectsUpdateManyWithoutSubject_categoriesNestedInput = {
    create?: XOR<subjectsCreateWithoutSubject_categoriesInput, subjectsUncheckedCreateWithoutSubject_categoriesInput> | subjectsCreateWithoutSubject_categoriesInput[] | subjectsUncheckedCreateWithoutSubject_categoriesInput[]
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_categoriesInput | subjectsCreateOrConnectWithoutSubject_categoriesInput[]
    upsert?: subjectsUpsertWithWhereUniqueWithoutSubject_categoriesInput | subjectsUpsertWithWhereUniqueWithoutSubject_categoriesInput[]
    createMany?: subjectsCreateManySubject_categoriesInputEnvelope
    set?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    disconnect?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    delete?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    connect?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    update?: subjectsUpdateWithWhereUniqueWithoutSubject_categoriesInput | subjectsUpdateWithWhereUniqueWithoutSubject_categoriesInput[]
    updateMany?: subjectsUpdateManyWithWhereWithoutSubject_categoriesInput | subjectsUpdateManyWithWhereWithoutSubject_categoriesInput[]
    deleteMany?: subjectsScalarWhereInput | subjectsScalarWhereInput[]
  }

  export type subjectsUncheckedUpdateManyWithoutSubject_categoriesNestedInput = {
    create?: XOR<subjectsCreateWithoutSubject_categoriesInput, subjectsUncheckedCreateWithoutSubject_categoriesInput> | subjectsCreateWithoutSubject_categoriesInput[] | subjectsUncheckedCreateWithoutSubject_categoriesInput[]
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_categoriesInput | subjectsCreateOrConnectWithoutSubject_categoriesInput[]
    upsert?: subjectsUpsertWithWhereUniqueWithoutSubject_categoriesInput | subjectsUpsertWithWhereUniqueWithoutSubject_categoriesInput[]
    createMany?: subjectsCreateManySubject_categoriesInputEnvelope
    set?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    disconnect?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    delete?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    connect?: subjectsWhereUniqueInput | subjectsWhereUniqueInput[]
    update?: subjectsUpdateWithWhereUniqueWithoutSubject_categoriesInput | subjectsUpdateWithWhereUniqueWithoutSubject_categoriesInput[]
    updateMany?: subjectsUpdateManyWithWhereWithoutSubject_categoriesInput | subjectsUpdateManyWithWhereWithoutSubject_categoriesInput[]
    deleteMany?: subjectsScalarWhereInput | subjectsScalarWhereInput[]
  }

  export type group_sessionsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<group_sessionsCreateWithoutSubjectsInput, group_sessionsUncheckedCreateWithoutSubjectsInput> | group_sessionsCreateWithoutSubjectsInput[] | group_sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutSubjectsInput | group_sessionsCreateOrConnectWithoutSubjectsInput[]
    createMany?: group_sessionsCreateManySubjectsInputEnvelope
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
  }

  export type resourcesCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<resourcesCreateWithoutSubjectsInput, resourcesUncheckedCreateWithoutSubjectsInput> | resourcesCreateWithoutSubjectsInput[] | resourcesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutSubjectsInput | resourcesCreateOrConnectWithoutSubjectsInput[]
    createMany?: resourcesCreateManySubjectsInputEnvelope
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<sessionsCreateWithoutSubjectsInput, sessionsUncheckedCreateWithoutSubjectsInput> | sessionsCreateWithoutSubjectsInput[] | sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutSubjectsInput | sessionsCreateOrConnectWithoutSubjectsInput[]
    createMany?: sessionsCreateManySubjectsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type student_subject_interestsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<student_subject_interestsCreateWithoutSubjectsInput, student_subject_interestsUncheckedCreateWithoutSubjectsInput> | student_subject_interestsCreateWithoutSubjectsInput[] | student_subject_interestsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutSubjectsInput | student_subject_interestsCreateOrConnectWithoutSubjectsInput[]
    createMany?: student_subject_interestsCreateManySubjectsInputEnvelope
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
  }

  export type subject_categoriesCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<subject_categoriesCreateWithoutSubjectsInput, subject_categoriesUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: subject_categoriesCreateOrConnectWithoutSubjectsInput
    connect?: subject_categoriesWhereUniqueInput
  }

  export type tutor_subjectsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<tutor_subjectsCreateWithoutSubjectsInput, tutor_subjectsUncheckedCreateWithoutSubjectsInput> | tutor_subjectsCreateWithoutSubjectsInput[] | tutor_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutSubjectsInput | tutor_subjectsCreateOrConnectWithoutSubjectsInput[]
    createMany?: tutor_subjectsCreateManySubjectsInputEnvelope
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
  }

  export type group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<group_sessionsCreateWithoutSubjectsInput, group_sessionsUncheckedCreateWithoutSubjectsInput> | group_sessionsCreateWithoutSubjectsInput[] | group_sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutSubjectsInput | group_sessionsCreateOrConnectWithoutSubjectsInput[]
    createMany?: group_sessionsCreateManySubjectsInputEnvelope
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
  }

  export type resourcesUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<resourcesCreateWithoutSubjectsInput, resourcesUncheckedCreateWithoutSubjectsInput> | resourcesCreateWithoutSubjectsInput[] | resourcesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutSubjectsInput | resourcesCreateOrConnectWithoutSubjectsInput[]
    createMany?: resourcesCreateManySubjectsInputEnvelope
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<sessionsCreateWithoutSubjectsInput, sessionsUncheckedCreateWithoutSubjectsInput> | sessionsCreateWithoutSubjectsInput[] | sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutSubjectsInput | sessionsCreateOrConnectWithoutSubjectsInput[]
    createMany?: sessionsCreateManySubjectsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<student_subject_interestsCreateWithoutSubjectsInput, student_subject_interestsUncheckedCreateWithoutSubjectsInput> | student_subject_interestsCreateWithoutSubjectsInput[] | student_subject_interestsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutSubjectsInput | student_subject_interestsCreateOrConnectWithoutSubjectsInput[]
    createMany?: student_subject_interestsCreateManySubjectsInputEnvelope
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
  }

  export type tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<tutor_subjectsCreateWithoutSubjectsInput, tutor_subjectsUncheckedCreateWithoutSubjectsInput> | tutor_subjectsCreateWithoutSubjectsInput[] | tutor_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutSubjectsInput | tutor_subjectsCreateOrConnectWithoutSubjectsInput[]
    createMany?: tutor_subjectsCreateManySubjectsInputEnvelope
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
  }

  export type group_sessionsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<group_sessionsCreateWithoutSubjectsInput, group_sessionsUncheckedCreateWithoutSubjectsInput> | group_sessionsCreateWithoutSubjectsInput[] | group_sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutSubjectsInput | group_sessionsCreateOrConnectWithoutSubjectsInput[]
    upsert?: group_sessionsUpsertWithWhereUniqueWithoutSubjectsInput | group_sessionsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: group_sessionsCreateManySubjectsInputEnvelope
    set?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    disconnect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    delete?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    update?: group_sessionsUpdateWithWhereUniqueWithoutSubjectsInput | group_sessionsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: group_sessionsUpdateManyWithWhereWithoutSubjectsInput | group_sessionsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: group_sessionsScalarWhereInput | group_sessionsScalarWhereInput[]
  }

  export type resourcesUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<resourcesCreateWithoutSubjectsInput, resourcesUncheckedCreateWithoutSubjectsInput> | resourcesCreateWithoutSubjectsInput[] | resourcesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutSubjectsInput | resourcesCreateOrConnectWithoutSubjectsInput[]
    upsert?: resourcesUpsertWithWhereUniqueWithoutSubjectsInput | resourcesUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: resourcesCreateManySubjectsInputEnvelope
    set?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    disconnect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    delete?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    update?: resourcesUpdateWithWhereUniqueWithoutSubjectsInput | resourcesUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: resourcesUpdateManyWithWhereWithoutSubjectsInput | resourcesUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: resourcesScalarWhereInput | resourcesScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<sessionsCreateWithoutSubjectsInput, sessionsUncheckedCreateWithoutSubjectsInput> | sessionsCreateWithoutSubjectsInput[] | sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutSubjectsInput | sessionsCreateOrConnectWithoutSubjectsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutSubjectsInput | sessionsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: sessionsCreateManySubjectsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutSubjectsInput | sessionsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutSubjectsInput | sessionsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type student_subject_interestsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<student_subject_interestsCreateWithoutSubjectsInput, student_subject_interestsUncheckedCreateWithoutSubjectsInput> | student_subject_interestsCreateWithoutSubjectsInput[] | student_subject_interestsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutSubjectsInput | student_subject_interestsCreateOrConnectWithoutSubjectsInput[]
    upsert?: student_subject_interestsUpsertWithWhereUniqueWithoutSubjectsInput | student_subject_interestsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: student_subject_interestsCreateManySubjectsInputEnvelope
    set?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    disconnect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    delete?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    update?: student_subject_interestsUpdateWithWhereUniqueWithoutSubjectsInput | student_subject_interestsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: student_subject_interestsUpdateManyWithWhereWithoutSubjectsInput | student_subject_interestsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: student_subject_interestsScalarWhereInput | student_subject_interestsScalarWhereInput[]
  }

  export type subject_categoriesUpdateOneWithoutSubjectsNestedInput = {
    create?: XOR<subject_categoriesCreateWithoutSubjectsInput, subject_categoriesUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: subject_categoriesCreateOrConnectWithoutSubjectsInput
    upsert?: subject_categoriesUpsertWithoutSubjectsInput
    disconnect?: subject_categoriesWhereInput | boolean
    delete?: subject_categoriesWhereInput | boolean
    connect?: subject_categoriesWhereUniqueInput
    update?: XOR<XOR<subject_categoriesUpdateToOneWithWhereWithoutSubjectsInput, subject_categoriesUpdateWithoutSubjectsInput>, subject_categoriesUncheckedUpdateWithoutSubjectsInput>
  }

  export type tutor_subjectsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<tutor_subjectsCreateWithoutSubjectsInput, tutor_subjectsUncheckedCreateWithoutSubjectsInput> | tutor_subjectsCreateWithoutSubjectsInput[] | tutor_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutSubjectsInput | tutor_subjectsCreateOrConnectWithoutSubjectsInput[]
    upsert?: tutor_subjectsUpsertWithWhereUniqueWithoutSubjectsInput | tutor_subjectsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: tutor_subjectsCreateManySubjectsInputEnvelope
    set?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    disconnect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    delete?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    update?: tutor_subjectsUpdateWithWhereUniqueWithoutSubjectsInput | tutor_subjectsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: tutor_subjectsUpdateManyWithWhereWithoutSubjectsInput | tutor_subjectsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: tutor_subjectsScalarWhereInput | tutor_subjectsScalarWhereInput[]
  }

  export type group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<group_sessionsCreateWithoutSubjectsInput, group_sessionsUncheckedCreateWithoutSubjectsInput> | group_sessionsCreateWithoutSubjectsInput[] | group_sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutSubjectsInput | group_sessionsCreateOrConnectWithoutSubjectsInput[]
    upsert?: group_sessionsUpsertWithWhereUniqueWithoutSubjectsInput | group_sessionsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: group_sessionsCreateManySubjectsInputEnvelope
    set?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    disconnect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    delete?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    update?: group_sessionsUpdateWithWhereUniqueWithoutSubjectsInput | group_sessionsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: group_sessionsUpdateManyWithWhereWithoutSubjectsInput | group_sessionsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: group_sessionsScalarWhereInput | group_sessionsScalarWhereInput[]
  }

  export type resourcesUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<resourcesCreateWithoutSubjectsInput, resourcesUncheckedCreateWithoutSubjectsInput> | resourcesCreateWithoutSubjectsInput[] | resourcesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutSubjectsInput | resourcesCreateOrConnectWithoutSubjectsInput[]
    upsert?: resourcesUpsertWithWhereUniqueWithoutSubjectsInput | resourcesUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: resourcesCreateManySubjectsInputEnvelope
    set?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    disconnect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    delete?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    update?: resourcesUpdateWithWhereUniqueWithoutSubjectsInput | resourcesUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: resourcesUpdateManyWithWhereWithoutSubjectsInput | resourcesUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: resourcesScalarWhereInput | resourcesScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<sessionsCreateWithoutSubjectsInput, sessionsUncheckedCreateWithoutSubjectsInput> | sessionsCreateWithoutSubjectsInput[] | sessionsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutSubjectsInput | sessionsCreateOrConnectWithoutSubjectsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutSubjectsInput | sessionsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: sessionsCreateManySubjectsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutSubjectsInput | sessionsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutSubjectsInput | sessionsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<student_subject_interestsCreateWithoutSubjectsInput, student_subject_interestsUncheckedCreateWithoutSubjectsInput> | student_subject_interestsCreateWithoutSubjectsInput[] | student_subject_interestsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: student_subject_interestsCreateOrConnectWithoutSubjectsInput | student_subject_interestsCreateOrConnectWithoutSubjectsInput[]
    upsert?: student_subject_interestsUpsertWithWhereUniqueWithoutSubjectsInput | student_subject_interestsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: student_subject_interestsCreateManySubjectsInputEnvelope
    set?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    disconnect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    delete?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    connect?: student_subject_interestsWhereUniqueInput | student_subject_interestsWhereUniqueInput[]
    update?: student_subject_interestsUpdateWithWhereUniqueWithoutSubjectsInput | student_subject_interestsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: student_subject_interestsUpdateManyWithWhereWithoutSubjectsInput | student_subject_interestsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: student_subject_interestsScalarWhereInput | student_subject_interestsScalarWhereInput[]
  }

  export type tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<tutor_subjectsCreateWithoutSubjectsInput, tutor_subjectsUncheckedCreateWithoutSubjectsInput> | tutor_subjectsCreateWithoutSubjectsInput[] | tutor_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutSubjectsInput | tutor_subjectsCreateOrConnectWithoutSubjectsInput[]
    upsert?: tutor_subjectsUpsertWithWhereUniqueWithoutSubjectsInput | tutor_subjectsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: tutor_subjectsCreateManySubjectsInputEnvelope
    set?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    disconnect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    delete?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    update?: tutor_subjectsUpdateWithWhereUniqueWithoutSubjectsInput | tutor_subjectsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: tutor_subjectsUpdateManyWithWhereWithoutSubjectsInput | tutor_subjectsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: tutor_subjectsScalarWhereInput | tutor_subjectsScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<studentsCreateWithoutSubscriptionsInput, studentsUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutSubscriptionsInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<studentsCreateWithoutSubscriptionsInput, studentsUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutSubscriptionsInput
    upsert?: studentsUpsertWithoutSubscriptionsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutSubscriptionsInput, studentsUpdateWithoutSubscriptionsInput>, studentsUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type tutorsCreateNestedOneWithoutTutor_availabilityInput = {
    create?: XOR<tutorsCreateWithoutTutor_availabilityInput, tutorsUncheckedCreateWithoutTutor_availabilityInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutTutor_availabilityInput
    connect?: tutorsWhereUniqueInput
  }

  export type tutorsUpdateOneRequiredWithoutTutor_availabilityNestedInput = {
    create?: XOR<tutorsCreateWithoutTutor_availabilityInput, tutorsUncheckedCreateWithoutTutor_availabilityInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutTutor_availabilityInput
    upsert?: tutorsUpsertWithoutTutor_availabilityInput
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutTutor_availabilityInput, tutorsUpdateWithoutTutor_availabilityInput>, tutorsUncheckedUpdateWithoutTutor_availabilityInput>
  }

  export type tutorsCreateNestedOneWithoutTutor_subjectsInput = {
    create?: XOR<tutorsCreateWithoutTutor_subjectsInput, tutorsUncheckedCreateWithoutTutor_subjectsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutTutor_subjectsInput
    connect?: tutorsWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutTutor_subjectsInput = {
    create?: XOR<subjectsCreateWithoutTutor_subjectsInput, subjectsUncheckedCreateWithoutTutor_subjectsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTutor_subjectsInput
    connect?: subjectsWhereUniqueInput
  }

  export type tutorsUpdateOneRequiredWithoutTutor_subjectsNestedInput = {
    create?: XOR<tutorsCreateWithoutTutor_subjectsInput, tutorsUncheckedCreateWithoutTutor_subjectsInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutTutor_subjectsInput
    upsert?: tutorsUpsertWithoutTutor_subjectsInput
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutTutor_subjectsInput, tutorsUpdateWithoutTutor_subjectsInput>, tutorsUncheckedUpdateWithoutTutor_subjectsInput>
  }

  export type subjectsUpdateOneRequiredWithoutTutor_subjectsNestedInput = {
    create?: XOR<subjectsCreateWithoutTutor_subjectsInput, subjectsUncheckedCreateWithoutTutor_subjectsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTutor_subjectsInput
    upsert?: subjectsUpsertWithoutTutor_subjectsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutTutor_subjectsInput, subjectsUpdateWithoutTutor_subjectsInput>, subjectsUncheckedUpdateWithoutTutor_subjectsInput>
  }

  export type group_sessionsCreateNestedManyWithoutTutorsInput = {
    create?: XOR<group_sessionsCreateWithoutTutorsInput, group_sessionsUncheckedCreateWithoutTutorsInput> | group_sessionsCreateWithoutTutorsInput[] | group_sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutTutorsInput | group_sessionsCreateOrConnectWithoutTutorsInput[]
    createMany?: group_sessionsCreateManyTutorsInputEnvelope
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
  }

  export type session_ratingsCreateNestedManyWithoutTutorsInput = {
    create?: XOR<session_ratingsCreateWithoutTutorsInput, session_ratingsUncheckedCreateWithoutTutorsInput> | session_ratingsCreateWithoutTutorsInput[] | session_ratingsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutTutorsInput | session_ratingsCreateOrConnectWithoutTutorsInput[]
    createMany?: session_ratingsCreateManyTutorsInputEnvelope
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutTutorsInput = {
    create?: XOR<sessionsCreateWithoutTutorsInput, sessionsUncheckedCreateWithoutTutorsInput> | sessionsCreateWithoutTutorsInput[] | sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutTutorsInput | sessionsCreateOrConnectWithoutTutorsInput[]
    createMany?: sessionsCreateManyTutorsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type tutor_availabilityCreateNestedManyWithoutTutorsInput = {
    create?: XOR<tutor_availabilityCreateWithoutTutorsInput, tutor_availabilityUncheckedCreateWithoutTutorsInput> | tutor_availabilityCreateWithoutTutorsInput[] | tutor_availabilityUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_availabilityCreateOrConnectWithoutTutorsInput | tutor_availabilityCreateOrConnectWithoutTutorsInput[]
    createMany?: tutor_availabilityCreateManyTutorsInputEnvelope
    connect?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
  }

  export type tutor_subjectsCreateNestedManyWithoutTutorsInput = {
    create?: XOR<tutor_subjectsCreateWithoutTutorsInput, tutor_subjectsUncheckedCreateWithoutTutorsInput> | tutor_subjectsCreateWithoutTutorsInput[] | tutor_subjectsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutTutorsInput | tutor_subjectsCreateOrConnectWithoutTutorsInput[]
    createMany?: tutor_subjectsCreateManyTutorsInputEnvelope
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTutorsInput = {
    create?: XOR<usersCreateWithoutTutorsInput, usersUncheckedCreateWithoutTutorsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTutorsInput
    connect?: usersWhereUniqueInput
  }

  export type group_sessionsUncheckedCreateNestedManyWithoutTutorsInput = {
    create?: XOR<group_sessionsCreateWithoutTutorsInput, group_sessionsUncheckedCreateWithoutTutorsInput> | group_sessionsCreateWithoutTutorsInput[] | group_sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutTutorsInput | group_sessionsCreateOrConnectWithoutTutorsInput[]
    createMany?: group_sessionsCreateManyTutorsInputEnvelope
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
  }

  export type session_ratingsUncheckedCreateNestedManyWithoutTutorsInput = {
    create?: XOR<session_ratingsCreateWithoutTutorsInput, session_ratingsUncheckedCreateWithoutTutorsInput> | session_ratingsCreateWithoutTutorsInput[] | session_ratingsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutTutorsInput | session_ratingsCreateOrConnectWithoutTutorsInput[]
    createMany?: session_ratingsCreateManyTutorsInputEnvelope
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutTutorsInput = {
    create?: XOR<sessionsCreateWithoutTutorsInput, sessionsUncheckedCreateWithoutTutorsInput> | sessionsCreateWithoutTutorsInput[] | sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutTutorsInput | sessionsCreateOrConnectWithoutTutorsInput[]
    createMany?: sessionsCreateManyTutorsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput = {
    create?: XOR<tutor_availabilityCreateWithoutTutorsInput, tutor_availabilityUncheckedCreateWithoutTutorsInput> | tutor_availabilityCreateWithoutTutorsInput[] | tutor_availabilityUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_availabilityCreateOrConnectWithoutTutorsInput | tutor_availabilityCreateOrConnectWithoutTutorsInput[]
    createMany?: tutor_availabilityCreateManyTutorsInputEnvelope
    connect?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
  }

  export type tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput = {
    create?: XOR<tutor_subjectsCreateWithoutTutorsInput, tutor_subjectsUncheckedCreateWithoutTutorsInput> | tutor_subjectsCreateWithoutTutorsInput[] | tutor_subjectsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutTutorsInput | tutor_subjectsCreateOrConnectWithoutTutorsInput[]
    createMany?: tutor_subjectsCreateManyTutorsInputEnvelope
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
  }

  export type group_sessionsUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<group_sessionsCreateWithoutTutorsInput, group_sessionsUncheckedCreateWithoutTutorsInput> | group_sessionsCreateWithoutTutorsInput[] | group_sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutTutorsInput | group_sessionsCreateOrConnectWithoutTutorsInput[]
    upsert?: group_sessionsUpsertWithWhereUniqueWithoutTutorsInput | group_sessionsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: group_sessionsCreateManyTutorsInputEnvelope
    set?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    disconnect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    delete?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    update?: group_sessionsUpdateWithWhereUniqueWithoutTutorsInput | group_sessionsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: group_sessionsUpdateManyWithWhereWithoutTutorsInput | group_sessionsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: group_sessionsScalarWhereInput | group_sessionsScalarWhereInput[]
  }

  export type session_ratingsUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<session_ratingsCreateWithoutTutorsInput, session_ratingsUncheckedCreateWithoutTutorsInput> | session_ratingsCreateWithoutTutorsInput[] | session_ratingsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutTutorsInput | session_ratingsCreateOrConnectWithoutTutorsInput[]
    upsert?: session_ratingsUpsertWithWhereUniqueWithoutTutorsInput | session_ratingsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: session_ratingsCreateManyTutorsInputEnvelope
    set?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    disconnect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    delete?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    update?: session_ratingsUpdateWithWhereUniqueWithoutTutorsInput | session_ratingsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: session_ratingsUpdateManyWithWhereWithoutTutorsInput | session_ratingsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: session_ratingsScalarWhereInput | session_ratingsScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<sessionsCreateWithoutTutorsInput, sessionsUncheckedCreateWithoutTutorsInput> | sessionsCreateWithoutTutorsInput[] | sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutTutorsInput | sessionsCreateOrConnectWithoutTutorsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutTutorsInput | sessionsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: sessionsCreateManyTutorsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutTutorsInput | sessionsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutTutorsInput | sessionsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type tutor_availabilityUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<tutor_availabilityCreateWithoutTutorsInput, tutor_availabilityUncheckedCreateWithoutTutorsInput> | tutor_availabilityCreateWithoutTutorsInput[] | tutor_availabilityUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_availabilityCreateOrConnectWithoutTutorsInput | tutor_availabilityCreateOrConnectWithoutTutorsInput[]
    upsert?: tutor_availabilityUpsertWithWhereUniqueWithoutTutorsInput | tutor_availabilityUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: tutor_availabilityCreateManyTutorsInputEnvelope
    set?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    disconnect?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    delete?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    connect?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    update?: tutor_availabilityUpdateWithWhereUniqueWithoutTutorsInput | tutor_availabilityUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: tutor_availabilityUpdateManyWithWhereWithoutTutorsInput | tutor_availabilityUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: tutor_availabilityScalarWhereInput | tutor_availabilityScalarWhereInput[]
  }

  export type tutor_subjectsUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<tutor_subjectsCreateWithoutTutorsInput, tutor_subjectsUncheckedCreateWithoutTutorsInput> | tutor_subjectsCreateWithoutTutorsInput[] | tutor_subjectsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutTutorsInput | tutor_subjectsCreateOrConnectWithoutTutorsInput[]
    upsert?: tutor_subjectsUpsertWithWhereUniqueWithoutTutorsInput | tutor_subjectsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: tutor_subjectsCreateManyTutorsInputEnvelope
    set?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    disconnect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    delete?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    update?: tutor_subjectsUpdateWithWhereUniqueWithoutTutorsInput | tutor_subjectsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: tutor_subjectsUpdateManyWithWhereWithoutTutorsInput | tutor_subjectsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: tutor_subjectsScalarWhereInput | tutor_subjectsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutTutorsNestedInput = {
    create?: XOR<usersCreateWithoutTutorsInput, usersUncheckedCreateWithoutTutorsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTutorsInput
    upsert?: usersUpsertWithoutTutorsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTutorsInput, usersUpdateWithoutTutorsInput>, usersUncheckedUpdateWithoutTutorsInput>
  }

  export type group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<group_sessionsCreateWithoutTutorsInput, group_sessionsUncheckedCreateWithoutTutorsInput> | group_sessionsCreateWithoutTutorsInput[] | group_sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: group_sessionsCreateOrConnectWithoutTutorsInput | group_sessionsCreateOrConnectWithoutTutorsInput[]
    upsert?: group_sessionsUpsertWithWhereUniqueWithoutTutorsInput | group_sessionsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: group_sessionsCreateManyTutorsInputEnvelope
    set?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    disconnect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    delete?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    connect?: group_sessionsWhereUniqueInput | group_sessionsWhereUniqueInput[]
    update?: group_sessionsUpdateWithWhereUniqueWithoutTutorsInput | group_sessionsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: group_sessionsUpdateManyWithWhereWithoutTutorsInput | group_sessionsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: group_sessionsScalarWhereInput | group_sessionsScalarWhereInput[]
  }

  export type session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<session_ratingsCreateWithoutTutorsInput, session_ratingsUncheckedCreateWithoutTutorsInput> | session_ratingsCreateWithoutTutorsInput[] | session_ratingsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: session_ratingsCreateOrConnectWithoutTutorsInput | session_ratingsCreateOrConnectWithoutTutorsInput[]
    upsert?: session_ratingsUpsertWithWhereUniqueWithoutTutorsInput | session_ratingsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: session_ratingsCreateManyTutorsInputEnvelope
    set?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    disconnect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    delete?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    connect?: session_ratingsWhereUniqueInput | session_ratingsWhereUniqueInput[]
    update?: session_ratingsUpdateWithWhereUniqueWithoutTutorsInput | session_ratingsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: session_ratingsUpdateManyWithWhereWithoutTutorsInput | session_ratingsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: session_ratingsScalarWhereInput | session_ratingsScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<sessionsCreateWithoutTutorsInput, sessionsUncheckedCreateWithoutTutorsInput> | sessionsCreateWithoutTutorsInput[] | sessionsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutTutorsInput | sessionsCreateOrConnectWithoutTutorsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutTutorsInput | sessionsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: sessionsCreateManyTutorsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutTutorsInput | sessionsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutTutorsInput | sessionsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<tutor_availabilityCreateWithoutTutorsInput, tutor_availabilityUncheckedCreateWithoutTutorsInput> | tutor_availabilityCreateWithoutTutorsInput[] | tutor_availabilityUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_availabilityCreateOrConnectWithoutTutorsInput | tutor_availabilityCreateOrConnectWithoutTutorsInput[]
    upsert?: tutor_availabilityUpsertWithWhereUniqueWithoutTutorsInput | tutor_availabilityUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: tutor_availabilityCreateManyTutorsInputEnvelope
    set?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    disconnect?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    delete?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    connect?: tutor_availabilityWhereUniqueInput | tutor_availabilityWhereUniqueInput[]
    update?: tutor_availabilityUpdateWithWhereUniqueWithoutTutorsInput | tutor_availabilityUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: tutor_availabilityUpdateManyWithWhereWithoutTutorsInput | tutor_availabilityUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: tutor_availabilityScalarWhereInput | tutor_availabilityScalarWhereInput[]
  }

  export type tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput = {
    create?: XOR<tutor_subjectsCreateWithoutTutorsInput, tutor_subjectsUncheckedCreateWithoutTutorsInput> | tutor_subjectsCreateWithoutTutorsInput[] | tutor_subjectsUncheckedCreateWithoutTutorsInput[]
    connectOrCreate?: tutor_subjectsCreateOrConnectWithoutTutorsInput | tutor_subjectsCreateOrConnectWithoutTutorsInput[]
    upsert?: tutor_subjectsUpsertWithWhereUniqueWithoutTutorsInput | tutor_subjectsUpsertWithWhereUniqueWithoutTutorsInput[]
    createMany?: tutor_subjectsCreateManyTutorsInputEnvelope
    set?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    disconnect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    delete?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    connect?: tutor_subjectsWhereUniqueInput | tutor_subjectsWhereUniqueInput[]
    update?: tutor_subjectsUpdateWithWhereUniqueWithoutTutorsInput | tutor_subjectsUpdateWithWhereUniqueWithoutTutorsInput[]
    updateMany?: tutor_subjectsUpdateManyWithWhereWithoutTutorsInput | tutor_subjectsUpdateManyWithWhereWithoutTutorsInput[]
    deleteMany?: tutor_subjectsScalarWhereInput | tutor_subjectsScalarWhereInput[]
  }

  export type messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput> | messagesCreateWithoutUsers_messages_sender_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_sender_idTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput> | messagesCreateWithoutUsers_messages_recipient_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_recipient_idTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type resourcesCreateNestedManyWithoutUsersInput = {
    create?: XOR<resourcesCreateWithoutUsersInput, resourcesUncheckedCreateWithoutUsersInput> | resourcesCreateWithoutUsersInput[] | resourcesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutUsersInput | resourcesCreateOrConnectWithoutUsersInput[]
    createMany?: resourcesCreateManyUsersInputEnvelope
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
  }

  export type session_notesCreateNestedManyWithoutUsersInput = {
    create?: XOR<session_notesCreateWithoutUsersInput, session_notesUncheckedCreateWithoutUsersInput> | session_notesCreateWithoutUsersInput[] | session_notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutUsersInput | session_notesCreateOrConnectWithoutUsersInput[]
    createMany?: session_notesCreateManyUsersInputEnvelope
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
  }

  export type studentsCreateNestedOneWithoutUsersInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    connect?: studentsWhereUniqueInput
  }

  export type tutorsCreateNestedOneWithoutUsersInput = {
    create?: XOR<tutorsCreateWithoutUsersInput, tutorsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutUsersInput
    connect?: tutorsWhereUniqueInput
  }

  export type messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput> | messagesCreateWithoutUsers_messages_sender_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_sender_idTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput> | messagesCreateWithoutUsers_messages_recipient_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_recipient_idTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type resourcesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<resourcesCreateWithoutUsersInput, resourcesUncheckedCreateWithoutUsersInput> | resourcesCreateWithoutUsersInput[] | resourcesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutUsersInput | resourcesCreateOrConnectWithoutUsersInput[]
    createMany?: resourcesCreateManyUsersInputEnvelope
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
  }

  export type session_notesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<session_notesCreateWithoutUsersInput, session_notesUncheckedCreateWithoutUsersInput> | session_notesCreateWithoutUsersInput[] | session_notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutUsersInput | session_notesCreateOrConnectWithoutUsersInput[]
    createMany?: session_notesCreateManyUsersInputEnvelope
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    connect?: studentsWhereUniqueInput
  }

  export type tutorsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<tutorsCreateWithoutUsersInput, tutorsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutUsersInput
    connect?: tutorsWhereUniqueInput
  }

  export type messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput> | messagesCreateWithoutUsers_messages_sender_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_sender_idTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_sender_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_sender_idTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_sender_idTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_sender_idTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_sender_idTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_sender_idTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput> | messagesCreateWithoutUsers_messages_recipient_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_recipient_idTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_recipient_idTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_recipient_idTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type resourcesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<resourcesCreateWithoutUsersInput, resourcesUncheckedCreateWithoutUsersInput> | resourcesCreateWithoutUsersInput[] | resourcesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutUsersInput | resourcesCreateOrConnectWithoutUsersInput[]
    upsert?: resourcesUpsertWithWhereUniqueWithoutUsersInput | resourcesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: resourcesCreateManyUsersInputEnvelope
    set?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    disconnect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    delete?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    update?: resourcesUpdateWithWhereUniqueWithoutUsersInput | resourcesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: resourcesUpdateManyWithWhereWithoutUsersInput | resourcesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: resourcesScalarWhereInput | resourcesScalarWhereInput[]
  }

  export type session_notesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<session_notesCreateWithoutUsersInput, session_notesUncheckedCreateWithoutUsersInput> | session_notesCreateWithoutUsersInput[] | session_notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutUsersInput | session_notesCreateOrConnectWithoutUsersInput[]
    upsert?: session_notesUpsertWithWhereUniqueWithoutUsersInput | session_notesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: session_notesCreateManyUsersInputEnvelope
    set?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    disconnect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    delete?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    update?: session_notesUpdateWithWhereUniqueWithoutUsersInput | session_notesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: session_notesUpdateManyWithWhereWithoutUsersInput | session_notesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: session_notesScalarWhereInput | session_notesScalarWhereInput[]
  }

  export type studentsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    upsert?: studentsUpsertWithoutUsersInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutUsersInput, studentsUpdateWithoutUsersInput>, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type tutorsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<tutorsCreateWithoutUsersInput, tutorsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutUsersInput
    upsert?: tutorsUpsertWithoutUsersInput
    disconnect?: tutorsWhereInput | boolean
    delete?: tutorsWhereInput | boolean
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutUsersInput, tutorsUpdateWithoutUsersInput>, tutorsUncheckedUpdateWithoutUsersInput>
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput> | messagesCreateWithoutUsers_messages_sender_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_sender_idTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_sender_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_sender_idTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_sender_idTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_sender_idTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_sender_idTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_sender_idTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput> | messagesCreateWithoutUsers_messages_recipient_idTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput | messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput[]
    createMany?: messagesCreateManyUsers_messages_recipient_idTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_recipient_idTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_recipient_idTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type resourcesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<resourcesCreateWithoutUsersInput, resourcesUncheckedCreateWithoutUsersInput> | resourcesCreateWithoutUsersInput[] | resourcesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: resourcesCreateOrConnectWithoutUsersInput | resourcesCreateOrConnectWithoutUsersInput[]
    upsert?: resourcesUpsertWithWhereUniqueWithoutUsersInput | resourcesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: resourcesCreateManyUsersInputEnvelope
    set?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    disconnect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    delete?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    connect?: resourcesWhereUniqueInput | resourcesWhereUniqueInput[]
    update?: resourcesUpdateWithWhereUniqueWithoutUsersInput | resourcesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: resourcesUpdateManyWithWhereWithoutUsersInput | resourcesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: resourcesScalarWhereInput | resourcesScalarWhereInput[]
  }

  export type session_notesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<session_notesCreateWithoutUsersInput, session_notesUncheckedCreateWithoutUsersInput> | session_notesCreateWithoutUsersInput[] | session_notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: session_notesCreateOrConnectWithoutUsersInput | session_notesCreateOrConnectWithoutUsersInput[]
    upsert?: session_notesUpsertWithWhereUniqueWithoutUsersInput | session_notesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: session_notesCreateManyUsersInputEnvelope
    set?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    disconnect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    delete?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    connect?: session_notesWhereUniqueInput | session_notesWhereUniqueInput[]
    update?: session_notesUpdateWithWhereUniqueWithoutUsersInput | session_notesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: session_notesUpdateManyWithWhereWithoutUsersInput | session_notesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: session_notesScalarWhereInput | session_notesScalarWhereInput[]
  }

  export type studentsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput
    upsert?: studentsUpsertWithoutUsersInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutUsersInput, studentsUpdateWithoutUsersInput>, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type tutorsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<tutorsCreateWithoutUsersInput, tutorsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: tutorsCreateOrConnectWithoutUsersInput
    upsert?: tutorsUpsertWithoutUsersInput
    disconnect?: tutorsWhereInput | boolean
    delete?: tutorsWhereInput | boolean
    connect?: tutorsWhereUniqueInput
    update?: XOR<XOR<tutorsUpdateToOneWithWhereWithoutUsersInput, tutorsUpdateWithoutUsersInput>, tutorsUncheckedUpdateWithoutUsersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type group_sessionsCreateWithoutGroup_session_participantsInput = {
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    tutors: tutorsCreateNestedOneWithoutGroup_sessionsInput
    subjects: subjectsCreateNestedOneWithoutGroup_sessionsInput
  }

  export type group_sessionsUncheckedCreateWithoutGroup_session_participantsInput = {
    group_session_id?: number
    tutor_id: number
    subject_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
  }

  export type group_sessionsCreateOrConnectWithoutGroup_session_participantsInput = {
    where: group_sessionsWhereUniqueInput
    create: XOR<group_sessionsCreateWithoutGroup_session_participantsInput, group_sessionsUncheckedCreateWithoutGroup_session_participantsInput>
  }

  export type studentsCreateWithoutGroup_session_participantsInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    session_ratings?: session_ratingsCreateNestedManyWithoutStudentsInput
    sessions?: sessionsCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    subscriptions?: subscriptionsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutGroup_session_participantsInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutStudentsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutGroup_session_participantsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutGroup_session_participantsInput, studentsUncheckedCreateWithoutGroup_session_participantsInput>
  }

  export type group_sessionsUpsertWithoutGroup_session_participantsInput = {
    update: XOR<group_sessionsUpdateWithoutGroup_session_participantsInput, group_sessionsUncheckedUpdateWithoutGroup_session_participantsInput>
    create: XOR<group_sessionsCreateWithoutGroup_session_participantsInput, group_sessionsUncheckedCreateWithoutGroup_session_participantsInput>
    where?: group_sessionsWhereInput
  }

  export type group_sessionsUpdateToOneWithWhereWithoutGroup_session_participantsInput = {
    where?: group_sessionsWhereInput
    data: XOR<group_sessionsUpdateWithoutGroup_session_participantsInput, group_sessionsUncheckedUpdateWithoutGroup_session_participantsInput>
  }

  export type group_sessionsUpdateWithoutGroup_session_participantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutors?: tutorsUpdateOneRequiredWithoutGroup_sessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsUncheckedUpdateWithoutGroup_session_participantsInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentsUpsertWithoutGroup_session_participantsInput = {
    update: XOR<studentsUpdateWithoutGroup_session_participantsInput, studentsUncheckedUpdateWithoutGroup_session_participantsInput>
    create: XOR<studentsCreateWithoutGroup_session_participantsInput, studentsUncheckedCreateWithoutGroup_session_participantsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutGroup_session_participantsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutGroup_session_participantsInput, studentsUncheckedUpdateWithoutGroup_session_participantsInput>
  }

  export type studentsUpdateWithoutGroup_session_participantsInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    session_ratings?: session_ratingsUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutGroup_session_participantsInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type group_session_participantsCreateWithoutGroup_sessionsInput = {
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
    students: studentsCreateNestedOneWithoutGroup_session_participantsInput
  }

  export type group_session_participantsUncheckedCreateWithoutGroup_sessionsInput = {
    participation_id?: number
    student_id: number
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
  }

  export type group_session_participantsCreateOrConnectWithoutGroup_sessionsInput = {
    where: group_session_participantsWhereUniqueInput
    create: XOR<group_session_participantsCreateWithoutGroup_sessionsInput, group_session_participantsUncheckedCreateWithoutGroup_sessionsInput>
  }

  export type group_session_participantsCreateManyGroup_sessionsInputEnvelope = {
    data: group_session_participantsCreateManyGroup_sessionsInput | group_session_participantsCreateManyGroup_sessionsInput[]
    skipDuplicates?: boolean
  }

  export type tutorsCreateWithoutGroup_sessionsInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    session_ratings?: session_ratingsCreateNestedManyWithoutTutorsInput
    sessions?: sessionsCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutTutorsInput
    users: usersCreateNestedOneWithoutTutorsInput
  }

  export type tutorsUncheckedCreateWithoutGroup_sessionsInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutTutorsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsCreateOrConnectWithoutGroup_sessionsInput = {
    where: tutorsWhereUniqueInput
    create: XOR<tutorsCreateWithoutGroup_sessionsInput, tutorsUncheckedCreateWithoutGroup_sessionsInput>
  }

  export type subjectsCreateWithoutGroup_sessionsInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    resources?: resourcesCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutSubjectsInput
    subject_categories?: subject_categoriesCreateNestedOneWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutGroup_sessionsInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
    resources?: resourcesUncheckedCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutGroup_sessionsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutGroup_sessionsInput, subjectsUncheckedCreateWithoutGroup_sessionsInput>
  }

  export type group_session_participantsUpsertWithWhereUniqueWithoutGroup_sessionsInput = {
    where: group_session_participantsWhereUniqueInput
    update: XOR<group_session_participantsUpdateWithoutGroup_sessionsInput, group_session_participantsUncheckedUpdateWithoutGroup_sessionsInput>
    create: XOR<group_session_participantsCreateWithoutGroup_sessionsInput, group_session_participantsUncheckedCreateWithoutGroup_sessionsInput>
  }

  export type group_session_participantsUpdateWithWhereUniqueWithoutGroup_sessionsInput = {
    where: group_session_participantsWhereUniqueInput
    data: XOR<group_session_participantsUpdateWithoutGroup_sessionsInput, group_session_participantsUncheckedUpdateWithoutGroup_sessionsInput>
  }

  export type group_session_participantsUpdateManyWithWhereWithoutGroup_sessionsInput = {
    where: group_session_participantsScalarWhereInput
    data: XOR<group_session_participantsUpdateManyMutationInput, group_session_participantsUncheckedUpdateManyWithoutGroup_sessionsInput>
  }

  export type group_session_participantsScalarWhereInput = {
    AND?: group_session_participantsScalarWhereInput | group_session_participantsScalarWhereInput[]
    OR?: group_session_participantsScalarWhereInput[]
    NOT?: group_session_participantsScalarWhereInput | group_session_participantsScalarWhereInput[]
    participation_id?: IntFilter<"group_session_participants"> | number
    group_session_id?: IntFilter<"group_session_participants"> | number
    student_id?: IntFilter<"group_session_participants"> | number
    registration_time?: DateTimeNullableFilter<"group_session_participants"> | Date | string | null
    payment_status?: StringNullableFilter<"group_session_participants"> | string | null
    attended?: BoolNullableFilter<"group_session_participants"> | boolean | null
  }

  export type tutorsUpsertWithoutGroup_sessionsInput = {
    update: XOR<tutorsUpdateWithoutGroup_sessionsInput, tutorsUncheckedUpdateWithoutGroup_sessionsInput>
    create: XOR<tutorsCreateWithoutGroup_sessionsInput, tutorsUncheckedCreateWithoutGroup_sessionsInput>
    where?: tutorsWhereInput
  }

  export type tutorsUpdateToOneWithWhereWithoutGroup_sessionsInput = {
    where?: tutorsWhereInput
    data: XOR<tutorsUpdateWithoutGroup_sessionsInput, tutorsUncheckedUpdateWithoutGroup_sessionsInput>
  }

  export type tutorsUpdateWithoutGroup_sessionsInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    session_ratings?: session_ratingsUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutTutorsNestedInput
    users?: usersUpdateOneRequiredWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateWithoutGroup_sessionsInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type subjectsUpsertWithoutGroup_sessionsInput = {
    update: XOR<subjectsUpdateWithoutGroup_sessionsInput, subjectsUncheckedUpdateWithoutGroup_sessionsInput>
    create: XOR<subjectsCreateWithoutGroup_sessionsInput, subjectsUncheckedCreateWithoutGroup_sessionsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutGroup_sessionsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutGroup_sessionsInput, subjectsUncheckedUpdateWithoutGroup_sessionsInput>
  }

  export type subjectsUpdateWithoutGroup_sessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: resourcesUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutSubjectsNestedInput
    subject_categories?: subject_categoriesUpdateOneWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutGroup_sessionsInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: resourcesUncheckedUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersCreateWithoutMessages_messages_sender_idTousersInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMessages_messages_sender_idTousersInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMessages_messages_sender_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMessages_messages_sender_idTousersInput, usersUncheckedCreateWithoutMessages_messages_sender_idTousersInput>
  }

  export type usersCreateWithoutMessages_messages_recipient_idTousersInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMessages_messages_recipient_idTousersInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMessages_messages_recipient_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMessages_messages_recipient_idTousersInput, usersUncheckedCreateWithoutMessages_messages_recipient_idTousersInput>
  }

  export type usersUpsertWithoutMessages_messages_sender_idTousersInput = {
    update: XOR<usersUpdateWithoutMessages_messages_sender_idTousersInput, usersUncheckedUpdateWithoutMessages_messages_sender_idTousersInput>
    create: XOR<usersCreateWithoutMessages_messages_sender_idTousersInput, usersUncheckedCreateWithoutMessages_messages_sender_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMessages_messages_sender_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMessages_messages_sender_idTousersInput, usersUncheckedUpdateWithoutMessages_messages_sender_idTousersInput>
  }

  export type usersUpdateWithoutMessages_messages_sender_idTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMessages_messages_sender_idTousersInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUpsertWithoutMessages_messages_recipient_idTousersInput = {
    update: XOR<usersUpdateWithoutMessages_messages_recipient_idTousersInput, usersUncheckedUpdateWithoutMessages_messages_recipient_idTousersInput>
    create: XOR<usersCreateWithoutMessages_messages_recipient_idTousersInput, usersUncheckedCreateWithoutMessages_messages_recipient_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMessages_messages_recipient_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMessages_messages_recipient_idTousersInput, usersUncheckedUpdateWithoutMessages_messages_recipient_idTousersInput>
  }

  export type usersUpdateWithoutMessages_messages_recipient_idTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMessages_messages_recipient_idTousersInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type sessionsCreateWithoutPaymentsInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutPaymentsInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutPaymentsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutPaymentsInput, sessionsUncheckedCreateWithoutPaymentsInput>
  }

  export type sessionsUpsertWithoutPaymentsInput = {
    update: XOR<sessionsUpdateWithoutPaymentsInput, sessionsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<sessionsCreateWithoutPaymentsInput, sessionsUncheckedCreateWithoutPaymentsInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutPaymentsInput, sessionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type sessionsUpdateWithoutPaymentsInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutPaymentsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type subjectsCreateWithoutResourcesInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutSubjectsInput
    subject_categories?: subject_categoriesCreateNestedOneWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutResourcesInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutResourcesInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutResourcesInput, subjectsUncheckedCreateWithoutResourcesInput>
  }

  export type usersCreateWithoutResourcesInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutResourcesInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutResourcesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutResourcesInput, usersUncheckedCreateWithoutResourcesInput>
  }

  export type session_resourcesCreateWithoutResourcesInput = {
    sessions: sessionsCreateNestedOneWithoutSession_resourcesInput
  }

  export type session_resourcesUncheckedCreateWithoutResourcesInput = {
    session_resource_id?: number
    session_id: number
  }

  export type session_resourcesCreateOrConnectWithoutResourcesInput = {
    where: session_resourcesWhereUniqueInput
    create: XOR<session_resourcesCreateWithoutResourcesInput, session_resourcesUncheckedCreateWithoutResourcesInput>
  }

  export type session_resourcesCreateManyResourcesInputEnvelope = {
    data: session_resourcesCreateManyResourcesInput | session_resourcesCreateManyResourcesInput[]
    skipDuplicates?: boolean
  }

  export type subjectsUpsertWithoutResourcesInput = {
    update: XOR<subjectsUpdateWithoutResourcesInput, subjectsUncheckedUpdateWithoutResourcesInput>
    create: XOR<subjectsCreateWithoutResourcesInput, subjectsUncheckedCreateWithoutResourcesInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutResourcesInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutResourcesInput, subjectsUncheckedUpdateWithoutResourcesInput>
  }

  export type subjectsUpdateWithoutResourcesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutSubjectsNestedInput
    subject_categories?: subject_categoriesUpdateOneWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutResourcesInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersUpsertWithoutResourcesInput = {
    update: XOR<usersUpdateWithoutResourcesInput, usersUncheckedUpdateWithoutResourcesInput>
    create: XOR<usersCreateWithoutResourcesInput, usersUncheckedCreateWithoutResourcesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutResourcesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutResourcesInput, usersUncheckedUpdateWithoutResourcesInput>
  }

  export type usersUpdateWithoutResourcesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutResourcesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type session_resourcesUpsertWithWhereUniqueWithoutResourcesInput = {
    where: session_resourcesWhereUniqueInput
    update: XOR<session_resourcesUpdateWithoutResourcesInput, session_resourcesUncheckedUpdateWithoutResourcesInput>
    create: XOR<session_resourcesCreateWithoutResourcesInput, session_resourcesUncheckedCreateWithoutResourcesInput>
  }

  export type session_resourcesUpdateWithWhereUniqueWithoutResourcesInput = {
    where: session_resourcesWhereUniqueInput
    data: XOR<session_resourcesUpdateWithoutResourcesInput, session_resourcesUncheckedUpdateWithoutResourcesInput>
  }

  export type session_resourcesUpdateManyWithWhereWithoutResourcesInput = {
    where: session_resourcesScalarWhereInput
    data: XOR<session_resourcesUpdateManyMutationInput, session_resourcesUncheckedUpdateManyWithoutResourcesInput>
  }

  export type session_resourcesScalarWhereInput = {
    AND?: session_resourcesScalarWhereInput | session_resourcesScalarWhereInput[]
    OR?: session_resourcesScalarWhereInput[]
    NOT?: session_resourcesScalarWhereInput | session_resourcesScalarWhereInput[]
    session_resource_id?: IntFilter<"session_resources"> | number
    session_id?: IntFilter<"session_resources"> | number
    resource_id?: IntFilter<"session_resources"> | number
  }

  export type sessionsCreateWithoutSession_notesInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutSession_notesInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutSession_notesInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutSession_notesInput, sessionsUncheckedCreateWithoutSession_notesInput>
  }

  export type usersCreateWithoutSession_notesInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSession_notesInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSession_notesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSession_notesInput, usersUncheckedCreateWithoutSession_notesInput>
  }

  export type sessionsUpsertWithoutSession_notesInput = {
    update: XOR<sessionsUpdateWithoutSession_notesInput, sessionsUncheckedUpdateWithoutSession_notesInput>
    create: XOR<sessionsCreateWithoutSession_notesInput, sessionsUncheckedCreateWithoutSession_notesInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutSession_notesInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutSession_notesInput, sessionsUncheckedUpdateWithoutSession_notesInput>
  }

  export type sessionsUpdateWithoutSession_notesInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutSession_notesInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type usersUpsertWithoutSession_notesInput = {
    update: XOR<usersUpdateWithoutSession_notesInput, usersUncheckedUpdateWithoutSession_notesInput>
    create: XOR<usersCreateWithoutSession_notesInput, usersUncheckedCreateWithoutSession_notesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSession_notesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSession_notesInput, usersUncheckedUpdateWithoutSession_notesInput>
  }

  export type usersUpdateWithoutSession_notesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSession_notesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type sessionsCreateWithoutSession_ratingsInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutSession_ratingsInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutSession_ratingsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutSession_ratingsInput, sessionsUncheckedCreateWithoutSession_ratingsInput>
  }

  export type studentsCreateWithoutSession_ratingsInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutStudentsInput
    sessions?: sessionsCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    subscriptions?: subscriptionsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutSession_ratingsInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutSession_ratingsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutSession_ratingsInput, studentsUncheckedCreateWithoutSession_ratingsInput>
  }

  export type tutorsCreateWithoutSession_ratingsInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsCreateNestedManyWithoutTutorsInput
    sessions?: sessionsCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutTutorsInput
    users: usersCreateNestedOneWithoutTutorsInput
  }

  export type tutorsUncheckedCreateWithoutSession_ratingsInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutTutorsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsCreateOrConnectWithoutSession_ratingsInput = {
    where: tutorsWhereUniqueInput
    create: XOR<tutorsCreateWithoutSession_ratingsInput, tutorsUncheckedCreateWithoutSession_ratingsInput>
  }

  export type sessionsUpsertWithoutSession_ratingsInput = {
    update: XOR<sessionsUpdateWithoutSession_ratingsInput, sessionsUncheckedUpdateWithoutSession_ratingsInput>
    create: XOR<sessionsCreateWithoutSession_ratingsInput, sessionsUncheckedCreateWithoutSession_ratingsInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutSession_ratingsInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutSession_ratingsInput, sessionsUncheckedUpdateWithoutSession_ratingsInput>
  }

  export type sessionsUpdateWithoutSession_ratingsInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutSession_ratingsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type studentsUpsertWithoutSession_ratingsInput = {
    update: XOR<studentsUpdateWithoutSession_ratingsInput, studentsUncheckedUpdateWithoutSession_ratingsInput>
    create: XOR<studentsCreateWithoutSession_ratingsInput, studentsUncheckedCreateWithoutSession_ratingsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutSession_ratingsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutSession_ratingsInput, studentsUncheckedUpdateWithoutSession_ratingsInput>
  }

  export type studentsUpdateWithoutSession_ratingsInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutSession_ratingsInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type tutorsUpsertWithoutSession_ratingsInput = {
    update: XOR<tutorsUpdateWithoutSession_ratingsInput, tutorsUncheckedUpdateWithoutSession_ratingsInput>
    create: XOR<tutorsCreateWithoutSession_ratingsInput, tutorsUncheckedCreateWithoutSession_ratingsInput>
    where?: tutorsWhereInput
  }

  export type tutorsUpdateToOneWithWhereWithoutSession_ratingsInput = {
    where?: tutorsWhereInput
    data: XOR<tutorsUpdateWithoutSession_ratingsInput, tutorsUncheckedUpdateWithoutSession_ratingsInput>
  }

  export type tutorsUpdateWithoutSession_ratingsInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutTutorsNestedInput
    users?: usersUpdateOneRequiredWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateWithoutSession_ratingsInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type sessionsCreateWithoutSession_resourcesInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutSession_resourcesInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutSession_resourcesInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutSession_resourcesInput, sessionsUncheckedCreateWithoutSession_resourcesInput>
  }

  export type resourcesCreateWithoutSession_resourcesInput = {
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    subjects?: subjectsCreateNestedOneWithoutResourcesInput
    users: usersCreateNestedOneWithoutResourcesInput
  }

  export type resourcesUncheckedCreateWithoutSession_resourcesInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    subject_id?: number | null
    uploaded_by: number
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type resourcesCreateOrConnectWithoutSession_resourcesInput = {
    where: resourcesWhereUniqueInput
    create: XOR<resourcesCreateWithoutSession_resourcesInput, resourcesUncheckedCreateWithoutSession_resourcesInput>
  }

  export type sessionsUpsertWithoutSession_resourcesInput = {
    update: XOR<sessionsUpdateWithoutSession_resourcesInput, sessionsUncheckedUpdateWithoutSession_resourcesInput>
    create: XOR<sessionsCreateWithoutSession_resourcesInput, sessionsUncheckedCreateWithoutSession_resourcesInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutSession_resourcesInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutSession_resourcesInput, sessionsUncheckedUpdateWithoutSession_resourcesInput>
  }

  export type sessionsUpdateWithoutSession_resourcesInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutSession_resourcesInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
  }

  export type resourcesUpsertWithoutSession_resourcesInput = {
    update: XOR<resourcesUpdateWithoutSession_resourcesInput, resourcesUncheckedUpdateWithoutSession_resourcesInput>
    create: XOR<resourcesCreateWithoutSession_resourcesInput, resourcesUncheckedCreateWithoutSession_resourcesInput>
    where?: resourcesWhereInput
  }

  export type resourcesUpdateToOneWithWhereWithoutSession_resourcesInput = {
    where?: resourcesWhereInput
    data: XOR<resourcesUpdateWithoutSession_resourcesInput, resourcesUncheckedUpdateWithoutSession_resourcesInput>
  }

  export type resourcesUpdateWithoutSession_resourcesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subjects?: subjectsUpdateOneWithoutResourcesNestedInput
    users?: usersUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateWithoutSession_resourcesInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateWithoutSessionsInput = {
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_method: string
    transaction_id?: string | null
    status: string
    platform_fee: Decimal | DecimalJsLike | number | string
    tutor_payout: Decimal | DecimalJsLike | number | string
    payout_date?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_date?: Date | string | null
    refund_reason?: string | null
  }

  export type paymentsUncheckedCreateWithoutSessionsInput = {
    payment_id?: number
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_method: string
    transaction_id?: string | null
    status: string
    platform_fee: Decimal | DecimalJsLike | number | string
    tutor_payout: Decimal | DecimalJsLike | number | string
    payout_date?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_date?: Date | string | null
    refund_reason?: string | null
  }

  export type paymentsCreateOrConnectWithoutSessionsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutSessionsInput, paymentsUncheckedCreateWithoutSessionsInput>
  }

  export type paymentsCreateManySessionsInputEnvelope = {
    data: paymentsCreateManySessionsInput | paymentsCreateManySessionsInput[]
    skipDuplicates?: boolean
  }

  export type session_notesCreateWithoutSessionsInput = {
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
    users: usersCreateNestedOneWithoutSession_notesInput
  }

  export type session_notesUncheckedCreateWithoutSessionsInput = {
    note_id?: number
    author_id: number
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
  }

  export type session_notesCreateOrConnectWithoutSessionsInput = {
    where: session_notesWhereUniqueInput
    create: XOR<session_notesCreateWithoutSessionsInput, session_notesUncheckedCreateWithoutSessionsInput>
  }

  export type session_notesCreateManySessionsInputEnvelope = {
    data: session_notesCreateManySessionsInput | session_notesCreateManySessionsInput[]
    skipDuplicates?: boolean
  }

  export type session_ratingsCreateWithoutSessionsInput = {
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutSession_ratingsInput
    tutors: tutorsCreateNestedOneWithoutSession_ratingsInput
  }

  export type session_ratingsUncheckedCreateWithoutSessionsInput = {
    rating_id?: number
    student_id: number
    tutor_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type session_ratingsCreateOrConnectWithoutSessionsInput = {
    where: session_ratingsWhereUniqueInput
    create: XOR<session_ratingsCreateWithoutSessionsInput, session_ratingsUncheckedCreateWithoutSessionsInput>
  }

  export type session_resourcesCreateWithoutSessionsInput = {
    resources: resourcesCreateNestedOneWithoutSession_resourcesInput
  }

  export type session_resourcesUncheckedCreateWithoutSessionsInput = {
    session_resource_id?: number
    resource_id: number
  }

  export type session_resourcesCreateOrConnectWithoutSessionsInput = {
    where: session_resourcesWhereUniqueInput
    create: XOR<session_resourcesCreateWithoutSessionsInput, session_resourcesUncheckedCreateWithoutSessionsInput>
  }

  export type session_resourcesCreateManySessionsInputEnvelope = {
    data: session_resourcesCreateManySessionsInput | session_resourcesCreateManySessionsInput[]
    skipDuplicates?: boolean
  }

  export type tutorsCreateWithoutSessionsInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutTutorsInput
    users: usersCreateNestedOneWithoutTutorsInput
  }

  export type tutorsUncheckedCreateWithoutSessionsInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsCreateOrConnectWithoutSessionsInput = {
    where: tutorsWhereUniqueInput
    create: XOR<tutorsCreateWithoutSessionsInput, tutorsUncheckedCreateWithoutSessionsInput>
  }

  export type studentsCreateWithoutSessionsInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    subscriptions?: subscriptionsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutSessionsInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutSessionsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutSessionsInput, studentsUncheckedCreateWithoutSessionsInput>
  }

  export type subjectsCreateWithoutSessionsInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsCreateNestedManyWithoutSubjectsInput
    resources?: resourcesCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutSubjectsInput
    subject_categories?: subject_categoriesCreateNestedOneWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutSessionsInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    resources?: resourcesUncheckedCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutSessionsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutSessionsInput, subjectsUncheckedCreateWithoutSessionsInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutSessionsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutSessionsInput, paymentsUncheckedUpdateWithoutSessionsInput>
    create: XOR<paymentsCreateWithoutSessionsInput, paymentsUncheckedCreateWithoutSessionsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutSessionsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutSessionsInput, paymentsUncheckedUpdateWithoutSessionsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutSessionsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutSessionsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    payment_id?: IntFilter<"payments"> | number
    session_id?: IntFilter<"payments"> | number
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    payment_method?: StringFilter<"payments"> | string
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: StringFilter<"payments"> | string
    platform_fee?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payout_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_date?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_reason?: StringNullableFilter<"payments"> | string | null
  }

  export type session_notesUpsertWithWhereUniqueWithoutSessionsInput = {
    where: session_notesWhereUniqueInput
    update: XOR<session_notesUpdateWithoutSessionsInput, session_notesUncheckedUpdateWithoutSessionsInput>
    create: XOR<session_notesCreateWithoutSessionsInput, session_notesUncheckedCreateWithoutSessionsInput>
  }

  export type session_notesUpdateWithWhereUniqueWithoutSessionsInput = {
    where: session_notesWhereUniqueInput
    data: XOR<session_notesUpdateWithoutSessionsInput, session_notesUncheckedUpdateWithoutSessionsInput>
  }

  export type session_notesUpdateManyWithWhereWithoutSessionsInput = {
    where: session_notesScalarWhereInput
    data: XOR<session_notesUpdateManyMutationInput, session_notesUncheckedUpdateManyWithoutSessionsInput>
  }

  export type session_notesScalarWhereInput = {
    AND?: session_notesScalarWhereInput | session_notesScalarWhereInput[]
    OR?: session_notesScalarWhereInput[]
    NOT?: session_notesScalarWhereInput | session_notesScalarWhereInput[]
    note_id?: IntFilter<"session_notes"> | number
    session_id?: IntFilter<"session_notes"> | number
    author_id?: IntFilter<"session_notes"> | number
    content?: StringFilter<"session_notes"> | string
    created_at?: DateTimeNullableFilter<"session_notes"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"session_notes"> | Date | string | null
    is_private?: BoolNullableFilter<"session_notes"> | boolean | null
  }

  export type session_ratingsUpsertWithoutSessionsInput = {
    update: XOR<session_ratingsUpdateWithoutSessionsInput, session_ratingsUncheckedUpdateWithoutSessionsInput>
    create: XOR<session_ratingsCreateWithoutSessionsInput, session_ratingsUncheckedCreateWithoutSessionsInput>
    where?: session_ratingsWhereInput
  }

  export type session_ratingsUpdateToOneWithWhereWithoutSessionsInput = {
    where?: session_ratingsWhereInput
    data: XOR<session_ratingsUpdateWithoutSessionsInput, session_ratingsUncheckedUpdateWithoutSessionsInput>
  }

  export type session_ratingsUpdateWithoutSessionsInput = {
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutSession_ratingsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSession_ratingsNestedInput
  }

  export type session_ratingsUncheckedUpdateWithoutSessionsInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_resourcesUpsertWithWhereUniqueWithoutSessionsInput = {
    where: session_resourcesWhereUniqueInput
    update: XOR<session_resourcesUpdateWithoutSessionsInput, session_resourcesUncheckedUpdateWithoutSessionsInput>
    create: XOR<session_resourcesCreateWithoutSessionsInput, session_resourcesUncheckedCreateWithoutSessionsInput>
  }

  export type session_resourcesUpdateWithWhereUniqueWithoutSessionsInput = {
    where: session_resourcesWhereUniqueInput
    data: XOR<session_resourcesUpdateWithoutSessionsInput, session_resourcesUncheckedUpdateWithoutSessionsInput>
  }

  export type session_resourcesUpdateManyWithWhereWithoutSessionsInput = {
    where: session_resourcesScalarWhereInput
    data: XOR<session_resourcesUpdateManyMutationInput, session_resourcesUncheckedUpdateManyWithoutSessionsInput>
  }

  export type tutorsUpsertWithoutSessionsInput = {
    update: XOR<tutorsUpdateWithoutSessionsInput, tutorsUncheckedUpdateWithoutSessionsInput>
    create: XOR<tutorsCreateWithoutSessionsInput, tutorsUncheckedCreateWithoutSessionsInput>
    where?: tutorsWhereInput
  }

  export type tutorsUpdateToOneWithWhereWithoutSessionsInput = {
    where?: tutorsWhereInput
    data: XOR<tutorsUpdateWithoutSessionsInput, tutorsUncheckedUpdateWithoutSessionsInput>
  }

  export type tutorsUpdateWithoutSessionsInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutTutorsNestedInput
    users?: usersUpdateOneRequiredWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateWithoutSessionsInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type studentsUpsertWithoutSessionsInput = {
    update: XOR<studentsUpdateWithoutSessionsInput, studentsUncheckedUpdateWithoutSessionsInput>
    create: XOR<studentsCreateWithoutSessionsInput, studentsUncheckedCreateWithoutSessionsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutSessionsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutSessionsInput, studentsUncheckedUpdateWithoutSessionsInput>
  }

  export type studentsUpdateWithoutSessionsInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutSessionsInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type subjectsUpsertWithoutSessionsInput = {
    update: XOR<subjectsUpdateWithoutSessionsInput, subjectsUncheckedUpdateWithoutSessionsInput>
    create: XOR<subjectsCreateWithoutSessionsInput, subjectsUncheckedCreateWithoutSessionsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutSessionsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutSessionsInput, subjectsUncheckedUpdateWithoutSessionsInput>
  }

  export type subjectsUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutSubjectsNestedInput
    subject_categories?: subject_categoriesUpdateOneWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutSessionsInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type studentsCreateWithoutStudent_subject_interestsInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutStudentsInput
    sessions?: sessionsCreateNestedManyWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
    subscriptions?: subscriptionsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_subject_interestsInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutStudentsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_subject_interestsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_subject_interestsInput, studentsUncheckedCreateWithoutStudent_subject_interestsInput>
  }

  export type subjectsCreateWithoutStudent_subject_interestsInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsCreateNestedManyWithoutSubjectsInput
    resources?: resourcesCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsCreateNestedManyWithoutSubjectsInput
    subject_categories?: subject_categoriesCreateNestedOneWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutStudent_subject_interestsInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    resources?: resourcesUncheckedCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutStudent_subject_interestsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutStudent_subject_interestsInput, subjectsUncheckedCreateWithoutStudent_subject_interestsInput>
  }

  export type studentsUpsertWithoutStudent_subject_interestsInput = {
    update: XOR<studentsUpdateWithoutStudent_subject_interestsInput, studentsUncheckedUpdateWithoutStudent_subject_interestsInput>
    create: XOR<studentsCreateWithoutStudent_subject_interestsInput, studentsUncheckedCreateWithoutStudent_subject_interestsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_subject_interestsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_subject_interestsInput, studentsUncheckedUpdateWithoutStudent_subject_interestsInput>
  }

  export type studentsUpdateWithoutStudent_subject_interestsInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_subject_interestsInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type subjectsUpsertWithoutStudent_subject_interestsInput = {
    update: XOR<subjectsUpdateWithoutStudent_subject_interestsInput, subjectsUncheckedUpdateWithoutStudent_subject_interestsInput>
    create: XOR<subjectsCreateWithoutStudent_subject_interestsInput, subjectsUncheckedCreateWithoutStudent_subject_interestsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutStudent_subject_interestsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutStudent_subject_interestsInput, subjectsUncheckedUpdateWithoutStudent_subject_interestsInput>
  }

  export type subjectsUpdateWithoutStudent_subject_interestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUpdateManyWithoutSubjectsNestedInput
    subject_categories?: subject_categoriesUpdateOneWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutStudent_subject_interestsInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type group_session_participantsCreateWithoutStudentsInput = {
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
    group_sessions: group_sessionsCreateNestedOneWithoutGroup_session_participantsInput
  }

  export type group_session_participantsUncheckedCreateWithoutStudentsInput = {
    participation_id?: number
    group_session_id: number
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
  }

  export type group_session_participantsCreateOrConnectWithoutStudentsInput = {
    where: group_session_participantsWhereUniqueInput
    create: XOR<group_session_participantsCreateWithoutStudentsInput, group_session_participantsUncheckedCreateWithoutStudentsInput>
  }

  export type group_session_participantsCreateManyStudentsInputEnvelope = {
    data: group_session_participantsCreateManyStudentsInput | group_session_participantsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type session_ratingsCreateWithoutStudentsInput = {
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
    sessions: sessionsCreateNestedOneWithoutSession_ratingsInput
    tutors: tutorsCreateNestedOneWithoutSession_ratingsInput
  }

  export type session_ratingsUncheckedCreateWithoutStudentsInput = {
    rating_id?: number
    session_id: number
    tutor_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type session_ratingsCreateOrConnectWithoutStudentsInput = {
    where: session_ratingsWhereUniqueInput
    create: XOR<session_ratingsCreateWithoutStudentsInput, session_ratingsUncheckedCreateWithoutStudentsInput>
  }

  export type session_ratingsCreateManyStudentsInputEnvelope = {
    data: session_ratingsCreateManyStudentsInput | session_ratingsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutStudentsInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutStudentsInput = {
    session_id?: number
    tutor_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutStudentsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutStudentsInput, sessionsUncheckedCreateWithoutStudentsInput>
  }

  export type sessionsCreateManyStudentsInputEnvelope = {
    data: sessionsCreateManyStudentsInput | sessionsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type student_subject_interestsCreateWithoutStudentsInput = {
    interest_level?: string | null
    subjects: subjectsCreateNestedOneWithoutStudent_subject_interestsInput
  }

  export type student_subject_interestsUncheckedCreateWithoutStudentsInput = {
    interest_id?: number
    subject_id: number
    interest_level?: string | null
  }

  export type student_subject_interestsCreateOrConnectWithoutStudentsInput = {
    where: student_subject_interestsWhereUniqueInput
    create: XOR<student_subject_interestsCreateWithoutStudentsInput, student_subject_interestsUncheckedCreateWithoutStudentsInput>
  }

  export type student_subject_interestsCreateManyStudentsInputEnvelope = {
    data: student_subject_interestsCreateManyStudentsInput | student_subject_interestsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutStudentsInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    tutors?: tutorsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutStudentsInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    tutors?: tutorsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutStudentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
  }

  export type subscriptionsCreateWithoutStudentsInput = {
    plan_name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle: string
    sessions_included?: number | null
    hours_included?: Decimal | DecimalJsLike | number | string | null
    start_date: Date | string
    end_date?: Date | string | null
    is_active?: boolean | null
    auto_renew?: boolean | null
    payment_method?: string | null
    last_billing_date?: Date | string | null
    next_billing_date?: Date | string | null
  }

  export type subscriptionsUncheckedCreateWithoutStudentsInput = {
    subscription_id?: number
    plan_name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle: string
    sessions_included?: number | null
    hours_included?: Decimal | DecimalJsLike | number | string | null
    start_date: Date | string
    end_date?: Date | string | null
    is_active?: boolean | null
    auto_renew?: boolean | null
    payment_method?: string | null
    last_billing_date?: Date | string | null
    next_billing_date?: Date | string | null
  }

  export type subscriptionsCreateOrConnectWithoutStudentsInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutStudentsInput, subscriptionsUncheckedCreateWithoutStudentsInput>
  }

  export type subscriptionsCreateManyStudentsInputEnvelope = {
    data: subscriptionsCreateManyStudentsInput | subscriptionsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type group_session_participantsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: group_session_participantsWhereUniqueInput
    update: XOR<group_session_participantsUpdateWithoutStudentsInput, group_session_participantsUncheckedUpdateWithoutStudentsInput>
    create: XOR<group_session_participantsCreateWithoutStudentsInput, group_session_participantsUncheckedCreateWithoutStudentsInput>
  }

  export type group_session_participantsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: group_session_participantsWhereUniqueInput
    data: XOR<group_session_participantsUpdateWithoutStudentsInput, group_session_participantsUncheckedUpdateWithoutStudentsInput>
  }

  export type group_session_participantsUpdateManyWithWhereWithoutStudentsInput = {
    where: group_session_participantsScalarWhereInput
    data: XOR<group_session_participantsUpdateManyMutationInput, group_session_participantsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type session_ratingsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: session_ratingsWhereUniqueInput
    update: XOR<session_ratingsUpdateWithoutStudentsInput, session_ratingsUncheckedUpdateWithoutStudentsInput>
    create: XOR<session_ratingsCreateWithoutStudentsInput, session_ratingsUncheckedCreateWithoutStudentsInput>
  }

  export type session_ratingsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: session_ratingsWhereUniqueInput
    data: XOR<session_ratingsUpdateWithoutStudentsInput, session_ratingsUncheckedUpdateWithoutStudentsInput>
  }

  export type session_ratingsUpdateManyWithWhereWithoutStudentsInput = {
    where: session_ratingsScalarWhereInput
    data: XOR<session_ratingsUpdateManyMutationInput, session_ratingsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type session_ratingsScalarWhereInput = {
    AND?: session_ratingsScalarWhereInput | session_ratingsScalarWhereInput[]
    OR?: session_ratingsScalarWhereInput[]
    NOT?: session_ratingsScalarWhereInput | session_ratingsScalarWhereInput[]
    rating_id?: IntFilter<"session_ratings"> | number
    session_id?: IntFilter<"session_ratings"> | number
    student_id?: IntFilter<"session_ratings"> | number
    tutor_id?: IntFilter<"session_ratings"> | number
    rating?: DecimalFilter<"session_ratings"> | Decimal | DecimalJsLike | number | string
    feedback?: StringNullableFilter<"session_ratings"> | string | null
    created_at?: DateTimeNullableFilter<"session_ratings"> | Date | string | null
  }

  export type sessionsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutStudentsInput, sessionsUncheckedUpdateWithoutStudentsInput>
    create: XOR<sessionsCreateWithoutStudentsInput, sessionsUncheckedCreateWithoutStudentsInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutStudentsInput, sessionsUncheckedUpdateWithoutStudentsInput>
  }

  export type sessionsUpdateManyWithWhereWithoutStudentsInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    session_id?: IntFilter<"sessions"> | number
    tutor_id?: IntFilter<"sessions"> | number
    student_id?: IntFilter<"sessions"> | number
    subject_id?: IntFilter<"sessions"> | number
    start_time?: DateTimeFilter<"sessions"> | Date | string
    end_time?: DateTimeFilter<"sessions"> | Date | string
    duration_minutes?: IntNullableFilter<"sessions"> | number | null
    hourly_rate?: DecimalFilter<"sessions"> | Decimal | DecimalJsLike | number | string
    session_cost?: DecimalNullableFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"sessions"> | string
    meeting_url?: StringNullableFilter<"sessions"> | string | null
    notes?: StringNullableFilter<"sessions"> | string | null
    materials_url?: StringNullableFilter<"sessions"> | string | null
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    canceled_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"sessions"> | string | null
    cancellation_fee?: DecimalNullableFilter<"sessions"> | Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: student_subject_interestsWhereUniqueInput
    update: XOR<student_subject_interestsUpdateWithoutStudentsInput, student_subject_interestsUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_subject_interestsCreateWithoutStudentsInput, student_subject_interestsUncheckedCreateWithoutStudentsInput>
  }

  export type student_subject_interestsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: student_subject_interestsWhereUniqueInput
    data: XOR<student_subject_interestsUpdateWithoutStudentsInput, student_subject_interestsUncheckedUpdateWithoutStudentsInput>
  }

  export type student_subject_interestsUpdateManyWithWhereWithoutStudentsInput = {
    where: student_subject_interestsScalarWhereInput
    data: XOR<student_subject_interestsUpdateManyMutationInput, student_subject_interestsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type student_subject_interestsScalarWhereInput = {
    AND?: student_subject_interestsScalarWhereInput | student_subject_interestsScalarWhereInput[]
    OR?: student_subject_interestsScalarWhereInput[]
    NOT?: student_subject_interestsScalarWhereInput | student_subject_interestsScalarWhereInput[]
    interest_id?: IntFilter<"student_subject_interests"> | number
    student_id?: IntFilter<"student_subject_interests"> | number
    subject_id?: IntFilter<"student_subject_interests"> | number
    interest_level?: StringNullableFilter<"student_subject_interests"> | string | null
  }

  export type usersUpsertWithoutStudentsInput = {
    update: XOR<usersUpdateWithoutStudentsInput, usersUncheckedUpdateWithoutStudentsInput>
    create: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudentsInput, usersUncheckedUpdateWithoutStudentsInput>
  }

  export type usersUpdateWithoutStudentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    tutors?: tutorsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutStudentsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    tutors?: tutorsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type subscriptionsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: subscriptionsWhereUniqueInput
    update: XOR<subscriptionsUpdateWithoutStudentsInput, subscriptionsUncheckedUpdateWithoutStudentsInput>
    create: XOR<subscriptionsCreateWithoutStudentsInput, subscriptionsUncheckedCreateWithoutStudentsInput>
  }

  export type subscriptionsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: subscriptionsWhereUniqueInput
    data: XOR<subscriptionsUpdateWithoutStudentsInput, subscriptionsUncheckedUpdateWithoutStudentsInput>
  }

  export type subscriptionsUpdateManyWithWhereWithoutStudentsInput = {
    where: subscriptionsScalarWhereInput
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type subscriptionsScalarWhereInput = {
    AND?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
    OR?: subscriptionsScalarWhereInput[]
    NOT?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
    subscription_id?: IntFilter<"subscriptions"> | number
    student_id?: IntFilter<"subscriptions"> | number
    plan_name?: StringFilter<"subscriptions"> | string
    description?: StringNullableFilter<"subscriptions"> | string | null
    price?: DecimalFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFilter<"subscriptions"> | string
    sessions_included?: IntNullableFilter<"subscriptions"> | number | null
    hours_included?: DecimalNullableFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFilter<"subscriptions"> | Date | string
    end_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    is_active?: BoolNullableFilter<"subscriptions"> | boolean | null
    auto_renew?: BoolNullableFilter<"subscriptions"> | boolean | null
    payment_method?: StringNullableFilter<"subscriptions"> | string | null
    last_billing_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
  }

  export type subjectsCreateWithoutSubject_categoriesInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsCreateNestedManyWithoutSubjectsInput
    resources?: resourcesCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutSubject_categoriesInput = {
    subject_id?: number
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    resources?: resourcesUncheckedCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutSubject_categoriesInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutSubject_categoriesInput, subjectsUncheckedCreateWithoutSubject_categoriesInput>
  }

  export type subjectsCreateManySubject_categoriesInputEnvelope = {
    data: subjectsCreateManySubject_categoriesInput | subjectsCreateManySubject_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type subjectsUpsertWithWhereUniqueWithoutSubject_categoriesInput = {
    where: subjectsWhereUniqueInput
    update: XOR<subjectsUpdateWithoutSubject_categoriesInput, subjectsUncheckedUpdateWithoutSubject_categoriesInput>
    create: XOR<subjectsCreateWithoutSubject_categoriesInput, subjectsUncheckedCreateWithoutSubject_categoriesInput>
  }

  export type subjectsUpdateWithWhereUniqueWithoutSubject_categoriesInput = {
    where: subjectsWhereUniqueInput
    data: XOR<subjectsUpdateWithoutSubject_categoriesInput, subjectsUncheckedUpdateWithoutSubject_categoriesInput>
  }

  export type subjectsUpdateManyWithWhereWithoutSubject_categoriesInput = {
    where: subjectsScalarWhereInput
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyWithoutSubject_categoriesInput>
  }

  export type subjectsScalarWhereInput = {
    AND?: subjectsScalarWhereInput | subjectsScalarWhereInput[]
    OR?: subjectsScalarWhereInput[]
    NOT?: subjectsScalarWhereInput | subjectsScalarWhereInput[]
    subject_id?: IntFilter<"subjects"> | number
    category_id?: IntNullableFilter<"subjects"> | number | null
    name?: StringFilter<"subjects"> | string
    description?: StringNullableFilter<"subjects"> | string | null
    difficulty_level?: StringNullableFilter<"subjects"> | string | null
  }

  export type group_sessionsCreateWithoutSubjectsInput = {
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutGroup_sessionsInput
    tutors: tutorsCreateNestedOneWithoutGroup_sessionsInput
  }

  export type group_sessionsUncheckedCreateWithoutSubjectsInput = {
    group_session_id?: number
    tutor_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutGroup_sessionsInput
  }

  export type group_sessionsCreateOrConnectWithoutSubjectsInput = {
    where: group_sessionsWhereUniqueInput
    create: XOR<group_sessionsCreateWithoutSubjectsInput, group_sessionsUncheckedCreateWithoutSubjectsInput>
  }

  export type group_sessionsCreateManySubjectsInputEnvelope = {
    data: group_sessionsCreateManySubjectsInput | group_sessionsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type resourcesCreateWithoutSubjectsInput = {
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    users: usersCreateNestedOneWithoutResourcesInput
    session_resources?: session_resourcesCreateNestedManyWithoutResourcesInput
  }

  export type resourcesUncheckedCreateWithoutSubjectsInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    uploaded_by: number
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutResourcesInput
  }

  export type resourcesCreateOrConnectWithoutSubjectsInput = {
    where: resourcesWhereUniqueInput
    create: XOR<resourcesCreateWithoutSubjectsInput, resourcesUncheckedCreateWithoutSubjectsInput>
  }

  export type resourcesCreateManySubjectsInputEnvelope = {
    data: resourcesCreateManySubjectsInput | resourcesCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutSubjectsInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    tutors: tutorsCreateNestedOneWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutSubjectsInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutSubjectsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutSubjectsInput, sessionsUncheckedCreateWithoutSubjectsInput>
  }

  export type sessionsCreateManySubjectsInputEnvelope = {
    data: sessionsCreateManySubjectsInput | sessionsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type student_subject_interestsCreateWithoutSubjectsInput = {
    interest_level?: string | null
    students: studentsCreateNestedOneWithoutStudent_subject_interestsInput
  }

  export type student_subject_interestsUncheckedCreateWithoutSubjectsInput = {
    interest_id?: number
    student_id: number
    interest_level?: string | null
  }

  export type student_subject_interestsCreateOrConnectWithoutSubjectsInput = {
    where: student_subject_interestsWhereUniqueInput
    create: XOR<student_subject_interestsCreateWithoutSubjectsInput, student_subject_interestsUncheckedCreateWithoutSubjectsInput>
  }

  export type student_subject_interestsCreateManySubjectsInputEnvelope = {
    data: student_subject_interestsCreateManySubjectsInput | student_subject_interestsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type subject_categoriesCreateWithoutSubjectsInput = {
    name: string
    description?: string | null
  }

  export type subject_categoriesUncheckedCreateWithoutSubjectsInput = {
    category_id?: number
    name: string
    description?: string | null
  }

  export type subject_categoriesCreateOrConnectWithoutSubjectsInput = {
    where: subject_categoriesWhereUniqueInput
    create: XOR<subject_categoriesCreateWithoutSubjectsInput, subject_categoriesUncheckedCreateWithoutSubjectsInput>
  }

  export type tutor_subjectsCreateWithoutSubjectsInput = {
    proficiency_level: string
    verified?: boolean | null
    tutors: tutorsCreateNestedOneWithoutTutor_subjectsInput
  }

  export type tutor_subjectsUncheckedCreateWithoutSubjectsInput = {
    tutor_subject_id?: number
    tutor_id: number
    proficiency_level: string
    verified?: boolean | null
  }

  export type tutor_subjectsCreateOrConnectWithoutSubjectsInput = {
    where: tutor_subjectsWhereUniqueInput
    create: XOR<tutor_subjectsCreateWithoutSubjectsInput, tutor_subjectsUncheckedCreateWithoutSubjectsInput>
  }

  export type tutor_subjectsCreateManySubjectsInputEnvelope = {
    data: tutor_subjectsCreateManySubjectsInput | tutor_subjectsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type group_sessionsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: group_sessionsWhereUniqueInput
    update: XOR<group_sessionsUpdateWithoutSubjectsInput, group_sessionsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<group_sessionsCreateWithoutSubjectsInput, group_sessionsUncheckedCreateWithoutSubjectsInput>
  }

  export type group_sessionsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: group_sessionsWhereUniqueInput
    data: XOR<group_sessionsUpdateWithoutSubjectsInput, group_sessionsUncheckedUpdateWithoutSubjectsInput>
  }

  export type group_sessionsUpdateManyWithWhereWithoutSubjectsInput = {
    where: group_sessionsScalarWhereInput
    data: XOR<group_sessionsUpdateManyMutationInput, group_sessionsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type group_sessionsScalarWhereInput = {
    AND?: group_sessionsScalarWhereInput | group_sessionsScalarWhereInput[]
    OR?: group_sessionsScalarWhereInput[]
    NOT?: group_sessionsScalarWhereInput | group_sessionsScalarWhereInput[]
    group_session_id?: IntFilter<"group_sessions"> | number
    tutor_id?: IntFilter<"group_sessions"> | number
    subject_id?: IntFilter<"group_sessions"> | number
    title?: StringFilter<"group_sessions"> | string
    description?: StringNullableFilter<"group_sessions"> | string | null
    start_time?: DateTimeFilter<"group_sessions"> | Date | string
    end_time?: DateTimeFilter<"group_sessions"> | Date | string
    max_participants?: IntFilter<"group_sessions"> | number
    current_participants?: IntNullableFilter<"group_sessions"> | number | null
    price_per_student?: DecimalFilter<"group_sessions"> | Decimal | DecimalJsLike | number | string
    meeting_url?: StringNullableFilter<"group_sessions"> | string | null
    status?: StringFilter<"group_sessions"> | string
    created_at?: DateTimeNullableFilter<"group_sessions"> | Date | string | null
  }

  export type resourcesUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: resourcesWhereUniqueInput
    update: XOR<resourcesUpdateWithoutSubjectsInput, resourcesUncheckedUpdateWithoutSubjectsInput>
    create: XOR<resourcesCreateWithoutSubjectsInput, resourcesUncheckedCreateWithoutSubjectsInput>
  }

  export type resourcesUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: resourcesWhereUniqueInput
    data: XOR<resourcesUpdateWithoutSubjectsInput, resourcesUncheckedUpdateWithoutSubjectsInput>
  }

  export type resourcesUpdateManyWithWhereWithoutSubjectsInput = {
    where: resourcesScalarWhereInput
    data: XOR<resourcesUpdateManyMutationInput, resourcesUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type resourcesScalarWhereInput = {
    AND?: resourcesScalarWhereInput | resourcesScalarWhereInput[]
    OR?: resourcesScalarWhereInput[]
    NOT?: resourcesScalarWhereInput | resourcesScalarWhereInput[]
    resource_id?: IntFilter<"resources"> | number
    title?: StringFilter<"resources"> | string
    description?: StringNullableFilter<"resources"> | string | null
    url?: StringNullableFilter<"resources"> | string | null
    file_path?: StringNullableFilter<"resources"> | string | null
    subject_id?: IntNullableFilter<"resources"> | number | null
    uploaded_by?: IntFilter<"resources"> | number
    resource_type?: StringFilter<"resources"> | string
    is_public?: BoolNullableFilter<"resources"> | boolean | null
    created_at?: DateTimeNullableFilter<"resources"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"resources"> | Date | string | null
  }

  export type sessionsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutSubjectsInput, sessionsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<sessionsCreateWithoutSubjectsInput, sessionsUncheckedCreateWithoutSubjectsInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutSubjectsInput, sessionsUncheckedUpdateWithoutSubjectsInput>
  }

  export type sessionsUpdateManyWithWhereWithoutSubjectsInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type student_subject_interestsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: student_subject_interestsWhereUniqueInput
    update: XOR<student_subject_interestsUpdateWithoutSubjectsInput, student_subject_interestsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<student_subject_interestsCreateWithoutSubjectsInput, student_subject_interestsUncheckedCreateWithoutSubjectsInput>
  }

  export type student_subject_interestsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: student_subject_interestsWhereUniqueInput
    data: XOR<student_subject_interestsUpdateWithoutSubjectsInput, student_subject_interestsUncheckedUpdateWithoutSubjectsInput>
  }

  export type student_subject_interestsUpdateManyWithWhereWithoutSubjectsInput = {
    where: student_subject_interestsScalarWhereInput
    data: XOR<student_subject_interestsUpdateManyMutationInput, student_subject_interestsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type subject_categoriesUpsertWithoutSubjectsInput = {
    update: XOR<subject_categoriesUpdateWithoutSubjectsInput, subject_categoriesUncheckedUpdateWithoutSubjectsInput>
    create: XOR<subject_categoriesCreateWithoutSubjectsInput, subject_categoriesUncheckedCreateWithoutSubjectsInput>
    where?: subject_categoriesWhereInput
  }

  export type subject_categoriesUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: subject_categoriesWhereInput
    data: XOR<subject_categoriesUpdateWithoutSubjectsInput, subject_categoriesUncheckedUpdateWithoutSubjectsInput>
  }

  export type subject_categoriesUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subject_categoriesUncheckedUpdateWithoutSubjectsInput = {
    category_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tutor_subjectsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: tutor_subjectsWhereUniqueInput
    update: XOR<tutor_subjectsUpdateWithoutSubjectsInput, tutor_subjectsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<tutor_subjectsCreateWithoutSubjectsInput, tutor_subjectsUncheckedCreateWithoutSubjectsInput>
  }

  export type tutor_subjectsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: tutor_subjectsWhereUniqueInput
    data: XOR<tutor_subjectsUpdateWithoutSubjectsInput, tutor_subjectsUncheckedUpdateWithoutSubjectsInput>
  }

  export type tutor_subjectsUpdateManyWithWhereWithoutSubjectsInput = {
    where: tutor_subjectsScalarWhereInput
    data: XOR<tutor_subjectsUpdateManyMutationInput, tutor_subjectsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type tutor_subjectsScalarWhereInput = {
    AND?: tutor_subjectsScalarWhereInput | tutor_subjectsScalarWhereInput[]
    OR?: tutor_subjectsScalarWhereInput[]
    NOT?: tutor_subjectsScalarWhereInput | tutor_subjectsScalarWhereInput[]
    tutor_subject_id?: IntFilter<"tutor_subjects"> | number
    tutor_id?: IntFilter<"tutor_subjects"> | number
    subject_id?: IntFilter<"tutor_subjects"> | number
    proficiency_level?: StringFilter<"tutor_subjects"> | string
    verified?: BoolNullableFilter<"tutor_subjects"> | boolean | null
  }

  export type studentsCreateWithoutSubscriptionsInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutStudentsInput
    sessions?: sessionsCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutStudentsInput
    users: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutSubscriptionsInput = {
    student_id?: number
    user_id: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutStudentsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutSubscriptionsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutSubscriptionsInput, studentsUncheckedCreateWithoutSubscriptionsInput>
  }

  export type studentsUpsertWithoutSubscriptionsInput = {
    update: XOR<studentsUpdateWithoutSubscriptionsInput, studentsUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<studentsCreateWithoutSubscriptionsInput, studentsUncheckedCreateWithoutSubscriptionsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutSubscriptionsInput, studentsUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type studentsUpdateWithoutSubscriptionsInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutSubscriptionsInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type tutorsCreateWithoutTutor_availabilityInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutTutorsInput
    sessions?: sessionsCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutTutorsInput
    users: usersCreateNestedOneWithoutTutorsInput
  }

  export type tutorsUncheckedCreateWithoutTutor_availabilityInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutTutorsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsCreateOrConnectWithoutTutor_availabilityInput = {
    where: tutorsWhereUniqueInput
    create: XOR<tutorsCreateWithoutTutor_availabilityInput, tutorsUncheckedCreateWithoutTutor_availabilityInput>
  }

  export type tutorsUpsertWithoutTutor_availabilityInput = {
    update: XOR<tutorsUpdateWithoutTutor_availabilityInput, tutorsUncheckedUpdateWithoutTutor_availabilityInput>
    create: XOR<tutorsCreateWithoutTutor_availabilityInput, tutorsUncheckedCreateWithoutTutor_availabilityInput>
    where?: tutorsWhereInput
  }

  export type tutorsUpdateToOneWithWhereWithoutTutor_availabilityInput = {
    where?: tutorsWhereInput
    data: XOR<tutorsUpdateWithoutTutor_availabilityInput, tutorsUncheckedUpdateWithoutTutor_availabilityInput>
  }

  export type tutorsUpdateWithoutTutor_availabilityInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutTutorsNestedInput
    users?: usersUpdateOneRequiredWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateWithoutTutor_availabilityInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type tutorsCreateWithoutTutor_subjectsInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutTutorsInput
    sessions?: sessionsCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityCreateNestedManyWithoutTutorsInput
    users: usersCreateNestedOneWithoutTutorsInput
  }

  export type tutorsUncheckedCreateWithoutTutor_subjectsInput = {
    tutor_id?: number
    user_id: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutTutorsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsCreateOrConnectWithoutTutor_subjectsInput = {
    where: tutorsWhereUniqueInput
    create: XOR<tutorsCreateWithoutTutor_subjectsInput, tutorsUncheckedCreateWithoutTutor_subjectsInput>
  }

  export type subjectsCreateWithoutTutor_subjectsInput = {
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsCreateNestedManyWithoutSubjectsInput
    resources?: resourcesCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutSubjectsInput
    subject_categories?: subject_categoriesCreateNestedOneWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutTutor_subjectsInput = {
    subject_id?: number
    category_id?: number | null
    name: string
    description?: string | null
    difficulty_level?: string | null
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    resources?: resourcesUncheckedCreateNestedManyWithoutSubjectsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutSubjectsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutTutor_subjectsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutTutor_subjectsInput, subjectsUncheckedCreateWithoutTutor_subjectsInput>
  }

  export type tutorsUpsertWithoutTutor_subjectsInput = {
    update: XOR<tutorsUpdateWithoutTutor_subjectsInput, tutorsUncheckedUpdateWithoutTutor_subjectsInput>
    create: XOR<tutorsCreateWithoutTutor_subjectsInput, tutorsUncheckedCreateWithoutTutor_subjectsInput>
    where?: tutorsWhereInput
  }

  export type tutorsUpdateToOneWithWhereWithoutTutor_subjectsInput = {
    where?: tutorsWhereInput
    data: XOR<tutorsUpdateWithoutTutor_subjectsInput, tutorsUncheckedUpdateWithoutTutor_subjectsInput>
  }

  export type tutorsUpdateWithoutTutor_subjectsInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUpdateManyWithoutTutorsNestedInput
    users?: usersUpdateOneRequiredWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateWithoutTutor_subjectsInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type subjectsUpsertWithoutTutor_subjectsInput = {
    update: XOR<subjectsUpdateWithoutTutor_subjectsInput, subjectsUncheckedUpdateWithoutTutor_subjectsInput>
    create: XOR<subjectsCreateWithoutTutor_subjectsInput, subjectsUncheckedCreateWithoutTutor_subjectsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutTutor_subjectsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutTutor_subjectsInput, subjectsUncheckedUpdateWithoutTutor_subjectsInput>
  }

  export type subjectsUpdateWithoutTutor_subjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutSubjectsNestedInput
    subject_categories?: subject_categoriesUpdateOneWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutTutor_subjectsInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type group_sessionsCreateWithoutTutorsInput = {
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutGroup_sessionsInput
    subjects: subjectsCreateNestedOneWithoutGroup_sessionsInput
  }

  export type group_sessionsUncheckedCreateWithoutTutorsInput = {
    group_session_id?: number
    subject_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutGroup_sessionsInput
  }

  export type group_sessionsCreateOrConnectWithoutTutorsInput = {
    where: group_sessionsWhereUniqueInput
    create: XOR<group_sessionsCreateWithoutTutorsInput, group_sessionsUncheckedCreateWithoutTutorsInput>
  }

  export type group_sessionsCreateManyTutorsInputEnvelope = {
    data: group_sessionsCreateManyTutorsInput | group_sessionsCreateManyTutorsInput[]
    skipDuplicates?: boolean
  }

  export type session_ratingsCreateWithoutTutorsInput = {
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
    sessions: sessionsCreateNestedOneWithoutSession_ratingsInput
    students: studentsCreateNestedOneWithoutSession_ratingsInput
  }

  export type session_ratingsUncheckedCreateWithoutTutorsInput = {
    rating_id?: number
    session_id: number
    student_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type session_ratingsCreateOrConnectWithoutTutorsInput = {
    where: session_ratingsWhereUniqueInput
    create: XOR<session_ratingsCreateWithoutTutorsInput, session_ratingsUncheckedCreateWithoutTutorsInput>
  }

  export type session_ratingsCreateManyTutorsInputEnvelope = {
    data: session_ratingsCreateManyTutorsInput | session_ratingsCreateManyTutorsInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutTutorsInput = {
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesCreateNestedManyWithoutSessionsInput
    students: studentsCreateNestedOneWithoutSessionsInput
    subjects: subjectsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutTutorsInput = {
    session_id?: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutSessionsInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutSessionsInput
    session_ratings?: session_ratingsUncheckedCreateNestedOneWithoutSessionsInput
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutTutorsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutTutorsInput, sessionsUncheckedCreateWithoutTutorsInput>
  }

  export type sessionsCreateManyTutorsInputEnvelope = {
    data: sessionsCreateManyTutorsInput | sessionsCreateManyTutorsInput[]
    skipDuplicates?: boolean
  }

  export type tutor_availabilityCreateWithoutTutorsInput = {
    day_of_week: number
    start_time: Date | string
    end_time: Date | string
    is_recurring?: boolean | null
    specific_date?: Date | string | null
  }

  export type tutor_availabilityUncheckedCreateWithoutTutorsInput = {
    availability_id?: number
    day_of_week: number
    start_time: Date | string
    end_time: Date | string
    is_recurring?: boolean | null
    specific_date?: Date | string | null
  }

  export type tutor_availabilityCreateOrConnectWithoutTutorsInput = {
    where: tutor_availabilityWhereUniqueInput
    create: XOR<tutor_availabilityCreateWithoutTutorsInput, tutor_availabilityUncheckedCreateWithoutTutorsInput>
  }

  export type tutor_availabilityCreateManyTutorsInputEnvelope = {
    data: tutor_availabilityCreateManyTutorsInput | tutor_availabilityCreateManyTutorsInput[]
    skipDuplicates?: boolean
  }

  export type tutor_subjectsCreateWithoutTutorsInput = {
    proficiency_level: string
    verified?: boolean | null
    subjects: subjectsCreateNestedOneWithoutTutor_subjectsInput
  }

  export type tutor_subjectsUncheckedCreateWithoutTutorsInput = {
    tutor_subject_id?: number
    subject_id: number
    proficiency_level: string
    verified?: boolean | null
  }

  export type tutor_subjectsCreateOrConnectWithoutTutorsInput = {
    where: tutor_subjectsWhereUniqueInput
    create: XOR<tutor_subjectsCreateWithoutTutorsInput, tutor_subjectsUncheckedCreateWithoutTutorsInput>
  }

  export type tutor_subjectsCreateManyTutorsInputEnvelope = {
    data: tutor_subjectsCreateManyTutorsInput | tutor_subjectsCreateManyTutorsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTutorsInput = {
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    resources?: resourcesCreateNestedManyWithoutUsersInput
    session_notes?: session_notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTutorsInput = {
    user_id?: number
    email: string
    password_hash: string
    first_name: string
    last_name: string
    phone?: string | null
    date_of_birth?: Date | string | null
    profile_picture?: string | null
    bio?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_sender_idTousersInput
    messages_messages_recipient_idTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_recipient_idTousersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    resources?: resourcesUncheckedCreateNestedManyWithoutUsersInput
    session_notes?: session_notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTutorsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTutorsInput, usersUncheckedCreateWithoutTutorsInput>
  }

  export type group_sessionsUpsertWithWhereUniqueWithoutTutorsInput = {
    where: group_sessionsWhereUniqueInput
    update: XOR<group_sessionsUpdateWithoutTutorsInput, group_sessionsUncheckedUpdateWithoutTutorsInput>
    create: XOR<group_sessionsCreateWithoutTutorsInput, group_sessionsUncheckedCreateWithoutTutorsInput>
  }

  export type group_sessionsUpdateWithWhereUniqueWithoutTutorsInput = {
    where: group_sessionsWhereUniqueInput
    data: XOR<group_sessionsUpdateWithoutTutorsInput, group_sessionsUncheckedUpdateWithoutTutorsInput>
  }

  export type group_sessionsUpdateManyWithWhereWithoutTutorsInput = {
    where: group_sessionsScalarWhereInput
    data: XOR<group_sessionsUpdateManyMutationInput, group_sessionsUncheckedUpdateManyWithoutTutorsInput>
  }

  export type session_ratingsUpsertWithWhereUniqueWithoutTutorsInput = {
    where: session_ratingsWhereUniqueInput
    update: XOR<session_ratingsUpdateWithoutTutorsInput, session_ratingsUncheckedUpdateWithoutTutorsInput>
    create: XOR<session_ratingsCreateWithoutTutorsInput, session_ratingsUncheckedCreateWithoutTutorsInput>
  }

  export type session_ratingsUpdateWithWhereUniqueWithoutTutorsInput = {
    where: session_ratingsWhereUniqueInput
    data: XOR<session_ratingsUpdateWithoutTutorsInput, session_ratingsUncheckedUpdateWithoutTutorsInput>
  }

  export type session_ratingsUpdateManyWithWhereWithoutTutorsInput = {
    where: session_ratingsScalarWhereInput
    data: XOR<session_ratingsUpdateManyMutationInput, session_ratingsUncheckedUpdateManyWithoutTutorsInput>
  }

  export type sessionsUpsertWithWhereUniqueWithoutTutorsInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutTutorsInput, sessionsUncheckedUpdateWithoutTutorsInput>
    create: XOR<sessionsCreateWithoutTutorsInput, sessionsUncheckedCreateWithoutTutorsInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutTutorsInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutTutorsInput, sessionsUncheckedUpdateWithoutTutorsInput>
  }

  export type sessionsUpdateManyWithWhereWithoutTutorsInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutTutorsInput>
  }

  export type tutor_availabilityUpsertWithWhereUniqueWithoutTutorsInput = {
    where: tutor_availabilityWhereUniqueInput
    update: XOR<tutor_availabilityUpdateWithoutTutorsInput, tutor_availabilityUncheckedUpdateWithoutTutorsInput>
    create: XOR<tutor_availabilityCreateWithoutTutorsInput, tutor_availabilityUncheckedCreateWithoutTutorsInput>
  }

  export type tutor_availabilityUpdateWithWhereUniqueWithoutTutorsInput = {
    where: tutor_availabilityWhereUniqueInput
    data: XOR<tutor_availabilityUpdateWithoutTutorsInput, tutor_availabilityUncheckedUpdateWithoutTutorsInput>
  }

  export type tutor_availabilityUpdateManyWithWhereWithoutTutorsInput = {
    where: tutor_availabilityScalarWhereInput
    data: XOR<tutor_availabilityUpdateManyMutationInput, tutor_availabilityUncheckedUpdateManyWithoutTutorsInput>
  }

  export type tutor_availabilityScalarWhereInput = {
    AND?: tutor_availabilityScalarWhereInput | tutor_availabilityScalarWhereInput[]
    OR?: tutor_availabilityScalarWhereInput[]
    NOT?: tutor_availabilityScalarWhereInput | tutor_availabilityScalarWhereInput[]
    availability_id?: IntFilter<"tutor_availability"> | number
    tutor_id?: IntFilter<"tutor_availability"> | number
    day_of_week?: IntFilter<"tutor_availability"> | number
    start_time?: DateTimeFilter<"tutor_availability"> | Date | string
    end_time?: DateTimeFilter<"tutor_availability"> | Date | string
    is_recurring?: BoolNullableFilter<"tutor_availability"> | boolean | null
    specific_date?: DateTimeNullableFilter<"tutor_availability"> | Date | string | null
  }

  export type tutor_subjectsUpsertWithWhereUniqueWithoutTutorsInput = {
    where: tutor_subjectsWhereUniqueInput
    update: XOR<tutor_subjectsUpdateWithoutTutorsInput, tutor_subjectsUncheckedUpdateWithoutTutorsInput>
    create: XOR<tutor_subjectsCreateWithoutTutorsInput, tutor_subjectsUncheckedCreateWithoutTutorsInput>
  }

  export type tutor_subjectsUpdateWithWhereUniqueWithoutTutorsInput = {
    where: tutor_subjectsWhereUniqueInput
    data: XOR<tutor_subjectsUpdateWithoutTutorsInput, tutor_subjectsUncheckedUpdateWithoutTutorsInput>
  }

  export type tutor_subjectsUpdateManyWithWhereWithoutTutorsInput = {
    where: tutor_subjectsScalarWhereInput
    data: XOR<tutor_subjectsUpdateManyMutationInput, tutor_subjectsUncheckedUpdateManyWithoutTutorsInput>
  }

  export type usersUpsertWithoutTutorsInput = {
    update: XOR<usersUpdateWithoutTutorsInput, usersUncheckedUpdateWithoutTutorsInput>
    create: XOR<usersCreateWithoutTutorsInput, usersUncheckedCreateWithoutTutorsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTutorsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTutorsInput, usersUncheckedUpdateWithoutTutorsInput>
  }

  export type usersUpdateWithoutTutorsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    resources?: resourcesUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTutorsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages_messages_sender_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersNestedInput
    messages_messages_recipient_idTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutUsersNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type messagesCreateWithoutUsers_messages_sender_idTousersInput = {
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
    users_messages_recipient_idTousers: usersCreateNestedOneWithoutMessages_messages_recipient_idTousersInput
  }

  export type messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput = {
    message_id?: number
    recipient_id: number
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
  }

  export type messagesCreateOrConnectWithoutUsers_messages_sender_idTousersInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput>
  }

  export type messagesCreateManyUsers_messages_sender_idTousersInputEnvelope = {
    data: messagesCreateManyUsers_messages_sender_idTousersInput | messagesCreateManyUsers_messages_sender_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutUsers_messages_recipient_idTousersInput = {
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
    users_messages_sender_idTousers: usersCreateNestedOneWithoutMessages_messages_sender_idTousersInput
  }

  export type messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput = {
    message_id?: number
    sender_id: number
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
  }

  export type messagesCreateOrConnectWithoutUsers_messages_recipient_idTousersInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput>
  }

  export type messagesCreateManyUsers_messages_recipient_idTousersInputEnvelope = {
    data: messagesCreateManyUsers_messages_recipient_idTousersInput | messagesCreateManyUsers_messages_recipient_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    title: string
    content: string
    notification_type: string
    related_id?: number | null
    created_at?: Date | string | null
    read_at?: Date | string | null
    is_read?: boolean | null
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    notification_id?: number
    title: string
    content: string
    notification_type: string
    related_id?: number | null
    created_at?: Date | string | null
    read_at?: Date | string | null
    is_read?: boolean | null
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type resourcesCreateWithoutUsersInput = {
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    subjects?: subjectsCreateNestedOneWithoutResourcesInput
    session_resources?: session_resourcesCreateNestedManyWithoutResourcesInput
  }

  export type resourcesUncheckedCreateWithoutUsersInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    subject_id?: number | null
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    session_resources?: session_resourcesUncheckedCreateNestedManyWithoutResourcesInput
  }

  export type resourcesCreateOrConnectWithoutUsersInput = {
    where: resourcesWhereUniqueInput
    create: XOR<resourcesCreateWithoutUsersInput, resourcesUncheckedCreateWithoutUsersInput>
  }

  export type resourcesCreateManyUsersInputEnvelope = {
    data: resourcesCreateManyUsersInput | resourcesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type session_notesCreateWithoutUsersInput = {
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
    sessions: sessionsCreateNestedOneWithoutSession_notesInput
  }

  export type session_notesUncheckedCreateWithoutUsersInput = {
    note_id?: number
    session_id: number
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
  }

  export type session_notesCreateOrConnectWithoutUsersInput = {
    where: session_notesWhereUniqueInput
    create: XOR<session_notesCreateWithoutUsersInput, session_notesUncheckedCreateWithoutUsersInput>
  }

  export type session_notesCreateManyUsersInputEnvelope = {
    data: session_notesCreateManyUsersInput | session_notesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutUsersInput = {
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutStudentsInput
    sessions?: sessionsCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutUsersInput = {
    student_id?: number
    education_level?: string | null
    grade_year?: string | null
    parent_guardian_name?: string | null
    parent_guardian_email?: string | null
    parent_guardian_phone?: string | null
    special_needs?: string | null
    learning_preferences?: string | null
    group_session_participants?: group_session_participantsUncheckedCreateNestedManyWithoutStudentsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutStudentsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutStudentsInput
    student_subject_interests?: student_subject_interestsUncheckedCreateNestedManyWithoutStudentsInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutUsersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
  }

  export type tutorsCreateWithoutUsersInput = {
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsCreateNestedManyWithoutTutorsInput
    sessions?: sessionsCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsCreateNestedManyWithoutTutorsInput
  }

  export type tutorsUncheckedCreateWithoutUsersInput = {
    tutor_id?: number
    hourly_rate: Decimal | DecimalJsLike | number | string
    experience_years?: number | null
    qualification: string
    background_check_status?: string | null
    background_check_date?: Date | string | null
    avg_rating?: Decimal | DecimalJsLike | number | string | null
    total_sessions?: number | null
    is_verified?: boolean | null
    verification_date?: Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedCreateNestedManyWithoutTutorsInput
    session_ratings?: session_ratingsUncheckedCreateNestedManyWithoutTutorsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutTutorsInput
    tutor_availability?: tutor_availabilityUncheckedCreateNestedManyWithoutTutorsInput
    tutor_subjects?: tutor_subjectsUncheckedCreateNestedManyWithoutTutorsInput
  }

  export type tutorsCreateOrConnectWithoutUsersInput = {
    where: tutorsWhereUniqueInput
    create: XOR<tutorsCreateWithoutUsersInput, tutorsUncheckedCreateWithoutUsersInput>
  }

  export type messagesUpsertWithWhereUniqueWithoutUsers_messages_sender_idTousersInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedUpdateWithoutUsers_messages_sender_idTousersInput>
    create: XOR<messagesCreateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_sender_idTousersInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUsers_messages_sender_idTousersInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUsers_messages_sender_idTousersInput, messagesUncheckedUpdateWithoutUsers_messages_sender_idTousersInput>
  }

  export type messagesUpdateManyWithWhereWithoutUsers_messages_sender_idTousersInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    message_id?: IntFilter<"messages"> | number
    sender_id?: IntFilter<"messages"> | number
    recipient_id?: IntFilter<"messages"> | number
    content?: StringFilter<"messages"> | string
    sent_at?: DateTimeNullableFilter<"messages"> | Date | string | null
    read_at?: DateTimeNullableFilter<"messages"> | Date | string | null
    attachment_url?: StringNullableFilter<"messages"> | string | null
  }

  export type messagesUpsertWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedUpdateWithoutUsers_messages_recipient_idTousersInput>
    create: XOR<messagesCreateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedCreateWithoutUsers_messages_recipient_idTousersInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUsers_messages_recipient_idTousersInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUsers_messages_recipient_idTousersInput, messagesUncheckedUpdateWithoutUsers_messages_recipient_idTousersInput>
  }

  export type messagesUpdateManyWithWhereWithoutUsers_messages_recipient_idTousersInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    notification_id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    content?: StringFilter<"notifications"> | string
    notification_type?: StringFilter<"notifications"> | string
    related_id?: IntNullableFilter<"notifications"> | number | null
    created_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    is_read?: BoolNullableFilter<"notifications"> | boolean | null
  }

  export type resourcesUpsertWithWhereUniqueWithoutUsersInput = {
    where: resourcesWhereUniqueInput
    update: XOR<resourcesUpdateWithoutUsersInput, resourcesUncheckedUpdateWithoutUsersInput>
    create: XOR<resourcesCreateWithoutUsersInput, resourcesUncheckedCreateWithoutUsersInput>
  }

  export type resourcesUpdateWithWhereUniqueWithoutUsersInput = {
    where: resourcesWhereUniqueInput
    data: XOR<resourcesUpdateWithoutUsersInput, resourcesUncheckedUpdateWithoutUsersInput>
  }

  export type resourcesUpdateManyWithWhereWithoutUsersInput = {
    where: resourcesScalarWhereInput
    data: XOR<resourcesUpdateManyMutationInput, resourcesUncheckedUpdateManyWithoutUsersInput>
  }

  export type session_notesUpsertWithWhereUniqueWithoutUsersInput = {
    where: session_notesWhereUniqueInput
    update: XOR<session_notesUpdateWithoutUsersInput, session_notesUncheckedUpdateWithoutUsersInput>
    create: XOR<session_notesCreateWithoutUsersInput, session_notesUncheckedCreateWithoutUsersInput>
  }

  export type session_notesUpdateWithWhereUniqueWithoutUsersInput = {
    where: session_notesWhereUniqueInput
    data: XOR<session_notesUpdateWithoutUsersInput, session_notesUncheckedUpdateWithoutUsersInput>
  }

  export type session_notesUpdateManyWithWhereWithoutUsersInput = {
    where: session_notesScalarWhereInput
    data: XOR<session_notesUpdateManyMutationInput, session_notesUncheckedUpdateManyWithoutUsersInput>
  }

  export type studentsUpsertWithoutUsersInput = {
    update: XOR<studentsUpdateWithoutUsersInput, studentsUncheckedUpdateWithoutUsersInput>
    create: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutUsersInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutUsersInput, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type studentsUpdateWithoutUsersInput = {
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutUsersInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    education_level?: NullableStringFieldUpdateOperationsInput | string | null
    grade_year?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    special_needs?: NullableStringFieldUpdateOperationsInput | string | null
    learning_preferences?: NullableStringFieldUpdateOperationsInput | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutStudentsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutStudentsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutStudentsNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type tutorsUpsertWithoutUsersInput = {
    update: XOR<tutorsUpdateWithoutUsersInput, tutorsUncheckedUpdateWithoutUsersInput>
    create: XOR<tutorsCreateWithoutUsersInput, tutorsUncheckedCreateWithoutUsersInput>
    where?: tutorsWhereInput
  }

  export type tutorsUpdateToOneWithWhereWithoutUsersInput = {
    where?: tutorsWhereInput
    data: XOR<tutorsUpdateWithoutUsersInput, tutorsUncheckedUpdateWithoutUsersInput>
  }

  export type tutorsUpdateWithoutUsersInput = {
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutTutorsNestedInput
  }

  export type tutorsUncheckedUpdateWithoutUsersInput = {
    tutor_id?: IntFieldUpdateOperationsInput | number
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    qualification?: StringFieldUpdateOperationsInput | string
    background_check_status?: NullableStringFieldUpdateOperationsInput | string | null
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avg_rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_sessions?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_details?: NullableJsonNullValueInput | InputJsonValue
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateManyWithoutTutorsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_availability?: tutor_availabilityUncheckedUpdateManyWithoutTutorsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutTutorsNestedInput
  }

  export type group_session_participantsCreateManyGroup_sessionsInput = {
    participation_id?: number
    student_id: number
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
  }

  export type group_session_participantsUpdateWithoutGroup_sessionsInput = {
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    students?: studentsUpdateOneRequiredWithoutGroup_session_participantsNestedInput
  }

  export type group_session_participantsUncheckedUpdateWithoutGroup_sessionsInput = {
    participation_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_session_participantsUncheckedUpdateManyWithoutGroup_sessionsInput = {
    participation_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_resourcesCreateManyResourcesInput = {
    session_resource_id?: number
    session_id: number
  }

  export type session_resourcesUpdateWithoutResourcesInput = {
    sessions?: sessionsUpdateOneRequiredWithoutSession_resourcesNestedInput
  }

  export type session_resourcesUncheckedUpdateWithoutResourcesInput = {
    session_resource_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
  }

  export type session_resourcesUncheckedUpdateManyWithoutResourcesInput = {
    session_resource_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
  }

  export type paymentsCreateManySessionsInput = {
    payment_id?: number
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_method: string
    transaction_id?: string | null
    status: string
    platform_fee: Decimal | DecimalJsLike | number | string
    tutor_payout: Decimal | DecimalJsLike | number | string
    payout_date?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_date?: Date | string | null
    refund_reason?: string | null
  }

  export type session_notesCreateManySessionsInput = {
    note_id?: number
    author_id: number
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
  }

  export type session_resourcesCreateManySessionsInput = {
    session_resource_id?: number
    resource_id: number
  }

  export type paymentsUpdateWithoutSessionsInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateWithoutSessionsInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutSessionsInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    platform_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tutor_payout?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type session_notesUpdateWithoutSessionsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: usersUpdateOneRequiredWithoutSession_notesNestedInput
  }

  export type session_notesUncheckedUpdateWithoutSessionsInput = {
    note_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_notesUncheckedUpdateManyWithoutSessionsInput = {
    note_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_resourcesUpdateWithoutSessionsInput = {
    resources?: resourcesUpdateOneRequiredWithoutSession_resourcesNestedInput
  }

  export type session_resourcesUncheckedUpdateWithoutSessionsInput = {
    session_resource_id?: IntFieldUpdateOperationsInput | number
    resource_id?: IntFieldUpdateOperationsInput | number
  }

  export type session_resourcesUncheckedUpdateManyWithoutSessionsInput = {
    session_resource_id?: IntFieldUpdateOperationsInput | number
    resource_id?: IntFieldUpdateOperationsInput | number
  }

  export type group_session_participantsCreateManyStudentsInput = {
    participation_id?: number
    group_session_id: number
    registration_time?: Date | string | null
    payment_status?: string | null
    attended?: boolean | null
  }

  export type session_ratingsCreateManyStudentsInput = {
    rating_id?: number
    session_id: number
    tutor_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type sessionsCreateManyStudentsInput = {
    session_id?: number
    tutor_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsCreateManyStudentsInput = {
    interest_id?: number
    subject_id: number
    interest_level?: string | null
  }

  export type subscriptionsCreateManyStudentsInput = {
    subscription_id?: number
    plan_name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    billing_cycle: string
    sessions_included?: number | null
    hours_included?: Decimal | DecimalJsLike | number | string | null
    start_date: Date | string
    end_date?: Date | string | null
    is_active?: boolean | null
    auto_renew?: boolean | null
    payment_method?: string | null
    last_billing_date?: Date | string | null
    next_billing_date?: Date | string | null
  }

  export type group_session_participantsUpdateWithoutStudentsInput = {
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    group_sessions?: group_sessionsUpdateOneRequiredWithoutGroup_session_participantsNestedInput
  }

  export type group_session_participantsUncheckedUpdateWithoutStudentsInput = {
    participation_id?: IntFieldUpdateOperationsInput | number
    group_session_id?: IntFieldUpdateOperationsInput | number
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_session_participantsUncheckedUpdateManyWithoutStudentsInput = {
    participation_id?: IntFieldUpdateOperationsInput | number
    group_session_id?: IntFieldUpdateOperationsInput | number
    registration_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_ratingsUpdateWithoutStudentsInput = {
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: sessionsUpdateOneRequiredWithoutSession_ratingsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSession_ratingsNestedInput
  }

  export type session_ratingsUncheckedUpdateWithoutStudentsInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_ratingsUncheckedUpdateManyWithoutStudentsInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUpdateWithoutStudentsInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutStudentsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateManyWithoutStudentsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsUpdateWithoutStudentsInput = {
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: subjectsUpdateOneRequiredWithoutStudent_subject_interestsNestedInput
  }

  export type student_subject_interestsUncheckedUpdateWithoutStudentsInput = {
    interest_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_subject_interestsUncheckedUpdateManyWithoutStudentsInput = {
    interest_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subscriptionsUpdateWithoutStudentsInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsUncheckedUpdateWithoutStudentsInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsUncheckedUpdateManyWithoutStudentsInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billing_cycle?: StringFieldUpdateOperationsInput | string
    sessions_included?: NullableIntFieldUpdateOperationsInput | number | null
    hours_included?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auto_renew?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    last_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subjectsCreateManySubject_categoriesInput = {
    subject_id?: number
    name: string
    description?: string | null
    difficulty_level?: string | null
  }

  export type subjectsUpdateWithoutSubject_categoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutSubject_categoriesInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
    group_sessions?: group_sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    resources?: resourcesUncheckedUpdateManyWithoutSubjectsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutSubjectsNestedInput
    student_subject_interests?: student_subject_interestsUncheckedUpdateManyWithoutSubjectsNestedInput
    tutor_subjects?: tutor_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateManyWithoutSubject_categoriesInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type group_sessionsCreateManySubjectsInput = {
    group_session_id?: number
    tutor_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
  }

  export type resourcesCreateManySubjectsInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    uploaded_by: number
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type sessionsCreateManySubjectsInput = {
    session_id?: number
    tutor_id: number
    student_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsCreateManySubjectsInput = {
    interest_id?: number
    student_id: number
    interest_level?: string | null
  }

  export type tutor_subjectsCreateManySubjectsInput = {
    tutor_subject_id?: number
    tutor_id: number
    proficiency_level: string
    verified?: boolean | null
  }

  export type group_sessionsUpdateWithoutSubjectsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutGroup_sessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsUncheckedUpdateWithoutSubjectsInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsUncheckedUpdateManyWithoutSubjectsInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type resourcesUpdateWithoutSubjectsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutResourcesNestedInput
    session_resources?: session_resourcesUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateWithoutSubjectsInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_resources?: session_resourcesUncheckedUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateManyWithoutSubjectsInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUpdateWithoutSubjectsInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    tutors?: tutorsUpdateOneRequiredWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutSubjectsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateManyWithoutSubjectsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type student_subject_interestsUpdateWithoutSubjectsInput = {
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_subject_interestsNestedInput
  }

  export type student_subject_interestsUncheckedUpdateWithoutSubjectsInput = {
    interest_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_subject_interestsUncheckedUpdateManyWithoutSubjectsInput = {
    interest_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    interest_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tutor_subjectsUpdateWithoutSubjectsInput = {
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tutors?: tutorsUpdateOneRequiredWithoutTutor_subjectsNestedInput
  }

  export type tutor_subjectsUncheckedUpdateWithoutSubjectsInput = {
    tutor_subject_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tutor_subjectsUncheckedUpdateManyWithoutSubjectsInput = {
    tutor_subject_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: IntFieldUpdateOperationsInput | number
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_sessionsCreateManyTutorsInput = {
    group_session_id?: number
    subject_id: number
    title: string
    description?: string | null
    start_time: Date | string
    end_time: Date | string
    max_participants: number
    current_participants?: number | null
    price_per_student: Decimal | DecimalJsLike | number | string
    meeting_url?: string | null
    status?: string
    created_at?: Date | string | null
  }

  export type session_ratingsCreateManyTutorsInput = {
    rating_id?: number
    session_id: number
    student_id: number
    rating: Decimal | DecimalJsLike | number | string
    feedback?: string | null
    created_at?: Date | string | null
  }

  export type sessionsCreateManyTutorsInput = {
    session_id?: number
    student_id: number
    subject_id: number
    start_time: Date | string
    end_time: Date | string
    duration_minutes?: number | null
    hourly_rate: Decimal | DecimalJsLike | number | string
    session_cost?: Decimal | DecimalJsLike | number | string | null
    status?: string
    meeting_url?: string | null
    notes?: string | null
    materials_url?: string | null
    created_at?: Date | string | null
    canceled_at?: Date | string | null
    cancellation_reason?: string | null
    cancellation_fee?: Decimal | DecimalJsLike | number | string | null
  }

  export type tutor_availabilityCreateManyTutorsInput = {
    availability_id?: number
    day_of_week: number
    start_time: Date | string
    end_time: Date | string
    is_recurring?: boolean | null
    specific_date?: Date | string | null
  }

  export type tutor_subjectsCreateManyTutorsInput = {
    tutor_subject_id?: number
    subject_id: number
    proficiency_level: string
    verified?: boolean | null
  }

  export type group_sessionsUpdateWithoutTutorsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_session_participants?: group_session_participantsUpdateManyWithoutGroup_sessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsUncheckedUpdateWithoutTutorsInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_session_participants?: group_session_participantsUncheckedUpdateManyWithoutGroup_sessionsNestedInput
  }

  export type group_sessionsUncheckedUpdateManyWithoutTutorsInput = {
    group_session_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    max_participants?: IntFieldUpdateOperationsInput | number
    current_participants?: NullableIntFieldUpdateOperationsInput | number | null
    price_per_student?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_ratingsUpdateWithoutTutorsInput = {
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: sessionsUpdateOneRequiredWithoutSession_ratingsNestedInput
    students?: studentsUpdateOneRequiredWithoutSession_ratingsNestedInput
  }

  export type session_ratingsUncheckedUpdateWithoutTutorsInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_ratingsUncheckedUpdateManyWithoutTutorsInput = {
    rating_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUpdateWithoutTutorsInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUpdateManyWithoutSessionsNestedInput
    students?: studentsUpdateOneRequiredWithoutSessionsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutTutorsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutSessionsNestedInput
    session_notes?: session_notesUncheckedUpdateManyWithoutSessionsNestedInput
    session_ratings?: session_ratingsUncheckedUpdateOneWithoutSessionsNestedInput
    session_resources?: session_resourcesUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateManyWithoutTutorsInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    hourly_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    session_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    meeting_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    materials_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancellation_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type tutor_availabilityUpdateWithoutTutorsInput = {
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_availabilityUncheckedUpdateWithoutTutorsInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_availabilityUncheckedUpdateManyWithoutTutorsInput = {
    availability_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_recurring?: NullableBoolFieldUpdateOperationsInput | boolean | null
    specific_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tutor_subjectsUpdateWithoutTutorsInput = {
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    subjects?: subjectsUpdateOneRequiredWithoutTutor_subjectsNestedInput
  }

  export type tutor_subjectsUncheckedUpdateWithoutTutorsInput = {
    tutor_subject_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tutor_subjectsUncheckedUpdateManyWithoutTutorsInput = {
    tutor_subject_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    proficiency_level?: StringFieldUpdateOperationsInput | string
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type messagesCreateManyUsers_messages_sender_idTousersInput = {
    message_id?: number
    recipient_id: number
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
  }

  export type messagesCreateManyUsers_messages_recipient_idTousersInput = {
    message_id?: number
    sender_id: number
    content: string
    sent_at?: Date | string | null
    read_at?: Date | string | null
    attachment_url?: string | null
  }

  export type notificationsCreateManyUsersInput = {
    notification_id?: number
    title: string
    content: string
    notification_type: string
    related_id?: number | null
    created_at?: Date | string | null
    read_at?: Date | string | null
    is_read?: boolean | null
  }

  export type resourcesCreateManyUsersInput = {
    resource_id?: number
    title: string
    description?: string | null
    url?: string | null
    file_path?: string | null
    subject_id?: number | null
    resource_type: string
    is_public?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type session_notesCreateManyUsersInput = {
    note_id?: number
    session_id: number
    content: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_private?: boolean | null
  }

  export type messagesUpdateWithoutUsers_messages_sender_idTousersInput = {
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    users_messages_recipient_idTousers?: usersUpdateOneRequiredWithoutMessages_messages_recipient_idTousersNestedInput
  }

  export type messagesUncheckedUpdateWithoutUsers_messages_sender_idTousersInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    recipient_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_sender_idTousersInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    recipient_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesUpdateWithoutUsers_messages_recipient_idTousersInput = {
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    users_messages_sender_idTousers?: usersUpdateOneRequiredWithoutMessages_messages_sender_idTousersNestedInput
  }

  export type messagesUncheckedUpdateWithoutUsers_messages_recipient_idTousersInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_recipient_idTousersInput = {
    message_id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    notification_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    notification_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    notification_type?: StringFieldUpdateOperationsInput | string
    related_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type resourcesUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subjects?: subjectsUpdateOneWithoutResourcesNestedInput
    session_resources?: session_resourcesUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateWithoutUsersInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_resources?: session_resourcesUncheckedUpdateManyWithoutResourcesNestedInput
  }

  export type resourcesUncheckedUpdateManyWithoutUsersInput = {
    resource_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    resource_type?: StringFieldUpdateOperationsInput | string
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type session_notesUpdateWithoutUsersInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: sessionsUpdateOneRequiredWithoutSession_notesNestedInput
  }

  export type session_notesUncheckedUpdateWithoutUsersInput = {
    note_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type session_notesUncheckedUpdateManyWithoutUsersInput = {
    note_id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_private?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}